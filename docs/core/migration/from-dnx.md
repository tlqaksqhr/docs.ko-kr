---
title: "DNX에서 .NET Core CLI로 마이그레이션"
description: "DNX 도구 사용에서 .NET Core CLI 도구로 마이그레이션합니다."
keywords: .NET, .NET Core
author: blackdwarf
ms.author: mairaw
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net-core
ms.devlang: dotnet
ms.assetid: c0d70120-78c8-4d26-bb3c-801f42fc2366
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: e94ab83bb6638438e0a98020a5b42755322af5da
ms.contentlocale: ko-kr
ms.lasthandoff: 07/28/2017

---

# <a name="migrating-from-dnx-to-net-core-cli-projectjson"></a><span data-ttu-id="8e22e-104">DNX에서.NET Core CLI(project.json)로 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="8e22e-104">Migrating from DNX to .NET Core CLI (project.json)</span></span>

## <a name="overview"></a><span data-ttu-id="8e22e-105">개요</span><span class="sxs-lookup"><span data-stu-id="8e22e-105">Overview</span></span>
<span data-ttu-id="8e22e-106">.NET Core 및 ASP.NET Core 1.0의 RC1 릴리스에서 DNX 도구를 발표했습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-106">The RC1 release of .NET Core and ASP.NET Core 1.0 introduced DNX tooling.</span></span> <span data-ttu-id="8e22e-107">.NET Core 및 ASP.NET Core 1.0의 RC2 릴리스에서 DNX에서 .NET Core CLI로 전환했습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-107">The RC2 release of .NET Core and ASP.NET Core 1.0 moved from DNX to the .NET Core CLI.</span></span>

<span data-ttu-id="8e22e-108">가볍게 복습하는 의미에서 DNX에 대해 정리해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-108">As a slight refresher, let's recap what DNX was about.</span></span> <span data-ttu-id="8e22e-109">DNX는 .NET Core, 좀 더 구체적으로 말해서 ASP.NET Core 1.0 응용 프로그램 빌드에 사용된 런타임 및 도구 집합이었습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-109">DNX was a runtime and a toolset used to build .NET Core and, more specifically, ASP.NET Core 1.0 applications.</span></span> <span data-ttu-id="8e22e-110">DNX는 3개의 주요 부분으로 구성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-110">It consisted of 3 main pieces:</span></span>

1. <span data-ttu-id="8e22e-111">DNVM - DNX를 얻기 위한 설치 스크립트</span><span class="sxs-lookup"><span data-stu-id="8e22e-111">DNVM - an install script for obtaining DNX</span></span>
2. <span data-ttu-id="8e22e-112">DNX(Dotnet 실행 런타임) - 코드를 실행하는 런타임</span><span class="sxs-lookup"><span data-stu-id="8e22e-112">DNX (Dotnet Execution Runtime) - the runtime that executes your code</span></span>
3. <span data-ttu-id="8e22e-113">DNU(Dotnet 개발자 유틸리티) - 종속성을 관리하고 응용 프로그램을 빌드 및 게시하기 위한 도구</span><span class="sxs-lookup"><span data-stu-id="8e22e-113">DNU (Dotnet Developer Utility) - tooling for managing dependencies, building and publishing your applications</span></span>

<span data-ttu-id="8e22e-114">CLI의 도입에 따라 이제 위의 모든 요소는 단일 도구 집합의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-114">With the introduction of the CLI, all of the above are now part of a single toolset.</span></span> <span data-ttu-id="8e22e-115">그러나 DNX는 RC1 시기에 사용 가능했으므로 이를 사용해 빌드한 프로젝트가 있고, 새 CLI 도구에서 해당 프로젝트를 이동하고자 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-115">However, since DNX was available in RC1 timeframe, you might have projects that were built using it that you would want to move off to the new CLI tooling.</span></span> 

<span data-ttu-id="8e22e-116">이 마이그레이션 가이드에서는 DNX에서 .NET Core CLI로 프로젝트를 마이그레이션하는 방법의 필수 사항을 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-116">This migration guide will cover the essentials on how to migrate projects off of DNX and onto .NET Core CLI.</span></span> <span data-ttu-id="8e22e-117">.NET Core에서 막 프로젝트를 시작하는 경우 이 문서를 건너뛸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-117">If you are just starting a project on .NET Core from scratch, you can freely skip this document.</span></span> 

## <a name="main-changes-in-the-tooling"></a><span data-ttu-id="8e22e-118">도구의 주요 변경 사항</span><span class="sxs-lookup"><span data-stu-id="8e22e-118">Main changes in the tooling</span></span>
<span data-ttu-id="8e22e-119">먼저 설명해야 할 몇 가지 일반적인 도구 변경 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-119">There are some general changes in the tooling that should be outlined first.</span></span> 

### <a name="no-more-dnvm"></a><span data-ttu-id="8e22e-120">더 이상 DNVM 없음</span><span class="sxs-lookup"><span data-stu-id="8e22e-120">No more DNVM</span></span>
<span data-ttu-id="8e22e-121">DNVM(*DotNet Version Manager*)은 컴퓨터에 DNX를 설치하는 데 사용된 bash/PowerShell 스크립트였습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-121">DNVM, short for *DotNet Version Manager* was a bash/PowerShell script used to install a DNX on your machine.</span></span> <span data-ttu-id="8e22e-122">DNVM을 통해 사용자는 지정한 피드(또는 기본 피드)에서 필요한 DNX를 가져와 특정 DNX를 "활성"으로 표시하여 특정 세션의 $PATH에 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-122">It helped users get the DNX they need from the feed they specified (or default ones) as well as mark a certain DNX "active", which would put it on the $PATH for the given session.</span></span> <span data-ttu-id="8e22e-123">이렇게 하면 다양한 도구를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-123">This would allow you to use the various tools.</span></span>

<span data-ttu-id="8e22e-124">DNVM은 기능 집합이 .NET Core CLI 도구에 포함된 변경 사항과 중복되므로 단종되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-124">DNVM was discontinued because its feature set was made redundant by changes coming in the .NET Core CLI tools.</span></span>

<span data-ttu-id="8e22e-125">CLI 도구는 다음과 같은 두 가지 주요 방법으로 패키지됩니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-125">The CLI tools come packaged in two main ways:</span></span>

1. <span data-ttu-id="8e22e-126">지정된 플랫폼에 대한 기본 설치 관리자</span><span class="sxs-lookup"><span data-stu-id="8e22e-126">Native installers for a given platform</span></span>
2. <span data-ttu-id="8e22e-127">다른 상황(예: CI 서버)에 대한 설치 스크립트</span><span class="sxs-lookup"><span data-stu-id="8e22e-127">Install script for other situations (like CI servers)</span></span>

<span data-ttu-id="8e22e-128">이러한 점에서 DNVM 설치 기능이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-128">Given this, the DNVM install features are not needed.</span></span> <span data-ttu-id="8e22e-129">그러나 런타임 선택 기능은 어떤가요?</span><span class="sxs-lookup"><span data-stu-id="8e22e-129">But what about the runtime selection features?</span></span> 

<span data-ttu-id="8e22e-130">특정 버전의 패키지를 종속성에 추가하여 `project.json`에서 런타임을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-130">You reference a runtime in your `project.json` by adding a package of a certain version to your dependencies.</span></span> <span data-ttu-id="8e22e-131">이 변경으로 응용 프로그램은 새로운 런타임 비트를 사용할 수 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-131">With this change, your application will be able to use the new runtime bits.</span></span> <span data-ttu-id="8e22e-132">이러한 비트를 컴퓨터로 가져오는 것은 CLI와 마찬가지입니다. 지원되는 기본 설치 관리자 중 하나 또는 설치 스크립트를 통해 런타임을 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-132">Getting these bits to your machine is the same as with the CLI: you install the runtime via one of the native installers it supports or via its install script.</span></span> 

### <a name="different-commands"></a><span data-ttu-id="8e22e-133">다양한 명령</span><span class="sxs-lookup"><span data-stu-id="8e22e-133">Different commands</span></span>
<span data-ttu-id="8e22e-134">DNX를 사용한 경우 세 부분(DNX, DNU 또는 DNVM) 중 하나에서 몇 가지 명령을 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-134">If you were using DNX, you used some commands from one of its three parts (DNX, DNU or DNVM).</span></span> <span data-ttu-id="8e22e-135">CLI에서는 이러한 명령 중 몇 개는 변경되고, 일부는 사용할 수 없으며, 일부는 동일하지만 의미 체계가 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-135">With the CLI, some of these commands change, some are not available and some are the same but have slightly different semantics.</span></span> 

<span data-ttu-id="8e22e-136">다음 표에서는 DNX/DNU 명령 및 해당 CLI 명령 간의 매핑을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-136">The table below shows the mapping between the DNX/DNU commands and their CLI counterparts.</span></span>


| <span data-ttu-id="8e22e-137">DNX 명령</span><span class="sxs-lookup"><span data-stu-id="8e22e-137">DNX command</span></span>                       | <span data-ttu-id="8e22e-138">CLI 명령</span><span class="sxs-lookup"><span data-stu-id="8e22e-138">CLI command</span></span>       | <span data-ttu-id="8e22e-139">설명</span><span class="sxs-lookup"><span data-stu-id="8e22e-139">Description</span></span>                                                                                                       |
|--------------------------------   |----------------   |-----------------------------------------------------------------------------------------------------------------  |
| <span data-ttu-id="8e22e-140">dnx run</span><span class="sxs-lookup"><span data-stu-id="8e22e-140">dnx run</span></span>                           | <span data-ttu-id="8e22e-141">dotnet run</span><span class="sxs-lookup"><span data-stu-id="8e22e-141">dotnet run</span></span>        | <span data-ttu-id="8e22e-142">소스에서 코드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-142">Run code from source.</span></span>                                                                                             |
| <span data-ttu-id="8e22e-143">dnu build</span><span class="sxs-lookup"><span data-stu-id="8e22e-143">dnu build</span></span>                         | <span data-ttu-id="8e22e-144">dotnet build</span><span class="sxs-lookup"><span data-stu-id="8e22e-144">dotnet build</span></span>      | <span data-ttu-id="8e22e-145">코드의 IL 바이너리를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-145">Build an IL binary of your code.</span></span>                                                                                  |
| <span data-ttu-id="8e22e-146">dnu pack</span><span class="sxs-lookup"><span data-stu-id="8e22e-146">dnu pack</span></span>                          | <span data-ttu-id="8e22e-147">dotnet pack</span><span class="sxs-lookup"><span data-stu-id="8e22e-147">dotnet pack</span></span>       | <span data-ttu-id="8e22e-148">코드의 NuGet 패키지를 패키지합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-148">Package up a NuGet package of your code.</span></span>                                                                          |
| <span data-ttu-id="8e22e-149">dnx \[command](예: "dnx web")</span><span class="sxs-lookup"><span data-stu-id="8e22e-149">dnx \[command] (for example, "dnx web")</span></span>   | <span data-ttu-id="8e22e-150">해당 없음\*</span><span class="sxs-lookup"><span data-stu-id="8e22e-150">N/A\*</span></span>             | <span data-ttu-id="8e22e-151">DNX 세계에서 project.json에 정의된 대로 명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-151">In DNX world, run a command as defined in the project.json.</span></span>                                                       |
| <span data-ttu-id="8e22e-152">dnu install</span><span class="sxs-lookup"><span data-stu-id="8e22e-152">dnu install</span></span>                       | <span data-ttu-id="8e22e-153">해당 없음\*</span><span class="sxs-lookup"><span data-stu-id="8e22e-153">N/A\*</span></span>             | <span data-ttu-id="8e22e-154">DNX 세계에서 종속성으로 패키지를 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-154">In the DNX world, install a package as a dependency.</span></span>                                                              |
| <span data-ttu-id="8e22e-155">dnu restore</span><span class="sxs-lookup"><span data-stu-id="8e22e-155">dnu restore</span></span>                       | <span data-ttu-id="8e22e-156">dotnet restore</span><span class="sxs-lookup"><span data-stu-id="8e22e-156">dotnet restore</span></span>    | <span data-ttu-id="8e22e-157">Project.json에 지정된 종속성을 복원합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-157">Restore dependencies specified in your project.json.</span></span>                                                              |
| <span data-ttu-id="8e22e-158">dnu publish</span><span class="sxs-lookup"><span data-stu-id="8e22e-158">dnu publish</span></span>                       | <span data-ttu-id="8e22e-159">dotnet publish</span><span class="sxs-lookup"><span data-stu-id="8e22e-159">dotnet publish</span></span>    | <span data-ttu-id="8e22e-160">배포할 응용 프로그램을 세 가지 형식(이식 가능, 이식 가능과 네이티브, 독립 실행형) 중 하나로 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-160">Publish your application for deployment in one of the three forms (portable, portable with native and standalone).</span></span>    |
| <span data-ttu-id="8e22e-161">dnu wrap</span><span class="sxs-lookup"><span data-stu-id="8e22e-161">dnu wrap</span></span>                          | <span data-ttu-id="8e22e-162">해당 없음\*</span><span class="sxs-lookup"><span data-stu-id="8e22e-162">N/A\*</span></span>             | <span data-ttu-id="8e22e-163">DNX 세계에서 csproj의 project.json을 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-163">In DNX world, wrap a project.json in csproj.</span></span>                                                                      |
| <span data-ttu-id="8e22e-164">dnu commands</span><span class="sxs-lookup"><span data-stu-id="8e22e-164">dnu commands</span></span>                      | <span data-ttu-id="8e22e-165">해당 없음\*</span><span class="sxs-lookup"><span data-stu-id="8e22e-165">N/A\*</span></span>             | <span data-ttu-id="8e22e-166">DNX 세계에서 전역적으로 설치된 명령을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-166">In DNX world, manage the globally installed commands.</span></span>                                                             |

<span data-ttu-id="8e22e-167">(\*) - 이 기능은 설계상 CLI에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-167">(\*) - these features are not supported in the CLI by design.</span></span> 

## <a name="dnx-features-that-are-not-supported"></a><span data-ttu-id="8e22e-168">지원되지 않는 DNX 기능</span><span class="sxs-lookup"><span data-stu-id="8e22e-168">DNX features that are not supported</span></span>
<span data-ttu-id="8e22e-169">위의 표에서 알 수 있듯이, 적어도 당분간은 CLI에서 지원하지 않기로 한 DNX 세계의 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-169">As the table above shows, there are features from the DNX world that we decided not to support in the CLI, at least for the time being.</span></span> <span data-ttu-id="8e22e-170">이 섹션에서는 그러한 기능 중 가장 중요한 것을 살펴보고, 지원 중단 배후의 원리, 그리고 그러한 기능이 필요한 경우의 해결 방법을 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-170">This section will go through the most important ones and outline the rationale behind not supporting them as well as workarounds if you do need them.</span></span>

### <a name="global-commands"></a><span data-ttu-id="8e22e-171">전역 명령</span><span class="sxs-lookup"><span data-stu-id="8e22e-171">Global commands</span></span>
<span data-ttu-id="8e22e-172">DNU는 "명령 전역"이라는 개념과 함께 제공되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-172">DNU came with a concept called "global commands".</span></span> <span data-ttu-id="8e22e-173">이는 응용 프로그램 실행을 위해 지정한 DNX를 호출하는 셸 스크립트와 함께 NuGet 패키지로 패키지된 콘솔 응용 프로그램이었습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-173">These were, essentially, console applications packaged up as NuGet packages with a shell script that would invoke the DNX you specified to run the application.</span></span> 

<span data-ttu-id="8e22e-174">CLI는 이 개념을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-174">The CLI does not support this concept.</span></span> <span data-ttu-id="8e22e-175">대신 친숙한 `dotnet <command>` 구문을 사용하여 호출할 수 있는 프로젝트별 명령을 추가하는 개념을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-175">It does, however, support the concept of adding per-project commands that can be invoked using the familiar `dotnet <command>` syntax.</span></span>

### <a name="installing-dependencies"></a><span data-ttu-id="8e22e-176">종속성 설치</span><span class="sxs-lookup"><span data-stu-id="8e22e-176">Installing dependencies</span></span>
<span data-ttu-id="8e22e-177">v1부터 .NET Core CLI 도구에는 종속성 설치를 위한 `install` 명령이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-177">As of v1, the .NET Core CLI tools don't have an `install` command for installing dependencies.</span></span> <span data-ttu-id="8e22e-178">NuGet에서 패키지를 설치하려면 이를 종속성으로 `project.json` 파일에 추가한 후 `dotnet restore`를 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-178">In order to install a package from NuGet, you would need to add it as a dependency to your `project.json` file and then run `dotnet restore`.</span></span> 

### <a name="running-your-code"></a><span data-ttu-id="8e22e-179">코드 실행</span><span class="sxs-lookup"><span data-stu-id="8e22e-179">Running your code</span></span>
<span data-ttu-id="8e22e-180">코드를 실행하는 두 가지 중요한 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-180">There are two main ways to run your code.</span></span> <span data-ttu-id="8e22e-181">하나는 소스에서 `dotnet run`으로 실행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-181">One is from source, with `dotnet run`.</span></span> <span data-ttu-id="8e22e-182">`dnx run`과는 달리, 이 경우 메모리 내 컴파일을 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-182">Unlike `dnx run`, this will not do any in-memory compilation.</span></span> <span data-ttu-id="8e22e-183">실제로 `dotnet build`를 호출하여 코드를 빌드하고 빌드된 바이너리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-183">It will actually invoke `dotnet build` to build your code and then run the built binary.</span></span> 

<span data-ttu-id="8e22e-184">또 다른 방법은 `dotnet` 자체를 사용하여 코드를 실행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-184">Another way is using the `dotnet` itself to run your code.</span></span> <span data-ttu-id="8e22e-185">이는 어셈블리에 경로를 제공하여 수행됩니다(`dotnet path/to/an/assembly.dll`).</span><span class="sxs-lookup"><span data-stu-id="8e22e-185">This is done by providing a path to your assembly: `dotnet path/to/an/assembly.dll`.</span></span> 

## <a name="migrating-your-dnx-project-to-net-core-cli"></a><span data-ttu-id="8e22e-186">DNX 프로젝트를 .NET Core CLI로 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="8e22e-186">Migrating your DNX project to .NET Core CLI</span></span>
<span data-ttu-id="8e22e-187">코드로 작업할 때 새 명령을 사용하는 것 외에도 DNX에서 마이그레이션할 때 세 가지 중요한 사항이 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-187">In addition to using new commands when working with your code, there are three major things left in migrating from DNX:</span></span>

1. <span data-ttu-id="8e22e-188">CLI를 사용할 수 있도록 `global.json` 파일을 마이그레이션합니다(있는 경우).</span><span class="sxs-lookup"><span data-stu-id="8e22e-188">Migrate the `global.json` file if you have it to be able to use CLI.</span></span>
2. <span data-ttu-id="8e22e-189">프로젝트 파일(`project.json`) 자체를 CLI 도구로 마이그레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-189">Migrating the project file (`project.json`) itself to the CLI tooling.</span></span>
3. <span data-ttu-id="8e22e-190">DNX API를 해당 BCL API로 마이그레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-190">Migrating off of any DNX APIs to their BCL counterparts.</span></span> 

### <a name="changing-the-globaljson-file"></a><span data-ttu-id="8e22e-191">Global.json 파일 변경</span><span class="sxs-lookup"><span data-stu-id="8e22e-191">Changing the global.json file</span></span>
<span data-ttu-id="8e22e-192">`global.json` 파일은 RC1 및 RC2(또는 그 이상) 프로젝트 모두에 대한 솔루션 파일 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-192">The `global.json` file acts like a solution file for both the RC1 and RC2 (or later) projects.</span></span> <span data-ttu-id="8e22e-193">Visual Studio는 물론 CLI 도구를 RC1 및 그 이후 버전과 차별화하기 위해, `"sdk": { "version" }` 속성을 사용하여 프로젝트가 RC1인지 또는 그 이후 버전인지를 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-193">In order for the CLI tools (as well as Visual Studio) to differentiate between RC1 and later versions, they use the `"sdk": { "version" }` property to make the distinction which project is RC1 or later.</span></span> <span data-ttu-id="8e22e-194">`global.json`에 이 노드가 없는 경우 최신으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-194">If `global.json` doesn't have this node at all, it is assumed to be the latest.</span></span> 

<span data-ttu-id="8e22e-195">`global.json` 파일을 업데이트하려면 속성을 제거하거나 사용할 정확한 도구 버전으로 설정합니다(이 경우**1.0.0-preview2-003121**).</span><span class="sxs-lookup"><span data-stu-id="8e22e-195">In order to update the `global.json` file, either remove the property or set it to the exact version of the tools that you wish to use, in this case **1.0.0-preview2-003121**:</span></span>

```json
{
    "sdk": {
        "version": "1.0.0-preview2-003121"
    }
}
```

### <a name="migrating-the-project-file"></a><span data-ttu-id="8e22e-196">프로젝트 파일 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="8e22e-196">Migrating the project file</span></span>
<span data-ttu-id="8e22e-197">CLI와 DNX는 둘 다 `project.json` 파일 기반의 동일한 기본 프로젝트 시스템을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-197">The CLI and DNX both use the same basic project system based on `project.json` file.</span></span> <span data-ttu-id="8e22e-198">프로젝트 파일의 구문 및 의미 체계는 시나리오에 따른 약간의 차이를 제외하면 상당 부분 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-198">The syntax and the semantics of the project file are pretty much the same, with small differences based on the scenarios.</span></span> <span data-ttu-id="8e22e-199">또한 [스키마 파일](http://json.schemastore.org/project)에서 확인할 수 있는 몇 가지 스키마 변경 내용이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-199">There are also some changes to the schema which you can see in the [schema file](http://json.schemastore.org/project).</span></span>

<span data-ttu-id="8e22e-200">콘솔 응용 프로그램을 작성하는 경우 프로젝트 파일에 다음 조각을 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-200">If you are building a console application, you need to add the following snippet to your project file:</span></span>

```json
"buildOptions": {
    "emitEntryPoint": true
}
```

<span data-ttu-id="8e22e-201">이렇게 하면 `dotnet build`는 응용 프로그램의 진입점을 내보내서 코드 실행이 효과적으로 수행되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-201">This instructs `dotnet build` to emit an entry point for your application, effectively making your code runnable.</span></span> <span data-ttu-id="8e22e-202">클래스 라이브러리를 빌드하는 경우 위 섹션을 생략하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-202">If you are building a class library, simply omit the above section.</span></span> <span data-ttu-id="8e22e-203">물론 위 코드 조각을 `project.json` 파일에 추가한 후 정적 진입점을 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-203">Of course, once you add the above snippet to your `project.json` file, you need to add a static entry point.</span></span> <span data-ttu-id="8e22e-204">DNX에서 나오면 DNX가 지원하는 DI를 더 이상 사용할 수 없으므로 `static void Main()`이 기본 .NET 진입점이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-204">With the move off DNX, the DI services it provided are no longer available and thus this needs to be a basic .NET entry point: `static void Main()`.</span></span>

<span data-ttu-id="8e22e-205">`project.json`에 "commands" 섹션이 있는 경우 이를 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-205">If you have a "commands" section in your `project.json`, you can remove it.</span></span> <span data-ttu-id="8e22e-206">DNU 명령으로 사용되었던 명령 중 일부(예: Entity Framework CLI 명령)는 CLI에 프로젝트별 확장으로 이식됩니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-206">Some of the commands that used to exist as DNU commands, such as Entity Framework CLI commands, are being ported to be per-project extensions to the CLI.</span></span> <span data-ttu-id="8e22e-207">프로젝트에서 사용하는 명령을 빌드한 경우 이를 CLI 확장으로 교체해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-207">If you built your own commands that you are using in your projects, you need to replace them with CLI extensions.</span></span> <span data-ttu-id="8e22e-208">이 경우 `project.json`의 `commands` 노드를 `tools` 노드로 교체하고, 도구 종속성을 나열해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-208">In this case, the `commands` node in `project.json` needs to be replaced by the `tools` node and it needs to list the tools dependencies.</span></span> 

<span data-ttu-id="8e22e-209">이러한 작업이 완료되면 어떤 이식성 유형을 앱에 사용할지를 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-209">After these things are done, you need to decide which type of portability you wish for you app.</span></span> <span data-ttu-id="8e22e-210">.NET Core에서는 선택 가능한 폭넓은 이식성 옵션이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-210">With .NET Core, we have invested into providing a spectrum of portability options that you can choose from.</span></span> <span data-ttu-id="8e22e-211">예를 들어 완전히 *이식 가능한* 응용 프로그램을 원할 수도 있고 *자체 포함* 응용 프로그램을 원할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-211">For instance, you may want to have a fully *portable* application or you may want to have a *self-contained* application.</span></span> <span data-ttu-id="8e22e-212">이식 가능한 응용 프로그램 옵션은 .NET Framework 응용 프로그램 작업과 유사하며, 대상 컴퓨터(.NET Core)에서 실행하기 위한 공유 구성 요소가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-212">The portable application option is more like .NET Framework applications work: it needs a shared component to execute it on the target machine (.NET Core).</span></span> <span data-ttu-id="8e22e-213">자체 포함 응용 프로그램의 경우 .NET Core를 대상에 설치할 필요가 없지만, 지원할 각 OS에 대해 하나의 응용 프로그램을 생성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-213">The self-contained application doesn't require .NET Core to be installed on the target, but you have to produce one application for each OS you wish to support.</span></span> <span data-ttu-id="8e22e-214">이러한 이식성 형식 등에 대해서는 [응용 프로그램 이식성 유형](../deploying/index.md) 문서에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-214">These portability types and more are discussed in the [application portability type](../deploying/index.md) document.</span></span> 

<span data-ttu-id="8e22e-215">원하는 이식성 형식을 호출하면 대상 프레임워크를 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-215">Once you make a call on what type of portability you want, you need to change your targeted framework(s).</span></span> <span data-ttu-id="8e22e-216">.NET Core용 응용 프로그램을 작성한 경우 대상 프레임워크로 `dnxcore50`을 사용할 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-216">If you were writing applications for .NET Core, you were most likely using `dnxcore50` as  your targeted framework.</span></span> <span data-ttu-id="8e22e-217">새로운 [.NET 표준](../../standard/net-standard.md)이 가져온 CLI 및 변경 사항과 함께 프레임워크는 다음 중 하나여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-217">With the CLI and the changes that the new [.NET Standard](../../standard/net-standard.md) brought, the framework needs to be one of the following:</span></span>

1. <span data-ttu-id="8e22e-218">`netcoreapp1.0`- .NET Core에서 응용 프로그램을 작성하는 경우(ASP.NET Core 응용 프로그램 포함)</span><span class="sxs-lookup"><span data-stu-id="8e22e-218">`netcoreapp1.0` - if you are writing applications on .NET Core (including ASP.NET Core applications)</span></span>
2. <span data-ttu-id="8e22e-219">`netstandard1.6`- .NET Core용 클래스 라이브러리를 작성하는 경우</span><span class="sxs-lookup"><span data-stu-id="8e22e-219">`netstandard1.6` - if you are writing class libraries for .NET Core</span></span>

<span data-ttu-id="8e22e-220">`dnx451` 같은 다른 `dnx` 대상을 사용 중인 경우에도 역시 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-220">If you are using other `dnx` targets, like `dnx451` you will need to change those as well.</span></span> <span data-ttu-id="8e22e-221">`dnx451`을`net451` 로 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-221">`dnx451` should be changed to `net451`.</span></span> <span data-ttu-id="8e22e-222">자세한 내용은 [.NET 표준](../../standard/net-standard.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8e22e-222">Please refer to the [.NET Standard](../../standard/net-standard.md) topic for more information.</span></span> 

<span data-ttu-id="8e22e-223">`project.json`이 거의 준비되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-223">Your `project.json` is now mostly ready.</span></span> <span data-ttu-id="8e22e-224">종속성 목록을 살펴보고, 특히 ASP.NET Core 종속성을 사용하는 경우 종속성을 새 버전으로 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-224">You need to go through your dependencies list and update the dependencies to their newer versions, especially if you are using ASP.NET Core dependencies.</span></span> <span data-ttu-id="8e22e-225">별도의 BCL API용 패키지를 사용한 경우 [응용 프로그램 이식성 유형](../deploying/index.md) 문서에 설명된 대로 런타임 패키지를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-225">If you were using separate packages for BCL APIs, you can use the runtime package as explained in the [application portability type](../deploying/index.md) document.</span></span> 

<span data-ttu-id="8e22e-226">준비가 되면 `dotnet restore`로 복원을 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-226">Once you are ready, you can try restoring with `dotnet restore`.</span></span> <span data-ttu-id="8e22e-227">종속성의 버전에 따라, NuGet이 위의 대상 프레임워크 중 하나에 대한 종속성을 확인할 수 없는 경우 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-227">Depending on the version of your dependencies, you may encounter errors if NuGet cannot resolve the dependencies for one of the targeted frameworks above.</span></span> <span data-ttu-id="8e22e-228">이는 "시점" 문제입니다. 시간이 지나면서 이러한 프레임워크를 지원하는 패키지가 점점 더 많아질 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-228">This is a "point-in-time" problem; as time progresses, more and more packages will include support for these frameworks.</span></span> <span data-ttu-id="8e22e-229">지금은 `framework` 노드 내에서 `imports` 문을 사용하여, 프레임워크를 대상으로 하는 패키지를 복원할 수 있는 NuGet을 "imports" 문 내에 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-229">For now, if you run into this, you can use the `imports` statement within the `framework` node to specify to NuGet that it can restore the packages targeting the framework within the "imports" statement.</span></span> <span data-ttu-id="8e22e-230">이 경우 표시되는 복원 오류는 어떤 프레임워크를 가져와야 하는지에 대한 충분한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-230">The restoring errors you get in this case should provide enough information to tell you which frameworks you need to import.</span></span> <span data-ttu-id="8e22e-231">잘 모르는 경우 일반적으로 `imports` 문에서 `dnxcore50` 및 `portable-net45+win8`을 지정하면 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-231">If you are slightly lost or new to this, in general, specifying `dnxcore50` and `portable-net45+win8` in the `imports` statement should do the trick.</span></span> <span data-ttu-id="8e22e-232">다음의 JSON 코드 조각은 이를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-232">The JSON snippet below shows how this looks like:</span></span>

```json
    "frameworks": {
        "netcoreapp1.0": { 
            "imports": ["dnxcore50", "portable-net45+win8"]
        }
    }
```

<span data-ttu-id="8e22e-233">`dotnet build`를 실행하면 너무 많지는 않더라도 궁극적인 빌드 오류가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-233">Running `dotnet build` will show any eventual build errors, though there shouldn't be too many of them.</span></span> <span data-ttu-id="8e22e-234">코드를 빌드하여 적절히 실행한 후에는 Runner로 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8e22e-234">After your code is building and running properly, you can test it out with the runner.</span></span> <span data-ttu-id="8e22e-235">`dotnet <path-to-your-assembly>`를 실행하고 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="8e22e-235">Execute `dotnet <path-to-your-assembly>` and see it run.</span></span>


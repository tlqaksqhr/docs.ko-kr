---
title: .NET Core로 이식 - 라이브러리
description: .NET Framework에서 .NET Core로 라이브러리 프로젝트를 이식하는 방법에 관해 알아봅니다.
author: cartermp
ms.author: mairaw
ms.date: 07/14/2017
ms.topic: conceptual
ms.prod: dotnet-core
ms.devlang: dotnet
ms.workload:
- dotnetcore
ms.openlocfilehash: ca71ed4b2423846db4b2c2fc0ba87c49330b7d14
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/28/2018
---
# <a name="porting-to-net-core---libraries"></a><span data-ttu-id="15874-103">.NET Core로 이식 - 라이브러리</span><span class="sxs-lookup"><span data-stu-id="15874-103">Porting to .NET Core - Libraries</span></span>

<span data-ttu-id="15874-104">이 문서에서는 플랫폼 간에 실행되도록 .NET Core에 라이브러리 코드를 이식하는 방법에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-104">This article discusses porting library code to .NET Core so that it runs cross-platform.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="15874-105">전제 조건</span><span class="sxs-lookup"><span data-stu-id="15874-105">Prerequisites</span></span>

<span data-ttu-id="15874-106">이 문서에서는 다음을 전제로 합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-106">This article assumes that you:</span></span>

- <span data-ttu-id="15874-107">사용자가 Visual Studio 2017 이상을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-107">Are using Visual Studio 2017 or later.</span></span>
  - <span data-ttu-id="15874-108">.NET Core는 이전 버전의 Visual Studio에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-108">.NET Core isn't supported on earlier versions of Visual Studio</span></span>
- <span data-ttu-id="15874-109">사용자가 [권장 이식 프로세스](index.md)를 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-109">Understand the [recommended porting process](index.md).</span></span>
- <span data-ttu-id="15874-110">사용자가 [타사 종속성](third-party-deps.md)과 관련된 문제를 모두 해결했습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-110">Have resolved any issues with [third-party dependencies](third-party-deps.md).</span></span>

<span data-ttu-id="15874-111">또한 다음 항목의 내용을 숙지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-111">You should also become familiar with the content of the following topics:</span></span>

<span data-ttu-id="15874-112">[.NET 표준](~/docs/standard/net-standard.md) </span><span class="sxs-lookup"><span data-stu-id="15874-112">[.NET Standard](~/docs/standard/net-standard.md) </span></span>  
<span data-ttu-id="15874-113">이 항목에서는 모든 .NET 구현에서 사용할 수 있는 .NET API의 공식 사양에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-113">This topic describes the formal specification of .NET APIs that are intended to be available on all .NET implementations.</span></span>

<span data-ttu-id="15874-114">[패키지, 메타패키지 및 프레임워크](~/docs/core/packages.md) </span><span class="sxs-lookup"><span data-stu-id="15874-114">[Packages, Metapackages and Frameworks](~/docs/core/packages.md) </span></span>  
<span data-ttu-id="15874-115">이 문서에서는 .NET Core가 패키지를 정의하고 사용하는 방법과 패키지가 여러 .NET 구현에서 실행되는 코드를 지원하는 방법에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-115">This article discusses how .NET Core defines and uses packages and how packages support code running on multiple .NET implementations.</span></span>

<span data-ttu-id="15874-116">[플랫폼 간 도구로 라이브러리 개발](~/docs/core/tutorials/libraries.md) </span><span class="sxs-lookup"><span data-stu-id="15874-116">[Developing Libraries with Cross Platform Tools](~/docs/core/tutorials/libraries.md) </span></span>  
<span data-ttu-id="15874-117">이 항목에서는 플랫폼 간 CLI 도구를 사용하여 .NET용 라이브러리를 작성하는 방법에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-117">This topic explains how to write libraries for .NET using cross-platform CLI tools.</span></span>

<span data-ttu-id="15874-118">[.NET Core용 *csproj* 형식에 대한 추가 사항](~/docs/core/tools/csproj.md) </span><span class="sxs-lookup"><span data-stu-id="15874-118">[Additions to the *csproj* format for .NET Core](~/docs/core/tools/csproj.md) </span></span>  
<span data-ttu-id="15874-119">이 문서에서는 *csproj* 및 MSBuild로 프로젝트 시스템을 전환함에 따라 프로젝트 파일에 추가된 변경 내용을 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-119">This article outlines the changes that were added to the project file as part of the move to *csproj* and MSBuild.</span></span>

<span data-ttu-id="15874-120">[.NET Core로 이식 - 타사 종속성 분석](~/docs/core/porting/third-party-deps.md) </span><span class="sxs-lookup"><span data-stu-id="15874-120">[Porting to .NET Core - Analyzing your Third-Party Party Dependencies](~/docs/core/porting/third-party-deps.md) </span></span>  
<span data-ttu-id="15874-121">이 항목에서는 타사 종속성의 이식성 및 .NET Core에서 NuGet 패키지 종속성이 실행되지 않는 경우 해야 할 작업에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-121">This topic discusses the portability of third-party dependencies and what to do when a NuGet package dependency doesn't run on .NET Core.</span></span>

## <a name="net-framework-technologies-unavailable-on-net-core"></a><span data-ttu-id="15874-122">.NET Core에서 사용할 수 없는 .NET Framework 기술</span><span class="sxs-lookup"><span data-stu-id="15874-122">.NET Framework technologies unavailable on .NET Core</span></span>

<span data-ttu-id="15874-123">.NET Framework 라이브러리에서 사용할 수 있는 AppDomain, 원격 통신, CAS(코드 액세스 보안), 보안 투명도와 같은 몇몇 기술은 .NET Core에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-123">Several technologies available to .NET Framework libraries aren't available for use with .NET Core, such as AppDomains, Remoting, Code Access Security (CAS), and Security Transparency.</span></span> <span data-ttu-id="15874-124">라이브러리가 이러한 기술 중 하나 이상에 의존하는 경우 아래에 설명된 대체 방법을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="15874-124">If your libraries rely on one or more of these technologies, consider the alternative approaches outlined below.</span></span> <span data-ttu-id="15874-125">API 호환성에 대한 자세한 정보를 위해 CoreFX 팀이 GitHub에서 [행동 변경/호환 중단 및 사용 중단/레거시 API 목록](https://github.com/dotnet/corefx/wiki/ApiCompat)을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-125">For more information on API compatibility, the CoreFX team maintains a [List of behavioral changes/compat breaks and deprecated/legacy APIs](https://github.com/dotnet/corefx/wiki/ApiCompat) at GitHub.</span></span>

<span data-ttu-id="15874-126">API 또는 기술이 현재 구현되지 않았기 때문에 이들을 고의로 지원하지 않는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="15874-126">Just because an API or technology isn't currently implemented doesn't imply it's intentionally unsupported.</span></span> <span data-ttu-id="15874-127">특정 API 및 기술을 요청하려면 GitHub의 [dotnet/corefx 리포지토리 문제](https://github.com/dotnet/corefx/issues)에서 문제를 제기하세요.</span><span class="sxs-lookup"><span data-stu-id="15874-127">File an issue in the [dotnet/corefx repository issues](https://github.com/dotnet/corefx/issues) at GitHub to ask for specific APIs and technologies.</span></span> <span data-ttu-id="15874-128">[문제의 이식 요청](https://github.com/dotnet/corefx/labels/port-to-core)은 `port-to-core` 레이블로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="15874-128">[Porting requests in the issues](https://github.com/dotnet/corefx/labels/port-to-core) are marked with the `port-to-core` label.</span></span>

### <a name="appdomains"></a><span data-ttu-id="15874-129">AppDomain</span><span class="sxs-lookup"><span data-stu-id="15874-129">AppDomains</span></span>

<span data-ttu-id="15874-130">AppDomain은 앱을 서로 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-130">AppDomains isolate apps from one another.</span></span> <span data-ttu-id="15874-131">AppDomain에는 런타임 지원이 필요하고, 일반적으로 상당히 비싸므로</span><span class="sxs-lookup"><span data-stu-id="15874-131">AppDomains require runtime support and are generally quite expensive.</span></span> <span data-ttu-id="15874-132">.NET Core에서 구현되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-132">They're not implemented in .NET Core.</span></span> <span data-ttu-id="15874-133">앞으로 이 기능을 추가할 계획이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-133">We don't plan on adding this capability in future.</span></span> <span data-ttu-id="15874-134">코드 격리의 경우 별도의 프로세스 또는 컨테이너를 대신 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-134">For code isolation, we recommend separate processes or using containers as an alternative.</span></span> <span data-ttu-id="15874-135">어셈블리를 동적으로 로드하기 위해 새 <xref:System.Runtime.Loader.AssemblyLoadContext> 클래스를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-135">For the dynamic loading of assemblies, we recommend the new <xref:System.Runtime.Loader.AssemblyLoadContext> class.</span></span>

<span data-ttu-id="15874-136">.NET Framework에서 코드를 쉽게 마이그레이션할 수 있도록 .NET Core에서 <xref:System.AppDomain> API 표면의 일부를 공개했습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-136">To make code migration from .NET Framework easier, we've exposed some of the <xref:System.AppDomain> API surface in .NET Core.</span></span> <span data-ttu-id="15874-137">API 중 일부는 정상적으로 작동하고(예: <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>), 일부 멤버는 아무것도 하지 않고(예: <xref:System.AppDomain.SetCachePath%2A>), 일부는 <xref:System.PlatformNotSupportedException>을 throw합니다(예: <xref:System.AppDomain.CreateDomain%2A>).</span><span class="sxs-lookup"><span data-stu-id="15874-137">Some of the API functions normally (for example, <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>), some members do nothing (for example, <xref:System.AppDomain.SetCachePath%2A>), and some of them throw <xref:System.PlatformNotSupportedException> (for example, <xref:System.AppDomain.CreateDomain%2A>).</span></span> <span data-ttu-id="15874-138">[dotnet/corefx GitHub 리포지토리](https://github.com/dotnet/corefx)의 [`System.AppDomain` 참조 소스](https://github.com/dotnet/corefx/blob/master/src/System.Runtime.Extensions/src/System/AppDomain.cs)에 대해 사용하는 형식을 확인하여 구현된 버전과 일치하는 분기를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-138">Check the types you use against the [`System.AppDomain` reference source](https://github.com/dotnet/corefx/blob/master/src/System.Runtime.Extensions/src/System/AppDomain.cs) in the [dotnet/corefx GitHub repository](https://github.com/dotnet/corefx) making sure to select the branch that matches your implemented version.</span></span>

### <a name="remoting"></a><span data-ttu-id="15874-139">원격 통신</span><span class="sxs-lookup"><span data-stu-id="15874-139">Remoting</span></span>

<span data-ttu-id="15874-140">.NET Remoting은 문제가 있는 아키텍처로 확인되었으며</span><span class="sxs-lookup"><span data-stu-id="15874-140">.NET Remoting was identified as a problematic architecture.</span></span> <span data-ttu-id="15874-141">더 이상 지원되지 않는 AppDomain 간 통신에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="15874-141">It's used for cross-AppDomain communication, which is no longer supported.</span></span> <span data-ttu-id="15874-142">또한 원격 통신에는 유지 관리 비용이 많이 드는 런타임 지원이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-142">Also, Remoting requires runtime support, which is expensive to maintain.</span></span> <span data-ttu-id="15874-143">이러한 이유로 .NET Remoting은 .NET Core에서 지원되지 않으며 향후 지원을 추가할 계획이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-143">For these reasons, .NET Remoting isn't supported on .NET Core, and we don't plan on adding support for it in the future.</span></span>

<span data-ttu-id="15874-144">프로세스 간 통신을 위해 <xref:System.IO.Pipes> 또는 <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> 클래스 같은 IPC(Inter-process communication) 메커니즘을 원격 통신 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-144">For communication across processes, consider inter-process communication (IPC) mechanisms as an alternative to Remoting, such as the <xref:System.IO.Pipes> or the <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> class.</span></span>

<span data-ttu-id="15874-145">여러 컴퓨터에서 네트워크 기반 솔루션을 대신 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="15874-145">Across machines, use a network-based solution as an alternative.</span></span> <span data-ttu-id="15874-146">HTTP와 같이 오버헤드가 낮은 일반 텍스트 프로토콜을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-146">Preferably, use a low-overhead plain text protocol, such as HTTP.</span></span> <span data-ttu-id="15874-147">ASP.NET Core에서 사용하는 웹 서버인 [Kestrel 웹 서버](https://docs.microsoft.com/aspnet/core/fundamentals/servers/kestrel)도 옵션이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-147">The [Kestrel web server](https://docs.microsoft.com/aspnet/core/fundamentals/servers/kestrel), the web server used by ASP.NET Core, is an option here.</span></span> <span data-ttu-id="15874-148">또한 네트워크 기반, 컴퓨터 간 시나리오에서 <xref:System.Net.Sockets>의 사용을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="15874-148">Also consider using <xref:System.Net.Sockets> for network-based, cross-machine scenarios.</span></span> <span data-ttu-id="15874-149">추가 옵션은 [.NET 오픈 소스 개발자 프로젝트: 메시징](https://github.com/Microsoft/dotnet/blob/master/dotnet-developer-projects.md#messaging)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="15874-149">For more options, see [.NET Open Source Developer Projects: Messaging](https://github.com/Microsoft/dotnet/blob/master/dotnet-developer-projects.md#messaging).</span></span>

### <a name="code-access-security-cas"></a><span data-ttu-id="15874-150">CAS(코드 액세스 보안)</span><span class="sxs-lookup"><span data-stu-id="15874-150">Code Access Security (CAS)</span></span>

<span data-ttu-id="15874-151">관리되는 응용 프로그램 또는 라이브러리에서 사용하거나 실행하는 리소스를 제한하기 위해 런타임 또는 프레임워크에 의존하는 샌드박싱은 [.NET Framework에서 지원되지 않으므로](~/docs/framework/misc/code-access-security.md) .NET Core에서도 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-151">Sandboxing, which is relying on the runtime or the framework to constrain which resources a managed application or library uses or runs, [isn't supported on .NET Framework](~/docs/framework/misc/code-access-security.md) and therefore is also not supported on .NET Core.</span></span> <span data-ttu-id="15874-152">CAS를 보안 경계로 계속 처리하기 위해 권한 상승이 발생하는 .NET Framework 및 런타임에는 사례가 너무 많이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-152">We believe that there are too many cases in the .NET Framework and runtime where an elevation of privileges occurs to continue treating CAS as a security boundary.</span></span> <span data-ttu-id="15874-153">또한 CAS는 구현을 더욱 복잡하게 만들고 이를 사용하지 않을 응용 프로그램의 정확성-성능에 종종 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="15874-153">In addition, CAS makes the implementation more complicated and often has correctness-performance implications for applications that don't intend to use it.</span></span>

<span data-ttu-id="15874-154">최소한의 권한으로 프로세스를 실행하려면 가상화, 컨테이너 또는 사용자 계정과 같은 운영 체제에서 제공하는 보안 경계를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-154">Use security boundaries provided by the operating system, such as virtualization, containers, or user accounts for running processes with the least set of privileges.</span></span>

### <a name="security-transparency"></a><span data-ttu-id="15874-155">보안 투명도</span><span class="sxs-lookup"><span data-stu-id="15874-155">Security Transparency</span></span>

<span data-ttu-id="15874-156">CAS와 마찬가지로 보안 투명도는 샌드박스 코드를 보안상 중요한 코드와 선언적인 방식으로 분리할 수 있지만 [더 이상 보안 경계로서 지원되지는 않습니다](~/docs/framework/misc/security-transparent-code.md).</span><span class="sxs-lookup"><span data-stu-id="15874-156">Similar to CAS, Security Transparency allows separating sandboxed code from security critical code in a declarative fashion but is [no longer supported as a security boundary](~/docs/framework/misc/security-transparent-code.md).</span></span> <span data-ttu-id="15874-157">이 기능은 Silverlight에서 많이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="15874-157">This feature is heavily used by Silverlight.</span></span> 

<span data-ttu-id="15874-158">최소한의 권한으로 프로세스를 실행하려면 가상화, 컨테이너 또는 사용자 계정과 같은 운영 체제에서 제공하는 보안 경계를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-158">Use security boundaries provided by the operating system, such as virtualization, containers, or user accounts for running processes with the least set of privileges.</span></span>

### <a name="globaljson"></a><span data-ttu-id="15874-159">global.json</span><span class="sxs-lookup"><span data-stu-id="15874-159">global.json</span></span>

<span data-ttu-id="15874-160">*global.json* 파일은 .NET Core 도구 버전의 프로젝트를 설정할 수 있는 선택적 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="15874-160">The *global.json* file is an optional file that allows you to set the .NET Core tools version of a project.</span></span> <span data-ttu-id="15874-161">.NET Core의 야간 빌드를 사용 중이고 특정 버전의 SDK를 지정하려면 *global.json* 파일로 버전을 지정하세요.</span><span class="sxs-lookup"><span data-stu-id="15874-161">If you're using nightly builds of .NET Core and wish to specify a specific version of the SDK, specify the version with a *global.json* file.</span></span> <span data-ttu-id="15874-162">이 파일은 일반적으로 현재 작업 디렉터리 또는 부모 디렉터리 중 하나에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-162">It typically resides in the current working directory or one of its parent directories.</span></span> 

```json
{
  "sdk": {
    "version": "2.1.0-preview1-006491"
  }
}
```

## <a name="converting-a-pcl-project"></a><span data-ttu-id="15874-163">PCL 프로젝트 변환</span><span class="sxs-lookup"><span data-stu-id="15874-163">Converting a PCL project</span></span>

<span data-ttu-id="15874-164">Visual Studio 2017에서 라이브러리를 로드하고 다음 단계를 수행하여 PCL 프로젝트의 대상을 .NET 표준으로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-164">You can convert the targets of a PCL project to .NET Standard by loading the library in Visual Studio 2017 and performing the following steps:</span></span>

1. <span data-ttu-id="15874-165">프로젝트 파일을 마우스 오른쪽 단추로 클릭하고 **속성**을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-165">Right-click on the project file and select **Properties**.</span></span>
1. <span data-ttu-id="15874-166">**라이브러리** 아래에서 **.NET 플랫폼 표준을 대상으로 지정**을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-166">Under **Library**, select **Target .NET Platform Standard**.</span></span>

<span data-ttu-id="15874-167">패키지가 NuGet 3.0을 지원하면 프로젝트의 대상이 .NET 표준으로 다시 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="15874-167">If your packages support NuGet 3.0, the project retargets to .NET Standard.</span></span>

<span data-ttu-id="15874-168">패키지가 NuGet 3.0을 지원하지 않으면 Visual Studio에서 현재 패키지를 제거하라는 대화 상자가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="15874-168">If your packages don't support NuGet 3.0, you receive a dialog from Visual Studio telling you to uninstall your current packages.</span></span> <span data-ttu-id="15874-169">이 알림을 받으면 다음 단계를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-169">If you receive this notice, perform the following steps:</span></span>

1. <span data-ttu-id="15874-170">프로젝트를 마우스 오른쪽 단추로 클릭하고 **NuGet 패키지 관리**를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-170">Right-click the project, select **Manage NuGet Packages**.</span></span>
1. <span data-ttu-id="15874-171">프로젝트의 패키지를 기록해 둡니다.</span><span class="sxs-lookup"><span data-stu-id="15874-171">Make a note of the project's packages.</span></span>
1. <span data-ttu-id="15874-172">하나씩 패키지를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-172">Uninstall the packages one-by-one.</span></span>
1. <span data-ttu-id="15874-173">제거 프로세스를 완료하려면 Visual Studio를 다시 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-173">You might need to restart Visual Studio to complete the uninstall process.</span></span> <span data-ttu-id="15874-174">이 경우 **NuGet 패키지 관리자** 창에 **다시 시작** 단추가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="15874-174">If so, a **Restart** button is presented to you in the **NuGet Package Manager** window.</span></span>
1. <span data-ttu-id="15874-175">프로젝트를 다시 로드하면 .NET 표준이 대상이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="15874-175">When the project reloads, it targets .NET Standard.</span></span> <span data-ttu-id="15874-176">제거해야 하는 패키지를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-176">Add the packages you were required to uninstall.</span></span>

## <a name="retargeting-your-net-framework-code-to-net-framework-462"></a><span data-ttu-id="15874-177">.NET Framework 4.6.2로 .NET Framework 코드 대상 다시 지정</span><span class="sxs-lookup"><span data-stu-id="15874-177">Retargeting your .NET Framework code to .NET Framework 4.6.2</span></span>

<span data-ttu-id="15874-178">코드가 .NET Framework 4.6.2를 대상으로 하지 않는 경우 .NET Framework 4.6.2로 대상을 다시 지정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-178">If your code isn't targeting .NET Framework 4.6.2, we recommended that you retarget to .NET Framework 4.6.2.</span></span> <span data-ttu-id="15874-179">그러면 .NET 표준에서 기존 API를 지원할 수 없는 경우 최신 API를 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-179">This ensures the availability of the latest API alternatives for cases where the .NET Standard doesn't support existing APIs.</span></span>

<span data-ttu-id="15874-180">Visual Studio에서 이식하려는 각 프로젝트에 대해 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-180">For each of your projects in Visual Studio you wish to port, do the following:</span></span>

1. <span data-ttu-id="15874-181">프로젝트를 마우스 오른쪽 단추로 클릭하고 속성을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-181">Right-click on the project and select Properties.</span></span>
1. <span data-ttu-id="15874-182">**대상 프레임워크** 드롭다운에서 **.NET Framework 4.6.2**를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-182">In the **Target Framework** dropdown, select **.NET Framework 4.6.2**.</span></span>
1. <span data-ttu-id="15874-183">프로젝트를 다시 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-183">Recompile your projects.</span></span>

<span data-ttu-id="15874-184">프로젝트가 .NET Framework 4.6.2를 대상으로 하기 때문에 해당 버전의 .NET Framework를 코드 이식의 기반으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-184">Because your projects now target .NET Framework 4.6.2, use that version of the .NET Framework as your base for porting code.</span></span>

## <a name="determining-the-portability-of-your-code"></a><span data-ttu-id="15874-185">코드의 이식성 확인</span><span class="sxs-lookup"><span data-stu-id="15874-185">Determining the portability of your code</span></span>

<span data-ttu-id="15874-186">다음 단계에서는 API Portability Analyzer(ApiPort)를 실행하여 분석을 위한 이식성 보고서를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-186">The next step is to run the API Portability Analyzer (ApiPort) to generate a portability report for analysis.</span></span>

<span data-ttu-id="15874-187">[API 이식성 도구(ApiPort)](../../standard/analyzers/portability-analyzer.md)를 이해하고 .NET Core를 대상으로 하는 이식성 보고서를 생성할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-187">Make sure you understand the [API Portability Analyzer (ApiPort)](../../standard/analyzers/portability-analyzer.md) and how to generate portability reports for targeting .NET Core.</span></span> <span data-ttu-id="15874-188">이 작업을 수행하는 방법은 요구 사항 및 개인적 취향에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-188">How you do this likely varies based on your needs and personal tastes.</span></span> <span data-ttu-id="15874-189">다음은 몇 가지 서로 다른 접근 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="15874-189">What follows are a few different approaches.</span></span> <span data-ttu-id="15874-190">코드가 어떻게 구성되어 있는가에 따라 이러한 접근 방식의 단계를 혼합하여 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-190">You may find yourself mixing steps of these approaches depending on how your code is structured.</span></span>

### <a name="dealing-primarily-with-the-compiler"></a><span data-ttu-id="15874-191">주로 컴파일러 처리</span><span class="sxs-lookup"><span data-stu-id="15874-191">Dealing primarily with the compiler</span></span>

<span data-ttu-id="15874-192">이 접근 방식은 작은 프로젝트 또는 많은 .NET Framework API를 사용하지 않는 프로젝트에 가장 적합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-192">This approach may be the best for small projects or projects which don't use many .NET Framework APIs.</span></span> <span data-ttu-id="15874-193">접근 방식은 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-193">The approach is simple:</span></span>

1. <span data-ttu-id="15874-194">필요에 따라 프로젝트에서 ApiPort를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-194">Optionally, run ApiPort on your project.</span></span> <span data-ttu-id="15874-195">ApiPort를 실행하는 경우 해결해야 할 문제에 대한 보고서에서 정보를 가져오세요.</span><span class="sxs-lookup"><span data-stu-id="15874-195">If you run ApiPort, gain knowledge from the report on issues you'll need to address.</span></span>
1. <span data-ttu-id="15874-196">모든 코드를 새 .NET Core 프로젝트에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-196">Copy all of your code over into a new .NET Core project.</span></span>
1. <span data-ttu-id="15874-197">이식성 보고서(생성된 경우)를 참조하면서 프로젝트가 완전히 컴파일될 때까지 컴파일러 오류를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-197">While referring to the portability report (if generated), solve compiler errors until the project fully compiles.</span></span>

<span data-ttu-id="15874-198">이 접근 방식은 구조적이지는 않지만 코드 중심 접근 방식을 사용하면 종종 문제를 신속하게 해결할 수 있으므로 더 작은 프로젝트나 라이브러리에 가장 적합한 방법이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-198">Although this approach is unstructured, the code-focused approach often leads to resolving issues quickly and might be the best approach for smaller projects or libraries.</span></span> <span data-ttu-id="15874-199">데이터 모델만 포함하는 프로젝트가 이 접근 방식에 적합한 후보가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-199">A project that contains only data models might be an ideal candidate for this approach.</span></span>

### <a name="staying-on-the-net-framework-until-portability-issues-are-resolved"></a><span data-ttu-id="15874-200">이식성 문제가 해결될 때까지 .NET Framework 유지</span><span class="sxs-lookup"><span data-stu-id="15874-200">Staying on the .NET Framework until portability issues are resolved</span></span>

<span data-ttu-id="15874-201">이 접근 방식은 전체 프로세스 중에 컴파일되는 코드를 선호하는 경우 적합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-201">This approach might be the best if you prefer to have code that compiles during the entire process.</span></span> <span data-ttu-id="15874-202">이 접근 방식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-202">The approach is as follows:</span></span>

1. <span data-ttu-id="15874-203">프로젝트에서 ApiPort를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-203">Run ApiPort on a project.</span></span>
1. <span data-ttu-id="15874-204">이식 가능한 다른 API를 사용하여 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-204">Address issues by using different APIs that are portable.</span></span>
1. <span data-ttu-id="15874-205">직접적인 대안을 사용할 수 없는 영역을 기록해 둡니다.</span><span class="sxs-lookup"><span data-stu-id="15874-205">Take note of any areas where you're prevented from using a direct alternative.</span></span>
1. <span data-ttu-id="15874-206">각 프로젝트를 새 .NET Core 프로젝트에 복사할 준비가 되었다고 확신할 때까지 이식하려는 모든 프로젝트에 대해 이전 단계를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-206">Repeat the prior steps for all projects you're porting until you're confident each is ready to be copied over into a new .NET Core project.</span></span>
1. <span data-ttu-id="15874-207">새 .NET Core 프로젝트에 코드를 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-207">Copy the code into a new .NET Core project.</span></span>
1. <span data-ttu-id="15874-208">직접적인 대안이 없는 것으로 기록해 둔 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-208">Work out any issues where you noted that a direct alternative doesn't exist.</span></span>

<span data-ttu-id="15874-209">이 신중한 접근 방식은 단순히 컴파일러 오류를 해결하는 것보다는 구조적이지만 비교적 코드 중심적이며 컴파일되는 코드가 항상 있다는 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-209">This careful approach is more structured than simply working out compiler errors, but it's still relatively code-focused and has the benefit of always having code that compiles.</span></span> <span data-ttu-id="15874-210">다른 API를 사용하여 해결할 수 없는 특정 문제를 해결하는 방법은 현저하게 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="15874-210">The way you resolve certain issues that couldn't be addressed by just using another API varies greatly.</span></span> <span data-ttu-id="15874-211">특정 프로젝트에 대해 보다 포괄적인 계획을 개발해야 할 수 있으며, 이는 다음 접근 방식에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-211">You may find that you need to develop a more comprehensive plan for certain projects, which is covered as the next approach.</span></span>

### <a name="developing-a-comprehensive-plan-of-attack"></a><span data-ttu-id="15874-212">포괄적인 공격 계획 개발</span><span class="sxs-lookup"><span data-stu-id="15874-212">Developing a comprehensive plan of attack</span></span>

<span data-ttu-id="15874-213">이 접근 방식은 .NET Core를 지원하기 위해 코드를 재구성하거나 코드의 특정 영역을 완전히 다시 작성해야 할 수 있는 더 크고 더 복잡한 프로젝트에 가장 적합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-213">This approach might be best for larger and more complex projects, where restructuring code or completely rewriting certain areas of code might be necessary to support .NET Core.</span></span> <span data-ttu-id="15874-214">이 접근 방식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-214">The approach is as follows:</span></span>

1. <span data-ttu-id="15874-215">프로젝트에서 ApiPort를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-215">Run ApiPort on a project.</span></span>
1. <span data-ttu-id="15874-216">이식 불가능한 각 형식이 사용되고 있는 위치 및 해당 형식이 전체 이식성에 어떻게 영향을 주는지를 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-216">Understand where each non-portable type is used and how that affects overall portability.</span></span>
   - <span data-ttu-id="15874-217">해당 형식의 특성을 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-217">Understand the nature of those types.</span></span> <span data-ttu-id="15874-218">수는 적은데 자주 사용되나요?</span><span class="sxs-lookup"><span data-stu-id="15874-218">Are they small in number but used frequently?</span></span> <span data-ttu-id="15874-219">아니면 수는 많지만 자주 사용되지 않나요?</span><span class="sxs-lookup"><span data-stu-id="15874-219">Are they large in number but used infrequently?</span></span> <span data-ttu-id="15874-220">집중적으로 사용되나요? 아니면 코드 전체에 분산되어 있나요?</span><span class="sxs-lookup"><span data-stu-id="15874-220">Is their use concentrated, or is it spread throughout your code?</span></span>
   - <span data-ttu-id="15874-221">이식할 수 없는 코드는 격리가 쉬우므로 더 효과적으로 처리할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="15874-221">Is it easy to isolate code that isn't portable so that you can deal with it more effectively?</span></span>
   - <span data-ttu-id="15874-222">코드를 리팩터링해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="15874-222">Do you need to refactor your code?</span></span>
   - <span data-ttu-id="15874-223">이식할 수 없는 해당 형식에 대해 동일한 작업을 수행하는 다른 API가 있나요?</span><span class="sxs-lookup"><span data-stu-id="15874-223">For those types which aren't portable, are there alternative APIs that accomplish the same task?</span></span> <span data-ttu-id="15874-224">예를 들어 <xref:System.Net.WebClient> 클래스를 사용하고 있는 경우 <xref:System.Net.Http.HttpClient> 클래스를 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-224">For example if you're using the <xref:System.Net.WebClient> class, you might be able to use the <xref:System.Net.Http.HttpClient> class instead.</span></span>
   - <span data-ttu-id="15874-225">드롭인 대체가 아닌 경우에도 작업을 수행하는 데 사용할 수 있는 이식 가능한 다른 API가 있나요?</span><span class="sxs-lookup"><span data-stu-id="15874-225">Are there different portable APIs available to accomplish a task, even if it's not a drop-in replacement?</span></span> <span data-ttu-id="15874-226">예를 들어 <xref:System.Xml.Schema.XmlSchema>를 사용하여 XML을 구문 분석하지만 XML 스키마 검색이 필요하지 않은 경우, API를 사용하는 대신 <xref:System.Xml.Linq> API를 사용하고 직접 구문 분석을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-226">For example if you're using <xref:System.Xml.Schema.XmlSchema> to parse XML but don't require XML schema discovery, you could use <xref:System.Xml.Linq> APIs and implement parsing yourself as opposed to relying on an API.</span></span>
1. <span data-ttu-id="15874-227">이식하기 어려운 어셈블리가 있는 경우 지금은 .NET Framework에 유지하는 것이 나을까요?</span><span class="sxs-lookup"><span data-stu-id="15874-227">If you have assemblies that are difficult to port, is it worth leaving them on .NET Framework for now?</span></span> <span data-ttu-id="15874-228">다음과 같은 몇 가지 사항을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-228">Here are some things to consider:</span></span>
   - <span data-ttu-id="15874-229">.NET Framework 또는 Windows 관련 기능을 너무 많이 사용하기 때문에 .NET Core와 호환되지 않는 일부 기능이 라이브러리에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-229">You may have some functionality in your library that's incompatible with .NET Core because it relies too heavily on .NET Framework or Windows-specific functionality.</span></span> <span data-ttu-id="15874-230">기능 이식을 위해 리소스를 사용할 수 있을 때까지 임시로 해당 기능을 유지하고 당분간은 기능이 더 적은 라이브러리의 .NET Core 버전을 릴리스하는 것이 더 나을까요?</span><span class="sxs-lookup"><span data-stu-id="15874-230">Is it worth leaving that functionality behind for now and releasing a .NET Core version of your library with less features on a temporary basis until resources are available to port the features?</span></span>
   - <span data-ttu-id="15874-231">리팩터링이 도움이 될까요?</span><span class="sxs-lookup"><span data-stu-id="15874-231">Would a refactor help?</span></span>
1. <span data-ttu-id="15874-232">사용할 수 없는 .NET Framework API의 고유한 구현을 작성하는 것이 합리적일까요?</span><span class="sxs-lookup"><span data-stu-id="15874-232">Is it reasonable to write your own implementation of an unavailable .NET Framework API?</span></span>
   <span data-ttu-id="15874-233">[.NET Framework 참조 소스](https://github.com/Microsoft/referencesource)에서 코드를 복사, 수정 및 사용하는 것이 좋을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-233">You could consider copying, modifying, and using code from the [.NET Framework Reference Source](https://github.com/Microsoft/referencesource).</span></span> <span data-ttu-id="15874-234">참조 소스 코드는 [MIT 라이선스](https://github.com/Microsoft/referencesource/blob/master/LICENSE.txt)에 따라 라이선스가 부여되므로, 소스를 자신의 코드에 대한 기초로 매우 자유롭게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-234">The reference source code is licensed under the [MIT License](https://github.com/Microsoft/referencesource/blob/master/LICENSE.txt), so you have significant freedom to use the source as a basis for your own code.</span></span> <span data-ttu-id="15874-235">코드에서 Microsoft 특성을 제대로 지정하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="15874-235">Just be sure to properly attribute Microsoft in your code.</span></span>
1. <span data-ttu-id="15874-236">필요에 따라 다른 프로젝트에 대해 이 프로세스를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-236">Repeat this process as needed for different projects.</span></span>
 
<span data-ttu-id="15874-237">분석 단계는 코드베이스의 크기에 따라 다소 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-237">The analysis phase could take some time depending on the size of your codebase.</span></span> <span data-ttu-id="15874-238">이 단계에서 시간을 할애하여 필요한 변경의 범위를 철저하게 이해하고 계획을 개발하면 장기 실행, 특히 복잡한 코드베이스가 있는 경우 일반적으로 시간이 절약됩니다.</span><span class="sxs-lookup"><span data-stu-id="15874-238">Spending time in this phase to thoroughly understand the scope of changes needed and to develop a plan usually saves you time in the long run, particularly if you have a complex codebase.</span></span>

<span data-ttu-id="15874-239">계획에 코드베이스의 중요한 변경 작업을 포함하는 동시에 .NET Framework 4.6.2를 계속 대상으로 지정할 수 있으므로 이전 접근 방식보다 더 구조화된 버전으로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-239">Your plan could involve making significant changes to your codebase while still targeting .NET Framework 4.6.2, making this a more structured version of the previous approach.</span></span> <span data-ttu-id="15874-240">계획 실행을 시작하는 방법은 코드베이스에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="15874-240">How you go about executing your plan is dependent on your codebase.</span></span>

### <a name="mixing-approaches"></a><span data-ttu-id="15874-241">접근 방식 혼합</span><span class="sxs-lookup"><span data-stu-id="15874-241">Mixing approaches</span></span>

<span data-ttu-id="15874-242">위의 접근 방식을 프로젝트 단위로 혼합하여 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-242">It's likely that you'll mix the above approaches on a per-project basis.</span></span> <span data-ttu-id="15874-243">사용자 및 코드베이스에 가장 적합한 방법을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-243">You should do what makes the most sense to you and for your codebase.</span></span>

## <a name="porting-your-tests"></a><span data-ttu-id="15874-244">테스트 이식</span><span class="sxs-lookup"><span data-stu-id="15874-244">Porting your tests</span></span>

<span data-ttu-id="15874-245">코드를 이식한 경우 모든 항목이 제대로 작동하는지 확인하는 가장 좋은 방법은 .NET Core에 이식할 때 코드를 테스트하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="15874-245">The best way to make sure everything works when you've ported your code is to test your code as you port it to .NET Core.</span></span> <span data-ttu-id="15874-246">이렇게 하려면 .NET Core에 대한 테스트를 빌드하고 실행하는 테스트 프레임워크를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-246">To do this, you'll need to use a testing framework that builds and runs tests for .NET Core.</span></span> <span data-ttu-id="15874-247">현재는 다음과 같은 세 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-247">Currently, you have three options:</span></span>

- [<span data-ttu-id="15874-248">xUnit</span><span class="sxs-lookup"><span data-stu-id="15874-248">xUnit</span></span>](https://xunit.github.io/)
  * [<span data-ttu-id="15874-249">시작</span><span class="sxs-lookup"><span data-stu-id="15874-249">Getting Started</span></span>](http://xunit.github.io/docs/getting-started-dotnet-core.html)
  * [<span data-ttu-id="15874-250">MSTest 프로젝트를 xUnit으로 변환하는 도구</span><span class="sxs-lookup"><span data-stu-id="15874-250">Tool to convert an MSTest project to xUnit</span></span>](https://github.com/dotnet/codeformatter/tree/master/src/XUnitConverter)
- [<span data-ttu-id="15874-251">NUnit</span><span class="sxs-lookup"><span data-stu-id="15874-251">NUnit</span></span>](http://www.nunit.org/)
  * [<span data-ttu-id="15874-252">시작</span><span class="sxs-lookup"><span data-stu-id="15874-252">Getting Started</span></span>](https://github.com/nunit/docs/wiki/Installation)
  * [<span data-ttu-id="15874-253">MSTest에서 NUnit으로 마이그레이션에 대한 블로그 게시물</span><span class="sxs-lookup"><span data-stu-id="15874-253">Blog post about migrating from MSTest to NUnit</span></span>](http://www.florian-rappl.de/News/Page/275/convert-mstest-to-nunit)
- [<span data-ttu-id="15874-254">MSTest</span><span class="sxs-lookup"><span data-stu-id="15874-254">MSTest</span></span>](https://docs.microsoft.com/visualstudio/test/unit-test-basics)

## <a name="recommended-approach-to-porting"></a><span data-ttu-id="15874-255">이식에 권장되는 접근 방식</span><span class="sxs-lookup"><span data-stu-id="15874-255">Recommended approach to porting</span></span>

<span data-ttu-id="15874-256">궁극적으로 이식 작업은 .NET Framework 코드가 구성된 방법에 따라 크게 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="15874-256">Ultimately, the porting effort depends heavily on how your .NET Framework code is structured.</span></span> <span data-ttu-id="15874-257">코드를 이식하는 좋은 방법은 코드의 기본 구성 요소인 라이브러리의 *기본*으로 시작하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="15874-257">A good way to port your code is to begin with the *base* of your library, which are the foundational components of your code.</span></span> <span data-ttu-id="15874-258">이는 다른 모든 항목에서 직접적으로나 간접적으로 사용하는 데이터 모델이나 일부 다른 기본 클래스 및 메서드가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-258">This might be data models or some other foundational classes and methods that everything else uses directly or indirectly.</span></span>

1. <span data-ttu-id="15874-259">현재 이식하고 있는 라이브러리의 계층을 테스트하는 테스트 프로젝트를 이식합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-259">Port the test project that tests the layer of your library that you're currently porting.</span></span>
1. <span data-ttu-id="15874-260">라이브러리의 기본을 새 .NET Core 프로젝트에 복사하고 지원하려는 .NET 표준의 버전을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-260">Copy over the base of your library into a new .NET Core project and select the version of the .NET Standard you wish to support.</span></span>
1. <span data-ttu-id="15874-261">코드를 컴파일하는 데 필요한 대로 내용을 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-261">Make any changes needed to get the code to compile.</span></span> <span data-ttu-id="15874-262">이 작업의 많은 부분에서 NuGet 패키지 종속성을 *csproj* 파일에 추가해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15874-262">Much of this may require adding NuGet package dependencies to your *csproj* file.</span></span>
1. <span data-ttu-id="15874-263">테스트를 실행하고 필요에 따라 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-263">Run the tests and make any needed adjustments.</span></span>
1. <span data-ttu-id="15874-264">이식할 다음 코드 계층을 선택하고 이전 단계를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="15874-264">Pick the next layer of code to port over and repeat the prior steps.</span></span>

<span data-ttu-id="15874-265">라이브러리의 기본으로 시작하고 기본에서 바깥쪽으로 이동하면서 필요에 따라 각 계층을 테스트하면, 이식은 한 번에 하나의 코드 계층으로 문제가 격리되는 체계적인 프로세스가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="15874-265">If you start with the base of your library and move outward from the base and test each layer as needed, porting is a systematic process where problems are isolated to one layer of code at a time.</span></span>

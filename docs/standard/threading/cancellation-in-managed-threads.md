---
title: 관리되는 스레드의 취소
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- cancellation in .NET, overview
ms.assetid: eea11fe5-d8b0-4314-bb5d-8a58166fb1c3
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: a764912e46707b6f10e720f95a7d971ec4fc8e15
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33592173"
---
# <a name="cancellation-in-managed-threads"></a><span data-ttu-id="84606-102">관리되는 스레드의 취소</span><span class="sxs-lookup"><span data-stu-id="84606-102">Cancellation in Managed Threads</span></span>
<span data-ttu-id="84606-103">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]부터 .NET Framework에서는 비동기 또는 장기 실행 비동기 작업의 협조적 취소를 위한 통합 모델을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-103">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], the .NET Framework uses a unified model for cooperative cancellation of asynchronous or long-running synchronous operations.</span></span> <span data-ttu-id="84606-104">이 모델은 취소 토큰이라는 경량 개체에 기반을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="84606-104">This model is based on a lightweight object called a cancellation token.</span></span> <span data-ttu-id="84606-105">취소할 수 있는 작업 하나 이상을 호출하는 개체가 새 스레드나 작업 등을 만드는 방식으로 토큰을 각 작업에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-105">The object that invokes one or more cancelable operations, for example by creating new threads or tasks, passes the token to each operation.</span></span> <span data-ttu-id="84606-106">개별 작업이 토큰 복사본을 다시 다른 작업에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-106">Individual operations can in turn pass copies of the token to other operations.</span></span> <span data-ttu-id="84606-107">나중에 토큰을 만든 개체가 해당 토큰을 사용하여 관련 작업이 수행 중인 작업을 중지하도록 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-107">At some later time, the object that created the token can use it to request that the operations stop what they are doing.</span></span> <span data-ttu-id="84606-108">요청 개체만 취소 요청을 실행할 수 있고 각 수신기는 적절한 시간에 적절한 방식으로 요청을 알리고 요청에 응답해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-108">Only the requesting object can issue the cancellation request, and each listener is responsible for noticing the request and responding to it in an appropriate and timely manner.</span></span>  
  
 <span data-ttu-id="84606-109">협조적 취소 모델을 구현하는 일반적인 패턴은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-109">The general pattern for implementing the cooperative cancellation model is:</span></span>  
  
-   <span data-ttu-id="84606-110">개별 취소 토큰을 관리하고 토큰에 취소 알림을 보내는 <xref:System.Threading.CancellationTokenSource> 개체를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-110">Instantiate a <xref:System.Threading.CancellationTokenSource> object, which manages and sends cancellation notification to the individual cancellation tokens.</span></span>  
  
-   <span data-ttu-id="84606-111"><xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> 속성에서 반환된 토큰을 취소를 수신 대기하는 각 작업이나 스레드에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-111">Pass the token returned by the <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> property to each task or thread that listens for cancellation.</span></span>  
  
-   <span data-ttu-id="84606-112">각 작업이나 스레드가 취소에 응답하는 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-112">Provide a mechanism for each task or thread to respond to cancellation.</span></span>  
  
-   <span data-ttu-id="84606-113"><xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 메서드를 호출하여 취소 알림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-113">Call the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to provide notification of cancellation.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="84606-114"><xref:System.Threading.CancellationTokenSource> 클래스는 <xref:System.IDisposable> 인터페이스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-114">The <xref:System.Threading.CancellationTokenSource> class implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="84606-115">취소 토큰 소스 사용을 마치면 <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType> 메서드를 호출하여 토큰에 포함된 관리되지 않는 리소스를 해제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-115">You should be sure to call the <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType> method when you have finished using the cancellation token source to free any unmanaged resources it holds.</span></span>  
  
 <span data-ttu-id="84606-116">다음 그림에서는 토큰 소스와 모든 토큰 복사본의 관계를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="84606-116">The following illustration shows the relationship between a token source and all the copies of its token.</span></span>  
  
 <span data-ttu-id="84606-117">![CancellationTokenSource 및 취소 토큰](../../../docs/standard/threading/media/vs-cancellationtoken.png "VS_CancellationToken")</span><span class="sxs-lookup"><span data-stu-id="84606-117">![CancellationTokenSource and cancellation tokens](../../../docs/standard/threading/media/vs-cancellationtoken.png "VS_CancellationToken")</span></span>  
  
 <span data-ttu-id="84606-118">새 취소 모델을 통해 취소 인식 응용 프로그램 및 라이브러리를 더 쉽게 만들 수 있고 이 모델은 다음 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-118">The new cancellation model makes it easier to create cancellation-aware applications and libraries, and it supports the following features:</span></span>  
  
-   <span data-ttu-id="84606-119">취소는 협조적이고 수신기에 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-119">Cancellation is cooperative and is not forced on the listener.</span></span> <span data-ttu-id="84606-120">수신기는 취소 요청에 대한 응답으로 정상적으로 종료하는 방법을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-120">The listener determines how to gracefully terminate in response to a cancellation request.</span></span>  
  
-   <span data-ttu-id="84606-121">요청은 수신 대기와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="84606-121">Requesting is distinct from listening.</span></span> <span data-ttu-id="84606-122">취소할 수 있는 작업을 호출하는 개체는 취소가 있더라도 취소가 요청되는 시점을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-122">An object that invokes a cancelable operation can control when (if ever) cancellation is requested.</span></span>  
  
-   <span data-ttu-id="84606-123">요청 개체는 단 하나의 메서드 호출을 통해 모든 토큰 복사본에 대해 취소 요청을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-123">The requesting object issues the cancellation request to all copies of the token by using just one method call.</span></span>  
  
-   <span data-ttu-id="84606-124">수신기는 여러 토큰을 하나의 *연결된 토큰*으로 결합하여 동시에 수신 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-124">A listener can listen to multiple tokens simultaneously by joining them into one *linked token*.</span></span>  
  
-   <span data-ttu-id="84606-125">사용자 코드는 라이브러리 코드에서 취소 요청을 인식하고 이 요청에 응답할 수 있고, 라이브러리 코드는 사용자 코드에서 취소 요청을 인식하고 이 요청에 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-125">User code can notice and respond to cancellation requests from library code, and library code can notice and respond to cancellation requests from user code.</span></span>  
  
-   <span data-ttu-id="84606-126">수신기는 대기 핸들에 대한 폴링, 콜백 등록 또는 대기를 통해 취소 요청에 대한 알림을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-126">Listeners can be notified of cancellation requests by polling, callback registration, or waiting on wait handles.</span></span>  
  
## <a name="cancellation-types"></a><span data-ttu-id="84606-127">취소 형식</span><span class="sxs-lookup"><span data-stu-id="84606-127">Cancellation Types</span></span>  
 <span data-ttu-id="84606-128">취소 프레임워크는 다음 표에 나열된 관련 형식 집합으로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="84606-128">The cancellation framework is implemented as a set of related types, which are listed in the following table.</span></span>  
  
|<span data-ttu-id="84606-129">형식 이름</span><span class="sxs-lookup"><span data-stu-id="84606-129">Type name</span></span>|<span data-ttu-id="84606-130">설명</span><span class="sxs-lookup"><span data-stu-id="84606-130">Description</span></span>|  
|---------------|-----------------|  
|<xref:System.Threading.CancellationTokenSource>|<span data-ttu-id="84606-131">취소 토큰을 만들고 해당 토큰의 모든 복사본에 대한 취소 요청을 실행하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84606-131">Object that creates a cancellation token, and also issues the cancellation request for all copies of that token.</span></span>|  
|<xref:System.Threading.CancellationToken>|<span data-ttu-id="84606-132">일반적으로 메서드 매개 변수로 수신기 하나 이상에 전달되는 경량 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="84606-132">Lightweight value type passed to one or more listeners, typically as a method parameter.</span></span> <span data-ttu-id="84606-133">수신기는 핸들을 폴링, 콜백 또는 대기하여 토큰의 `IsCancellationRequested` 속성 값을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-133">Listeners monitor the value of the `IsCancellationRequested` property of the token by polling, callback, or wait handle.</span></span>|  
|<xref:System.OperationCanceledException>|<span data-ttu-id="84606-134">이 예외 생성자의 오버로드는 <xref:System.Threading.CancellationToken>을 매개 변수로 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-134">Overloads of this exception's constructor accept a <xref:System.Threading.CancellationToken> as a parameter.</span></span> <span data-ttu-id="84606-135">수신기는 선택적으로 이 예외를 throw하여 취소의 출처를 확인하고 취소 요청에 응답했다는 것을 다른 수신기에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="84606-135">Listeners can optionally throw this exception to verify the source of the cancellation and notify others that it has responded to a cancellation request.</span></span>|  
  
 <span data-ttu-id="84606-136">새 취소 모델은 여러 가지 형식으로 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]에 통합되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-136">The new cancellation model is integrated into the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] in several types.</span></span> <span data-ttu-id="84606-137">가장 중요한 형식은 <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 및 <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="84606-137">The most important ones are <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>.</span></span> <span data-ttu-id="84606-138">모든 새 라이브러리 및 응용 프로그램 코드에 대해 이 새 취소 모델을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-138">We recommend that you use this new cancellation model for all new library and application code.</span></span>  
  
## <a name="code-example"></a><span data-ttu-id="84606-139">코드 예제</span><span class="sxs-lookup"><span data-stu-id="84606-139">Code Example</span></span>  
 <span data-ttu-id="84606-140">다음 예제에서는 요청 개체가 <xref:System.Threading.CancellationTokenSource> 개체를 만들고 <xref:System.Threading.CancellationTokenSource.Token%2A> 속성을 취소 가능한 작업에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-140">In the following example, the requesting object creates a <xref:System.Threading.CancellationTokenSource> object, and then passes its <xref:System.Threading.CancellationTokenSource.Token%2A> property to the cancelable operation.</span></span> <span data-ttu-id="84606-141">요청을 수신하는 작업에서는 폴링을 통해 토큰의 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 속성 값을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-141">The operation that receives the request monitors the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token by polling.</span></span> <span data-ttu-id="84606-142">값이 `true`가 되면 수신기가 적절한 방식이더라도 종료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-142">When the value becomes `true`, the listener can terminate in whatever manner is appropriate.</span></span> <span data-ttu-id="84606-143">이 예제에서는 대부분 경우에 모두 필요한 메서드가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="84606-143">In this example, the method just exits, which is all that is required in many cases.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84606-144">예제에서는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 메서드를 사용하여 새 취소 프레임워크가 기존 API와 호환된다는 것을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="84606-144">The example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to demonstrate that the new cancellation framework is compatible with legacy APIs.</span></span> <span data-ttu-id="84606-145">새로운 권장 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 형식을 사용하는 예에 대해서는 [방법: 작업 및 해당 자식 취소](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84606-145">For an example that uses the new, preferred <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> type, see [How to: Cancel a Task and Its Children](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
 [!code-csharp[Cancellation#1](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex1.cs#1)]
 [!code-vb[Cancellation#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex1.vb#1)]  
  
## <a name="operation-cancellation-versus-object-cancellation"></a><span data-ttu-id="84606-146">작업 취소 대 개체 취소</span><span class="sxs-lookup"><span data-stu-id="84606-146">Operation Cancellation Versus Object Cancellation</span></span>  
 <span data-ttu-id="84606-147">새 취소 프레임워크에서 취소는 개체가 아니라 작업을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="84606-147">In the new cancellation framework, cancellation refers to operations, not objects.</span></span> <span data-ttu-id="84606-148">취소 요청은 필요한 정리가 수행되고 나서 가능하면 즉시 작업이 중지되어야 함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-148">The cancellation request means that the operation should stop as soon as possible after any required cleanup is performed.</span></span> <span data-ttu-id="84606-149">취소 토큰 하나가 “취소할 수 있는 작업" 하나를 나타내야 하지만 해당 작업은 프로그램에서 구현될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-149">One cancellation token should refer to one "cancelable operation," however that operation may be implemented in your program.</span></span> <span data-ttu-id="84606-150">토큰의 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 속성이 `true`로 설정되고 나면 `false`로 재설정될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-150">After the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token has been set to `true`, it cannot be reset to `false`.</span></span> <span data-ttu-id="84606-151">따라서 취소 토큰이 취소된 후에는 해당 토큰을 다시 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-151">Therefore, cancellation tokens cannot be reused after they have been canceled.</span></span>  
  
 <span data-ttu-id="84606-152">개체 취소 메커니즘이 필요하면 다음 예제와 같이 <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> 메서드를 호출하여 작업 취소 메커니즘을 기반으로 개체 취소 메커니즘을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-152">If you require an object cancellation mechanism, you can base it on the operation cancellation mechanism by calling the <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> method, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#2](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/objectcancellation1.cs#2)]
 [!code-vb[Cancellation#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/objectcancellation1.vb#2)]  
  
 <span data-ttu-id="84606-153">개체가 동시 취소 가능 작업을 두 개 이상 지원하면 개별 토큰을 개별 취소 가능한 작업에 입력으로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-153">If an object supports more than one concurrent cancelable operation, pass a separate token as input to each distinct cancelable operation.</span></span> <span data-ttu-id="84606-154">이런 방식으로 다른 작업에 영향을 미치지 않고 작업을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-154">That way, one operation can be cancelled without affecting the others.</span></span>  
  
## <a name="listening-and-responding-to-cancellation-requests"></a><span data-ttu-id="84606-155">취소 요청 수신 대기 및 응답</span><span class="sxs-lookup"><span data-stu-id="84606-155">Listening and Responding to Cancellation Requests</span></span>  
 <span data-ttu-id="84606-156">사용자 대리자에서 취소 가능한 작업의 구현자는 취소 요청에 대한 응답으로 작업을 종료하는 방법을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-156">In the user delegate, the implementer of a cancelable operation determines how to terminate the operation in response to a cancellation request.</span></span> <span data-ttu-id="84606-157">대부분 경우에 사용자 대리자는 필요한 정리를 수행하고 즉시 반환될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-157">In many cases, the user delegate can just perform any required cleanup and then return immediately.</span></span>  
  
 <span data-ttu-id="84606-158">그러나 더 복잡한 경우에 사용자 대리자가 취소가 발생했다는 정보를 라이브러리 코드에 알려야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-158">However, in more complex cases, it might be necessary for the user delegate to notify library code that cancellation has occurred.</span></span> <span data-ttu-id="84606-159">이 경우 작업을 종료하는 올바른 방법은 <xref:System.OperationCanceledException>을 throw하는 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> 메서드를 대리자가 호출하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="84606-159">In such cases, the correct way to terminate the operation is for the delegate to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>, method, which will cause an <xref:System.OperationCanceledException> to be thrown.</span></span> <span data-ttu-id="84606-160">라이브러리 코드는 사용자 대리자 스레드에서 이 예외를 catch하고 예외의 토큰을 검사하여 예외가 협조적 취소를 나타내는지, 아니면 다른 예외적인 상황인지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-160">Library code can catch this exception on the user delegate thread and examine the exception's token to determine whether the exception indicates cooperative cancellation or some other exceptional situation.</span></span>  
  
 <span data-ttu-id="84606-161"><xref:System.Threading.Tasks.Task> 클래스는 이 방식으로 <xref:System.OperationCanceledException>을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-161">The <xref:System.Threading.Tasks.Task> class handles <xref:System.OperationCanceledException> in this way.</span></span> <span data-ttu-id="84606-162">자세한 내용은 [작업 취소](../../../docs/standard/parallel-programming/task-cancellation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84606-162">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
### <a name="listening-by-polling"></a><span data-ttu-id="84606-163">폴링으로 수신 대기</span><span class="sxs-lookup"><span data-stu-id="84606-163">Listening by Polling</span></span>  
 <span data-ttu-id="84606-164">루핑되거나 재귀적으로 사용되는 장기 실행 계산의 경우 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> 속성 값을 주기적으로 폴링하여 취소 요청을 수신 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-164">For long-running computations that loop or recurse, you can listen for a cancellation request by periodically polling the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="84606-165">값이 `true`이면 메서드가 가능한 한 빠르게 정리 및 종료되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-165">If its value is `true`, the method should clean up and terminate as quickly as possible.</span></span> <span data-ttu-id="84606-166">최적 폴링 빈도는 응용 프로그램 형식에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="84606-166">The optimal frequency of polling depends on the type of application.</span></span> <span data-ttu-id="84606-167">특정 프로그램에 대한 최적 폴링 빈도는 개발자가 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-167">It is up to the developer to determine the best polling frequency for any given program.</span></span> <span data-ttu-id="84606-168">폴링 자체는 성능에 큰 영향을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-168">Polling itself does not significantly impact performance.</span></span> <span data-ttu-id="84606-169">다음 예제에서는 한 가지 가능한 폴링 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="84606-169">The following example shows one possible way to poll.</span></span>  
  
 [!code-csharp[Cancellation#3](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex11.cs#3)]
 [!code-vb[Cancellation#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex11.vb#3)]  
  
 <span data-ttu-id="84606-170">더 자세한 예제를 보려면 [방법: 폴링을 통해 취소 요청 수신 대기](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-by-polling.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84606-170">For a more complete example, see [How to: Listen for Cancellation Requests by Polling](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-by-polling.md).</span></span>  
  
### <a name="listening-by-registering-a-callback"></a><span data-ttu-id="84606-171">콜백을 등록하여 수신 대기</span><span class="sxs-lookup"><span data-stu-id="84606-171">Listening by Registering a Callback</span></span>  
 <span data-ttu-id="84606-172">일부 작업은 적절한 시기에 취소 토큰의 값을 확인할 수 없는 방식으로 차단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-172">Some operations can become blocked in such a way that they cannot check the value of the cancellation token in a timely manner.</span></span> <span data-ttu-id="84606-173">이러한 경우에는 취소 요청이 수신될 때 메서드를 차단 해제하는 콜백 메서드를 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-173">For these cases, you can register a callback method that unblocks the method when a cancellation request is received.</span></span>  
  
 <span data-ttu-id="84606-174"><xref:System.Threading.CancellationToken.Register%2A> 메서드는 특히 이 목적으로 사용되는 <xref:System.Threading.CancellationTokenRegistration> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-174">The <xref:System.Threading.CancellationToken.Register%2A> method returns a <xref:System.Threading.CancellationTokenRegistration> object that is used specifically for this purpose.</span></span> <span data-ttu-id="84606-175">다음 예제에서는 <xref:System.Threading.CancellationToken.Register%2A> 메서드를 사용하여 비동기 웹 요청을 취소하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="84606-175">The following example shows how to use the <xref:System.Threading.CancellationToken.Register%2A> method to cancel an asynchronous Web request.</span></span>  
  
 [!code-csharp[Cancellation#4](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex4.cs#4)]
 [!code-vb[Cancellation#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex4.vb#4)]  
  
 <span data-ttu-id="84606-176"><xref:System.Threading.CancellationTokenRegistration> 개체는 스레드 동기화를 관리하고 콜백이 정확한 시점에 실행을 중지하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-176">The <xref:System.Threading.CancellationTokenRegistration> object manages thread synchronization and ensures that the callback will stop executing at a precise point in time.</span></span>  
  
 <span data-ttu-id="84606-177">시스템 응답성을 확인하고 교착 상태를 방지하려면 콜백을 등록할 때 다음 지침을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-177">In order to ensure system responsiveness and to avoid deadlocks, the following guidelines must be followed when registering callbacks:</span></span>  
  
-   <span data-ttu-id="84606-178">콜백 메서드는 동기적으로 호출되어 콜백이 반환될 때까지 <xref:System.Threading.CancellationTokenSource.Cancel%2A>에 대한 호출이 반환되지 않으므로 콜백 메서드는 빨라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-178">The callback method should be fast because it is called synchronously and therefore the call to <xref:System.Threading.CancellationTokenSource.Cancel%2A> does not return until the callback returns.</span></span>  
  
-   <span data-ttu-id="84606-179">콜백이 실행되는 동안 <xref:System.Threading.CancellationTokenRegistration.Dispose%2A>를 호출하고 콜백이 대기하도록 잠금을 유지하면 프로그램에서 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-179">If you call <xref:System.Threading.CancellationTokenRegistration.Dispose%2A> while the callback is running, and you hold a lock that the callback is waiting on, your program can deadlock.</span></span> <span data-ttu-id="84606-180">`Dispose`가 반환되고 나서 콜백에 필요한 리소스를 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-180">After `Dispose` returns, you can free any resources required by the callback.</span></span>  
  
-   <span data-ttu-id="84606-181">콜백은 한 콜백에서 수동 스레드 또는 <xref:System.Threading.SynchronizationContext> 사용을 수행하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84606-181">Callbacks should not perform any manual thread or <xref:System.Threading.SynchronizationContext> usage in a callback.</span></span> <span data-ttu-id="84606-182">콜백이 특정 스레드에서 실행되어야 하면 대상 syncContext가 활성 <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType>가 되도록 지정할 수 있는 <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType> 생성자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-182">If a callback must run on a particular thread, use the <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType> constructor that enables you to specify that the target syncContext is the active <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="84606-183">콜백에서 수동 스레딩을 수행하면 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-183">Performing manual threading in a callback can cause deadlock.</span></span>  
  
 <span data-ttu-id="84606-184">더 자세한 예제를 보려면 [방법: 취소 요청에 대한 콜백 등록](../../../docs/standard/threading/how-to-register-callbacks-for-cancellation-requests.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84606-184">For a more complete example, see [How to: Register Callbacks for Cancellation Requests](../../../docs/standard/threading/how-to-register-callbacks-for-cancellation-requests.md).</span></span>  
  
### <a name="listening-by-using-a-wait-handle"></a><span data-ttu-id="84606-185">대기 핸들을 사용하여 수신 대기</span><span class="sxs-lookup"><span data-stu-id="84606-185">Listening by Using a Wait Handle</span></span>  
 <span data-ttu-id="84606-186">취소할 수 있는 작업이 <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> 또는 <xref:System.Threading.Semaphore?displayProperty=nameWithType>와 같은 동기화 기본 형식에서 대기하는 동안 차단되면 <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> 속성을 사용하여 작업이 이벤트 및 취소 요청에서 대기하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-186">When a cancelable operation can block while it waits on a synchronization primitive such as a <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> or <xref:System.Threading.Semaphore?displayProperty=nameWithType>, you can use the <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> property to enable the operation to wait on both the event and the cancellation request.</span></span> <span data-ttu-id="84606-187">취소 토큰의 대기 핸들은 취소 요청에 대한 응답으로 신호가 전송되고 메서드는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드의 반환 값을 사용하여 신호를 전송한 취소 토큰이었는지를 판별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-187">The wait handle of the cancellation token will become signaled in response to a cancellation request, and the method can use the return value of the <xref:System.Threading.WaitHandle.WaitAny%2A> method to determine whether it was the cancellation token that signaled.</span></span> <span data-ttu-id="84606-188">그리고 나서 작업은 적절하게 종료되거나 <xref:System.OperationCanceledException>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-188">The operation can then just exit, or throw a <xref:System.OperationCanceledException>, as appropriate.</span></span>  
  
 [!code-csharp[Cancellation#5](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex9.cs#5)]
 [!code-vb[Cancellation#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex9.vb#5)]  
  
 <span data-ttu-id="84606-189">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]을(를) 대상으로 지정한 새 코드에서 <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> 및 <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>은 둘 다 `Wait` 메서드에서 새 취소 프레임워크를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-189">In new code that targets the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> both support the new cancellation framework in their `Wait` methods.</span></span> <span data-ttu-id="84606-190"><xref:System.Threading.CancellationToken>을 메서드에 전달하고 취소가 요청될 대 이벤트가 활성화되어 <xref:System.OperationCanceledException>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-190">You can pass the <xref:System.Threading.CancellationToken> to the method, and when the cancellation is requested, the event wakes up and throws an <xref:System.OperationCanceledException>.</span></span>  
  
 [!code-csharp[Cancellation#6](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex10.cs#6)]
 [!code-vb[Cancellation#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex10.vb#6)]  
  
 <span data-ttu-id="84606-191">더 자세한 예제를 보려면 [방법: 대기 핸들이 있는 취소 요청 수신 대기](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-that-have-wait-handles.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84606-191">For a more complete example, see [How to: Listen for Cancellation Requests That Have Wait Handles](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-that-have-wait-handles.md).</span></span>  
  
### <a name="listening-to-multiple-tokens-simultaneously"></a><span data-ttu-id="84606-192">동시에 여러 토큰 수신 대기</span><span class="sxs-lookup"><span data-stu-id="84606-192">Listening to Multiple Tokens Simultaneously</span></span>  
 <span data-ttu-id="84606-193">경우에 따라 수신기는 여러 취소 토큰을 동시에 수신 대기해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-193">In some cases, a listener may have to listen to multiple cancellation tokens simultaneously.</span></span> <span data-ttu-id="84606-194">예를 들어 취소 가능한 작업은 외부에서 메서드 매개 변수에 인수로 전달되는 토큰 이외에 내부 취소 토큰을 모니터링해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-194">For example, a cancelable operation may have to monitor an internal cancellation token in addition to a token passed in externally as an argument to a method parameter.</span></span> <span data-ttu-id="84606-195">이 작업을 하려면 다음 예제와 같이 토큰 두 개 이상을 토큰 하나로 결합할 수 있는 연결된 토큰 소스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="84606-195">To accomplish this, create a linked token source that can join two or more tokens into one token, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#7](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex13.cs#7)]
 [!code-vb[Cancellation#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex13.vb#7)]  
  
 <span data-ttu-id="84606-196">작업을 완료했을 때 연결된 토큰 소스에서 `Dispose`를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-196">Notice that you must call `Dispose` on the linked token source when you are done with it.</span></span> <span data-ttu-id="84606-197">더 자세한 예제를 보려면 [방법: 여러 취소 요청 수신 대기](../../../docs/standard/threading/how-to-listen-for-multiple-cancellation-requests.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84606-197">For a more complete example, see [How to: Listen for Multiple Cancellation Requests](../../../docs/standard/threading/how-to-listen-for-multiple-cancellation-requests.md).</span></span>  
  
## <a name="cooperation-between-library-code-and-user-code"></a><span data-ttu-id="84606-198">라이브러리 코드와 사용자 코드 간 협력</span><span class="sxs-lookup"><span data-stu-id="84606-198">Cooperation Between Library Code and User Code</span></span>  
 <span data-ttu-id="84606-199">통합 취소 프레임워크를 사용하면 라이브러리 코드에서 사용자 코드를 취소하고 사용자 코드에서 협조적 방식으로 라이브러리 코드를 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-199">The unified cancellation framework makes it possible for library code to cancel user code, and for user code to cancel library code in a cooperative manner.</span></span> <span data-ttu-id="84606-200">원활한 협력은 다음 지침에 따라 양측에 의존합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-200">Smooth cooperation depends on each side following these guidelines:</span></span>  
  
-   <span data-ttu-id="84606-201">취소 가능한 작업을 제공하는 라이브러리 코드는 사용자 코드가 취소를 요청할 수 있도록 외부 취소 토큰을 허용하는 공용 메서드도 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-201">If library code provides cancelable operations, it should also provide public methods that accept an external cancellation token so that user code can request cancellation.</span></span>  
  
-   <span data-ttu-id="84606-202">라이브러리 코드가 사용자 코드를 호출하면 라이브러리 코드는 OperationCanceledException(externalToken)을 *협조적 취소*로 해석하고 오류 예외로 해석할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84606-202">If library code calls into user code, the library code should interpret an OperationCanceledException(externalToken) as *cooperative cancellation*, and not necessarily as a failure exception.</span></span>  
  
-   <span data-ttu-id="84606-203">사용자 대리자는 적절한 시간에 라이브러리 코드의 취소 요청에 응답해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84606-203">User-delegates should attempt to respond to cancellation requests from library code in a timely manner.</span></span>  
  
 <span data-ttu-id="84606-204"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 및 <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>은 이들 지침을 따르는 클래스의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="84606-204"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> are examples of classes that follows these guidelines.</span></span> <span data-ttu-id="84606-205">자세한 내용은 [작업 취소](../../../docs/standard/parallel-programming/task-cancellation.md) 및 [방법: PLINQ 쿼리 취소](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84606-205">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md)and [How to: Cancel a PLINQ Query](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="84606-206">참고 항목</span><span class="sxs-lookup"><span data-stu-id="84606-206">See Also</span></span>  
 [<span data-ttu-id="84606-207">관리되는 스레딩 기본 사항</span><span class="sxs-lookup"><span data-stu-id="84606-207">Managed Threading Basics</span></span>](../../../docs/standard/threading/managed-threading-basics.md)

---
title: 스레드 및 스레딩
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: ''
ms.suite: ''
ms.technology: dotnet-standard
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- multiple threads
- threading [.NET Framework]
- threading [.NET Framework], multiple threads
ms.assetid: 5baac3aa-e603-4fa6-9f89-0f2c1084e6b1
caps.latest.revision: 14
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 02c676e3bb6c0dcc9e65858367d13f41adc797e8
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/18/2018
---
# <a name="threads-and-threading"></a><span data-ttu-id="e7407-102">스레드 및 스레딩</span><span class="sxs-lookup"><span data-stu-id="e7407-102">Threads and Threading</span></span>
<span data-ttu-id="e7407-103">운영 체제에서는 프로세스를 사용하여 실행 중인 서로 다른 응용 프로그램을 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-103">Operating systems use processes to separate the different applications that they are executing.</span></span> <span data-ttu-id="e7407-104">스레드는 운영 체제가 프로세서 시간을 할당하는 기본 단위이며 둘 이상의 스레드가 해당 프로세스 내에서 코드를 실행 중일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-104">Threads are the basic unit to which an operating system allocates processor time, and more than one thread can be executing code inside that process.</span></span> <span data-ttu-id="e7407-105">각 스레드는 예외 처리기, 예약 우선 순위 및 시스템에서 스레드가 예약될 때까지 스레드 컨텍스트를 저장하는 데 사용하는 구조 집합을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-105">Each thread maintains exception handlers, a scheduling priority, and a set of structures the system uses to save the thread context until it is scheduled.</span></span> <span data-ttu-id="e7407-106">스레드 컨텍스트에는 스레드의 CPU 레지스터 및 스택 집합을 포함하여 스레드가 실행을 원활하게 재개하는 데 필요한 모든 정보가 스레드 호스트 프로세스의 주소 공간에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-106">The thread context includes all the information the thread needs to seamlessly resume execution, including the thread's set of CPU registers and stack, in the address space of the thread's host process.</span></span>  
  
 <span data-ttu-id="e7407-107">.NET Framework가 <xref:System.AppDomain?displayProperty=nameWithType>으로 표시된 응용 프로그램 도메인이라는 간단한 관리되는 하위 프로세스로 운영 체제 프로세스를 추가로 세분화합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-107">The .NET Framework further subdivides an operating system process into lightweight managed subprocesses, called application domains, represented by <xref:System.AppDomain?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e7407-108">하나 이상의 관리되는 스레드(<xref:System.Threading.Thread?displayProperty=nameWithType>로 표시됨)가 동일한 관리되는 프로세스 내에 있는 하나 이상의 응용 프로그램 도메인에서 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-108">One or more managed threads (represented by <xref:System.Threading.Thread?displayProperty=nameWithType>) can run in one or any number of application domains within the same managed process.</span></span> <span data-ttu-id="e7407-109">각 응용 프로그램 도메인은 단일 스레드로 시작되지만 해당 응용 프로그램 도메인의 코드는 추가 응용 프로그램 도메인과 추가 스레드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-109">Although each application domain is started with a single thread, code in that application domain can create additional application domains and additional threads.</span></span> <span data-ttu-id="e7407-110">결과는 관리되는 스레드가 동일한 관리되는 프로세스 내에서 응용 프로그램 도메인 간에 자유롭게 이동할 수 있다는 것입니다. 여러 응용 프로그램 도메인 간에는 하나의 스레드만 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-110">The result is that a managed thread can move freely between application domains inside the same managed process; you might have only one thread moving among several application domains.</span></span>  
  
 <span data-ttu-id="e7407-111">선점 멀티태스킹을 지원하는 운영 체제는 여러 프로세스에서 여러 스레드를 동시에 실행하는 효과를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-111">An operating system that supports preemptive multitasking creates the effect of simultaneous execution of multiple threads from multiple processes.</span></span> <span data-ttu-id="e7407-112">이 작업을 수행하기 위해 사용 가능한 프로세서 시간을, 이를 필요로 하는 스레드 간에 나누어 프로세서 시간 조각을 차례로 각 스레드에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-112">It does this by dividing the available processor time among the threads that need it, allocating a processor time slice to each thread one after another.</span></span> <span data-ttu-id="e7407-113">현재 실행 중인 스레드는 시간 조각이 경과하고 또 다른 스레드가 실행을 재개할 때 일시 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-113">The currently executing thread is suspended when its time slice elapses, and another thread resumes running.</span></span> <span data-ttu-id="e7407-114">시스템이 한 스레드에서 다른 스레드로 전환할 때 시스템에서는 선점 스레드의 스레드 컨텍스트를 저장하고 스레드 큐에 있는 다음 스레드의 저장된 스레드 컨텍스트를 다시 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-114">When the system switches from one thread to another, it saves the thread context of the preempted thread and reloads the saved thread context of the next thread in the thread queue.</span></span>  
  
 <span data-ttu-id="e7407-115">시간 조각 길이는 운영 체제와 프로세서에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-115">The length of the time slice depends on the operating system and the processor.</span></span> <span data-ttu-id="e7407-116">각 시간 조각은 작으므로 하나의 프로세서만 있는 경우에도 동시에 여러 스레드가 실행되는 것처럼 보입니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-116">Because each time slice is small, multiple threads appear to be executing at the same time, even if there is only one processor.</span></span> <span data-ttu-id="e7407-117">이 경우는 실제로 실행 가능 스레드가 사용 가능한 프로세서 간에 분산되는 멀티 프로세서 시스템에서 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-117">This is actually the case on multiprocessor systems, where the executable threads are distributed among the available processors.</span></span>  
  
## <a name="when-to-use-multiple-threads"></a><span data-ttu-id="e7407-118">다중 스레드 사용 시기</span><span class="sxs-lookup"><span data-stu-id="e7407-118">When To Use Multiple Threads</span></span>  
 <span data-ttu-id="e7407-119">사용자 조작이 필요한 소프트웨어는 풍부한 사용자 환경을 제공하기 위해 가능한 한 빠르게 사용자 활동에 대응해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-119">Software that requires user interaction must react to the user's activities as rapidly as possible to provide a rich user experience.</span></span> <span data-ttu-id="e7407-120">그러나 동시에 사용자에게 데이터를 가능한 한 빠르게 제공하는 데 필요한 계산을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-120">At the same time, however, it must do the calculations necessary to present data to the user as fast as possible.</span></span> <span data-ttu-id="e7407-121">응용 프로그램에서 실행 스레드를 하나만 사용하는 경우 [비동기 프로그래밍](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)을 [.NET Framework 원격](https://msdn.microsoft.com/library/eccb1d31-0a22-417a-97fd-f4f1f3aa4462)과 결합하거나 ASP.NET으로 만든 [XML Web services](https://msdn.microsoft.com/library/1e64af78-d705-4384-b08d-591a45f4379c)와 결합하면 자체 처리 시간 이외에 다른 컴퓨터의 처리 시간을 사용하여 사용자에게 더 빠르게 응답하고 응용 프로그램의 데이터 처리 시간을 단축할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-121">If your application uses only one thread of execution, you can combine [asynchronous programming](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) with[.NET Framework remoting](https://msdn.microsoft.com/library/eccb1d31-0a22-417a-97fd-f4f1f3aa4462) or [XML Web services](https://msdn.microsoft.com/library/1e64af78-d705-4384-b08d-591a45f4379c) created using ASP.NET to use the processing time of other computers in addition to that of your own to increase responsiveness to the user and decrease the data processing time of your application.</span></span> <span data-ttu-id="e7407-122">집약적인 입/출력 작업을 수행하는 경우 I/O 완료 포트를 사용하여 응용 프로그램의 응답성을 향상할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-122">If you are doing intensive input/output work, you can also use I/O completion ports to increase your application's responsiveness.</span></span>  
  
### <a name="advantages-of-multiple-threads"></a><span data-ttu-id="e7407-123">여러 스레드의 장점</span><span class="sxs-lookup"><span data-stu-id="e7407-123">Advantages of Multiple Threads</span></span>  
 <span data-ttu-id="e7407-124">그러나 둘 이상의 스레드를 사용하는 것이 사용자에 대한 응답성을 향상하고 작업을 거의 동시에 완료하는 데 필요한 데이터를 처리할 수 있는 가장 강력한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-124">Using more than one thread, however, is the most powerful technique available to increase responsiveness to the user and process the data necessary to get the job done at almost the same time.</span></span> <span data-ttu-id="e7407-125">하나의 프로세서가 있는 컴퓨터에서 여러 스레드가 이 효과를 만들 수 있으므로 사용자 이벤트 간의 짧은 시간을 활용하여 데이터를 백그라운드에서 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-125">On a computer with one processor, multiple threads can create this effect, taking advantage of the small periods of time in between user events to process the data in the background.</span></span> <span data-ttu-id="e7407-126">예를 들어 다른 스레드가 동일한 응용 프로그램 내에서 스프레드시트의 다른 부분을 다시 계산하는 동안 사용자가 스프레드시트를 편집할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-126">For example, a user can edit a spreadsheet while another thread is recalculating other parts of the spreadsheet within the same application.</span></span>  
  
 <span data-ttu-id="e7407-127">수정이 없으면 동일한 응용 프로그램이 둘 이상의 프로세서가 있는 컴퓨터에서 실행될 때 사용자 만족도가 크게 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-127">Without modification, the same application would dramatically increase user satisfaction when run on a computer with more than one processor.</span></span> <span data-ttu-id="e7407-128">단일 응용 프로그램 도메인은 여러 스레드를 사용하여 다음 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-128">Your single application domain could use multiple threads to accomplish the following tasks:</span></span>  
  
-   <span data-ttu-id="e7407-129">네트워크를 통해, 웹 서버 및 데이터베이스와 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-129">Communicate over a network, to a Web server, and to a database.</span></span>  
  
-   <span data-ttu-id="e7407-130">시간이 오래 걸리는 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-130">Perform operations that take a large amount of time.</span></span>  
  
-   <span data-ttu-id="e7407-131">다양한 우선 순위의 작업을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-131">Distinguish tasks of varying priority.</span></span> <span data-ttu-id="e7407-132">예를 들어 우선 순위가 높은 스레드는 시간이 중요한 작업을 관리하고 우선 순위가 낮은 스레드는 다른 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-132">For example, a high-priority thread manages time-critical tasks, and a low-priority thread performs other tasks.</span></span>  
  
-   <span data-ttu-id="e7407-133">백그라운드 작업에 시간을 할당하면서 사용자 인터페이스가 계속 빠르게 응답하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-133">Allow the user interface to remain responsive, while allocating time to background tasks.</span></span>  
  
### <a name="disadvantages-of-multiple-threads"></a><span data-ttu-id="e7407-134">다중 스레드의 단점</span><span class="sxs-lookup"><span data-stu-id="e7407-134">Disadvantages of Multiple Threads</span></span>  
 <span data-ttu-id="e7407-135">가능한 한 적은 스레드를 사용하여 운영 체제 리소스 사용을 최소화하고 성능을 개선하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-135">It is recommended that you use as few threads as possible, thereby minimizing the use of operating-system resources and improving performance.</span></span> <span data-ttu-id="e7407-136">스레딩에는 응용 프로그램을 디자인할 때 고려할 리소스 요구사항과 잠재적 충돌도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-136">Threading also has resource requirements and potential conflicts to be considered when designing your application.</span></span> <span data-ttu-id="e7407-137">리소스 요구 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-137">The resource requirements are as follows:</span></span>  
  
-   <span data-ttu-id="e7407-138">시스템은 프로세스, **AppDomain** 개체 및 스레드에 필요한 컨텍스트 정보에 대해 메모리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-138">The system consumes memory for the context information required by processes, **AppDomain** objects, and threads.</span></span> <span data-ttu-id="e7407-139">따라서 만들 수 있는 프로세스, **AppDomain** 개체 및 스레드의 개수는 사용 가능한 메모리로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-139">Therefore, the number of processes, **AppDomain** objects, and threads that can be created is limited by available memory.</span></span>  
  
-   <span data-ttu-id="e7407-140">많은 스레드를 추적하는 데는 상당한 프로세서 시간이 소비됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-140">Keeping track of a large number of threads consumes significant processor time.</span></span> <span data-ttu-id="e7407-141">스레드가 너무 많으면 대부분의 스레드가 상당한 향상을 달성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-141">If there are too many threads, most of them will not make significant progress.</span></span> <span data-ttu-id="e7407-142">대부분의 현재 스레드가 하나의 프로세스에 있는 경우 다른 프로세스의 스레드가 예약되는 빈도가 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-142">If most of the current threads are in one process, threads in other processes are scheduled less frequently.</span></span>  
  
-   <span data-ttu-id="e7407-143">많은 스레드를 사용하여 코드 실행을 제어하는 것은 복잡하며 많은 버그의 출처가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-143">Controlling code execution with many threads is complex, and can be a source of many bugs.</span></span>  
  
-   <span data-ttu-id="e7407-144">스레드를 삭제하려면 발생할 수 있는 상황을 알고 있어야 하고 해당 문제를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-144">Destroying threads requires knowing what could happen and handling those issues.</span></span>  
  
 <span data-ttu-id="e7407-145">리소스에 대한 공유 액세스를 제공하면 충돌이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-145">Providing shared access to resources can create conflicts.</span></span> <span data-ttu-id="e7407-146">충돌을 피하려면 공유 리소스에 대한 액세스를 동기화하거나 제어해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-146">To avoid conflicts, you must synchronize, or control the access to, shared resources.</span></span> <span data-ttu-id="e7407-147">동일하거나 서로 다른 응용 프로그램 도메인 내에서 액세스를 제대로 동기화하지 못하면 교착 상태(두 개의 스레드가 각각 다른 스레드가 완료될 때까지 대기하는 동안 응답을 중지하는 경우) 및 경합 상태(두 이벤트의 타이밍에 대한 예기치 않은 중요 종속성으로 인해 비정상적인 결과가 발생할 경우) 같은 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-147">Failure to synchronize access properly (in the same or different application domains) can lead to problems such as deadlocks (in which two threads stop responding while each waits for the other to complete) and race conditions (when an anomalous result occurs due to an unexpected critical dependence on the timing of two events).</span></span> <span data-ttu-id="e7407-148">시스템은 여러 스레드 간에 리소스 공유를 조정하는 데 사용할 수 있는 동기화 개체를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-148">The system provides synchronization objects that can be used to coordinate resource sharing among multiple threads.</span></span> <span data-ttu-id="e7407-149">스레드 수를 줄이면 리소스를 더 쉽게 동기화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-149">Reducing the number of threads makes it easier to synchronize resources.</span></span>  
  
 <span data-ttu-id="e7407-150">동기화가 필요한 리소스는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-150">Resources that require synchronization include:</span></span>  
  
-   <span data-ttu-id="e7407-151">시스템 리소스(예: 통신 포트).</span><span class="sxs-lookup"><span data-stu-id="e7407-151">System resources (such as communications ports).</span></span>  
  
-   <span data-ttu-id="e7407-152">여러 프로세스에서 공유되는 리소스(예: 파일 핸들).</span><span class="sxs-lookup"><span data-stu-id="e7407-152">Resources shared by multiple processes (such as file handles).</span></span>  
  
-   <span data-ttu-id="e7407-153">여러 스레드가 액세스하는 단일 응용 프로그램 도메인의 리소스(예: 전역, 정적 및 인스턴스 필드).</span><span class="sxs-lookup"><span data-stu-id="e7407-153">The resources of a single application domain (such as global, static, and instance fields) accessed by multiple threads.</span></span>  
  
### <a name="threading-and-application-design"></a><span data-ttu-id="e7407-154">스레딩 및 응용 프로그램 디자인</span><span class="sxs-lookup"><span data-stu-id="e7407-154">Threading and Application Design</span></span>  
 <span data-ttu-id="e7407-155">일반적으로 <xref:System.Threading.ThreadPool> 클래스를 사용하는 것은 특정 작업 예약이 필요하지 않은 경우 다른 스레드를 차단하지 않고 비교적 짧은 작업에 대해 여러 스레드를 처리하는 가장 간편한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-155">In general, using the <xref:System.Threading.ThreadPool> class is the easiest way to handle multiple threads for relatively short tasks that will not block other threads and when you do not expect any particular scheduling of the tasks.</span></span> <span data-ttu-id="e7407-156">그러나 고유한 스레드를 만드는 것에는 여러 가지 이유가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-156">However, there are a number of reasons to create your own threads:</span></span>  
  
-   <span data-ttu-id="e7407-157">작업에 특정 우선 순위를 포함해야 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="e7407-157">If you need a task to have a particular priority.</span></span>  
  
-   <span data-ttu-id="e7407-158">장시간 실행되어 다른 작업을 차단할 수 있는 작업이 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="e7407-158">If you have a task that might run a long time (and therefore block other tasks).</span></span>  
  
-   <span data-ttu-id="e7407-159">단일 스레드 아파트에 스레드를 배치해야 하는 경우(모든 **ThreadPool** 스레드가 다중 스레드 아파트에 있음).</span><span class="sxs-lookup"><span data-stu-id="e7407-159">If you need to place threads into a single-threaded apartment (all **ThreadPool** threads are in the multithreaded apartment).</span></span>  
  
-   <span data-ttu-id="e7407-160">스레드와 연결된 안정적인 ID가 필요한 경우.</span><span class="sxs-lookup"><span data-stu-id="e7407-160">If you need a stable identity associated with the thread.</span></span> <span data-ttu-id="e7407-161">예를 들어 전용 스레드를 사용하여 해당 스레드를 중단하거나, 일시 중단하거나, 이름별로 검색해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-161">For example, you should use a dedicated thread to abort that thread, suspend it, or discover it by name.</span></span>  
  
-   <span data-ttu-id="e7407-162">사용자 인터페이스와 상호 작용하는 백그라운드 스레드를 실행해야 하는 경우 .NET Framework 버전 2.0은 사용자 인터페이스 스레드에 대한 크로스 스레드 마샬링을 통해 이벤트를 사용하여 통신하는 <xref:System.ComponentModel.BackgroundWorker> 구성 요소를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-162">If you need to run background threads that interact with the user interface, the .NET Framework version 2.0 provides a <xref:System.ComponentModel.BackgroundWorker> component that communicates using events, with cross-thread marshaling to the user-interface thread.</span></span>  
  
### <a name="threading-and-exceptions"></a><span data-ttu-id="e7407-163">스레딩 및 예외</span><span class="sxs-lookup"><span data-stu-id="e7407-163">Threading and Exceptions</span></span>  
 <span data-ttu-id="e7407-164">스레드에서 예외를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-164">Do handle exceptions in threads.</span></span> <span data-ttu-id="e7407-165">백그라운드 스레드를 포함하여 스레드의 처리되지 않은 예외는 일반적으로 프로세스를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-165">Unhandled exceptions in threads, even background threads, generally terminate the process.</span></span> <span data-ttu-id="e7407-166">이 규칙에는 다음 세 가지 예외 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-166">There are three exceptions to this rule:</span></span>  
  
-   <span data-ttu-id="e7407-167"><xref:System.Threading.Thread.Abort%2A>가 호출되었으므로 스레드에서 <xref:System.Threading.ThreadAbortException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-167">A <xref:System.Threading.ThreadAbortException> is thrown in a thread because <xref:System.Threading.Thread.Abort%2A> was called.</span></span>  
  
-   <span data-ttu-id="e7407-168">응용 프로그램 도메인이 언로드되고 있으므로 스레드에서 <xref:System.AppDomainUnloadedException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-168">An <xref:System.AppDomainUnloadedException> is thrown in a thread because the application domain is being unloaded.</span></span>  
  
-   <span data-ttu-id="e7407-169">공용 언어 런타임 또는 호스트 프로세스에서 스레드를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-169">The common language runtime or a host process terminates the thread.</span></span>  
  
 <span data-ttu-id="e7407-170">자세한 내용은 [관리되는 스레드의 예외](../../../docs/standard/threading/exceptions-in-managed-threads.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e7407-170">For more information, see [Exceptions in Managed Threads](../../../docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e7407-171">예를 들어 .NET Framework 버전 1.0 및 1.1에서는 공용 언어 런타임이 스레드 풀 스레드에서 일부 예외를 자동으로 포착합니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-171">In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps some exceptions, for example in thread pool threads.</span></span> <span data-ttu-id="e7407-172">이는 손상된 응용 프로그램 상태일 수 있으며 결국 응용 프로그램이 중단되게 하여 디버그하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7407-172">This may corrupt application state and eventually cause applications to hang, which might be very difficult to debug.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e7407-173">참고 항목</span><span class="sxs-lookup"><span data-stu-id="e7407-173">See Also</span></span>  
 <xref:System.Threading.ThreadPool>  
 <xref:System.ComponentModel.BackgroundWorker>  
 [<span data-ttu-id="e7407-174">다중 스레딩을 위한 데이터 동기화</span><span class="sxs-lookup"><span data-stu-id="e7407-174">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [<span data-ttu-id="e7407-175">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="e7407-175">The Managed Thread Pool</span></span>](../../../docs/standard/threading/the-managed-thread-pool.md)

---
title: "일반적인 웹 응용 프로그램 아키텍처"
description: "ASP.NET Core 및 Microsoft Azure로 웹 응용 프로그램을 설계 | 일반적인 웹 응용 프로그램 아키텍처"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: b6236cfab290211f930d6a1987075abeade4fd6d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
#<a name="common-web-application-architectures"></a>일반적인 웹 응용 프로그램 아키텍처

> "아키텍처는 비용이 많이 드는 좋은 생각 되 면, 잘못 된 아키텍처를 시도 하십시오."  
> _-Brian Foote 및 Yoder 있습니다._

## <a name="summary"></a>요약

대부분의 일반적인.NET 응용 프로그램은 실행 파일 또는 단일 IIS appdomain 내에서 실행 되는 단일 웹 응용 프로그램에 해당 하는 하나의 단위로 배포 합니다. 이 가장 간단한 배포 모델 및 상태일 때 잘 많은 내부 및 공용 더 작은 응용 프로그램을 사용 합니다. 하지만이 단일 배포 단위인도 들어 가장 중요 업무용 응용 프로그램 혜택을 받을 여러 계층에 일부 논리 분리에서입니다.

## <a name="what-is-a-monolithic-application"></a>단일 응용 프로그램 이란?

단일 응용 프로그램은 완전히 독립적인, 해당 동작 면에서입니다. 해당 작업을 수행 하는 과정에서 다른 서비스 또는 데이터 저장소와 상호 작용할 수도 있고 해당 동작의 코어에서 자체 프로세스로 실행 전체 응용 프로그램은 일반적으로 하나의 단위로 배포 합니다. 일반적으로 이러한 응용 프로그램을 수평으로 확장 하는 경우 전체 응용 프로그램이 여러 서버 또는 가상 컴퓨터에서 중복 됩니다.

## <a name="all-in-one-applications"></a>내부에서 올인원 응용 프로그램

응용 프로그램 아키텍처에 대 한 프로젝트의 수를 최소로 하나입니다. 이 아키텍처에서 응용 프로그램의 전체 로직이 단일 프로젝트에 포함 된 단일 어셈블리로 컴파일된 있고, 단일 단위로 배포 합니다.

새 ASP.NET Core 프로젝트 명령줄 또는 Visual Studio에서 만든 시작 간단한 "내부에서 올인원" monolith 합니다. 프레젠테이션, 비즈니스 및 데이터 액세스 논리를 포함 하 여 응용 프로그램의 동작을 모두 포함 됩니다. 그림 5-1 단일 프로젝트 응용 프로그램의 파일 구조를 보여 줍니다.

**그림 5-1입니다.** 단일 프로젝트 ASP.NET Core 응용 프로그램

![](./media/image5-1.png)

단일 프로젝트 시나리오에서 분리 하는 폴더를 사용 하 여 수행 됩니다. 기본 서식 파일에 데이터 및 서비스에 대 한 모델, 뷰 및 컨트롤러의 MVC 패턴 책임에 대 한 별도 폴더와 폴더를 추가로 포함 됩니다. 이 정렬에서 프레젠테이션 세부 정보를 Views 폴더에 가능한 한 제한 된 및 데이터 액세스에 대 한 구현 세부 정보는 Data 폴더에 보관 하는 클래스를 제한 해야 합니다. 비즈니스 논리는 서비스와 모델 폴더 내에서 클래스에 있어야 합니다.

간단 하지만 단일 프로젝트 모놀리식 솔루션에 몇 가지 단점이 있습니다. 프로젝트의 크기와 복잡성 증가, 파일 및 폴더의 수가 함께 증가 계속 됩니다. UI 문제 (모델, 뷰, 컨트롤러), 그룹화 되지 않은 함께 사전순으로 여러 폴더에 있어야 합니다. 이 문제 ModelBinders, 필터 등의 추가 UI 수준 구문 자신의 폴더에 추가 될 때만 나쁜를 가져옵니다. 비즈니스 논리 모델 및 서비스 폴더 간의 분산 하 고 있는 폴더의 클래스는 다른 사용자에 의존 해야 합니다는 명확한 표시가 없습니다. 이 처럼 프로젝트 수준에서 조직의 경우가 많으므로 [코드](http://deviq.com/spaghetti-code/)합니다.

이러한 문제를 해결 하려면 응용 프로그램이 종종 발전 하면서 각 프로젝트 특정에 있는 것으로 간주 되는 다중 프로젝트 솔루션으로 *레이어* 응용 프로그램의 합니다.

## <a name="what-are-layers"></a>계층은 무엇입니까?

응용 프로그램 복잡성에서 성장 함에 따라 해당 복잡성을 관리 하기 가지 방법은 해당 책임이 나 문제에 따라 응용 프로그램을 나눌 수입니다. 문제 원칙을 분리 하 여 따르며 개발자가 특정 기능을 구현 하는 쉽게 찾을 수 있도록 구성 증가 코드 베이스를 유지할 수 있습니다. 계층화 아키텍처는 하지만 여러 가지 장점이 방금 코드 조직 외을 제공합니다.

코드를 계층으로 구성 하 여 응용 프로그램에 걸쳐 공통 하위 수준 기능을 재사용할 수 있습니다. 더 적은 코드를 작성할 필요가 것을 의미 하 고 건조 원칙을 한 번만 구현을 표준화 하기 위해 응용 프로그램을 허용할 수 있기 때문이 다시 사용 하는 것이 좋습니다.

계층화 된 아키텍처와 응용 프로그램에 레이어 다른 레이어가와 통신할 수 제한을 적용할 수 있습니다. 이렇게 하면 캡슐화를 달성 합니다. 레이어를 변경 하거나 대체 하는 경우에 함께 작동 하는 계층에만 영향을 해야 합니다. 제한 하 여 계층에 다른 계층 변경의 영향을 최소화할 수 있습니다 단일 변경 전체 응용 프로그램에 영향을 주지 않도록 따라 달라 집니다.

레이어 (및 캡슐화) 보다 쉽게 응용 프로그램 내에서 기능을 대체 합니다. 예를 들어 응용 프로그램 지 속성에 대 한 자체 SQL Server 데이터베이스 사용 처음 되지만 나중에 클라우드 기반 지 속성 전략 또는 web API 뒤에 있는 하나를 사용 하도록 선택할 수 있습니다. 응용 프로그램에 논리적 계층 내에서 해당 지 속성 구현을 캡슐화 제대로 하는 경우 해당 SQL Server 특정 계층을 동일한 공용 인터페이스를 구현 하 여 새 변환기도 대체할 수 있습니다.

구현 향후 요구 사항 변화에 대 한 응답에서을 바꾸는 가능성이 외에도 응용 프로그램 계층도 쉽게 만들 수 구현을 테스트 목적으로 교체 합니다. 실제 데이터 계층 또는 응용 프로그램의 UI 계층에 대해 작동 하는 테스트를 작성 하는 대신 요청에 대 한 알려진된 응답을 제공 하는 가짜 구현으로 이러한 계층 테스트 시 바꿀 수 있습니다. 이 일반적으로 인해 테스트 훨씬 쉽게 작성 하 고 훨씬 빠르게 테스트 다시 실행에 비해 실행 응용 프로그램의 실제 인프라입니다.

논리 쌓기 엔터프라이즈 소프트웨어 응용 프로그램에서 코드를 향상 시키기 위한 일반적인 방법 이며 여러 가지 방법으로 계층으로 코드를 구성할 수 있는 합니다.

> [!NOTE]
> *레이어* 응용 프로그램 내에서 논리적 분리를 나타냅니다. 응용 프로그램 논리 서버 또는 프로세스를 구분 하려면 물리적으로 배포 된 경우 이러한 별도 실제 배포 대상 이라고 *계층*합니다. 이것은 가능한 경우 단일 계층에 배포 되는 N 계층 응용 프로그램에 매우 일반적입니다.

## <a name="traditional-n-layer-architecture-applications"></a>기존의 "N 레이어" 아키텍처 응용 프로그램

에 응용 프로그램 논리의 가장 일반적인 조직 계층화 그림 5-2에 표시 된 것입니다.

**그림 5-2입니다.** 일반적인 응용 프로그램 계층입니다.

![](./media/image5-2.png)

이들이 레이어는 UI로 축약 BLL (Business Logic Layer) 및 DAL (데이터 액세스 계층). 이 아키텍처를 사용 하 여 사용자만 BLL와 상호 작용 하는 UI 계층을 통해 요청을 확인 합니다. 차례로 BLL, 데이터 액세스 요청에 대 한 DAL를 호출할 수 있습니다. UI 계층 하지 않아야 모든 요청에는 dal과 직접 또는 다른 수단을 통해 직접 지 속성 상호 작용 해야 합니다. 마찬가지로, BLL 상호 작용 해야 지 속성 DAL을 통해 이동 하 여 합니다. 이러한 방식으로 각 계층에는 잘 알려진 책임 있습니다.

하나이 기존의 계층화 접근 방법의 단점은 맨 아래에 컴파일 시간 종속성 위에서 실행입니다. 즉, UI 계층 DAL에 따라 달라 지는 BLL에 따라 달라 집니다. 이 일반적으로 보유 하 고 가장 중요 한 논리는 응용 프로그램에서 BLL 종속 데이터 액세스 구현 세부 정보 (및 자주 데이터베이스의 존재에) 임을 의미 합니다. 이러한 아키텍처에 비즈니스 논리를 테스트는 테스트 데이터베이스 요구 어렵습니다. 다음 섹션에서 확인할 수 종속성 반전 원칙을이 문제를 해결 하기 위해 사용할 수 있습니다.

그림 5-3 책임 (또는 계층)에 의해 세 개의 프로젝트도 응용 프로그램을 분할 하는 예제 솔루션을 보여 줍니다.

**그림 5-3입니다.** 세 가지 프로젝트와 함께 간단한 모놀리식 응용 프로그램입니다.

![](./media/image5-3.png)

이 응용 프로그램에서는 여러 프로젝트 구성을 위한 목적으로 사용 하지만 계속 단일 단위로 배포 및 클라이언트에서 단일 웹 앱으로 상호 작용 합니다. 그러면 매우 간단한 배포 프로세스 수 있습니다. 그림 5-4 이러한 응용 프로그램 수 있습니다는 방법을 보여 줍니다. Windows Azure를 사용 하 여 호스팅됩니다.

![](./media/image5-4.png)

**그림 5-4입니다.** Azure 웹 앱의 간단한 배포

응용 프로그램 요구 사항이 증가, 처럼 더 복잡 하 고 강력한 배포 솔루션 필요할 수 있습니다. 그림 5-5에는 추가 기능을 지 원하는 더 복잡 한 배포 계획의 예가 나와 있습니다.

![](./media/image5-5.png)

**그림 5-5입니다.** Azure 앱 서비스에 웹 응용 프로그램 배포

내부적으로이 프로젝트의이 조직 책임을 기반으로 하는 여러 프로젝트에 응용 프로그램의 유지 관리 용이성 향상 됩니다.

이 단위는 클라우드 기반 주문형으로 확장성 활용 하기 위해 내부 또는 외부 확장할 수 있습니다. 수직 확장 응용 프로그램을 호스팅하는 서버에 추가 CPU, 메모리, 디스크 공간 부족 또는 기타 리소스를 추가 하는 것을 의미 합니다. 스케일 아웃는 이러한 서버의 추가 인스턴스 추가 여부를 물리적 서버 또는 가상 컴퓨터. 응용 프로그램은 여러 인스턴스에서 호스트 되는 경우 부하 분산 장치는 개별 응용 프로그램 인스턴스에 요청을 할당 하는 데 사용 됩니다.

Azure의 웹 응용 프로그램을 확장 하는 가장 간단한 방법은 응용 프로그램의 앱 서비스 계획에서 수동으로 크기 조정을 구성 하는 것입니다. 그림 5-6 인스턴스 개수를 서비스 응용 프로그램을 구성 하려면 적절 한 Azure 대시보드 화면을 표시 합니다.

![](./media/image5-6.png)

**그림 5-6입니다.** 앱 서비스 계획 Azure에서 크기 조정 합니다.

## <a name="clean-architecture"></a>클린 아키텍처

Domain-Driven 디자인 (DDD) 원칙 뿐만 아니라 종속성 반전 원칙에 따라 응용 프로그램에서 비슷한 아키텍처 도착 하는 경향이 있습니다. 이 아키텍처 수 년에 걸쳐 많은 이름으로 떨어졌습니다. 첫 번째 이름 중 하나는 6 각형 아키텍처, 포트 및 어댑터 옵니다. 으로 인용 된 최근는 [양 파형 아키텍처](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) 또는 [클린 아키텍처](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)합니다. 이 마지막 이름 기준으로이 전자책 (영문)의 아키텍처를 설명 하는 데 사용 되는 정리 아키텍처입니다.

> [!NOTE]
> 용어 클린 아키텍처 DDD를 사용 하 여 빌드되지 않은 하는 것에 대 한도 DDD 원칙을 사용 하 여 빌드된 응용 프로그램에 적용할 수 있습니다. 전자의 경우의 경우이 조합은로 참조할 수 있습니다 "클린 DDD 아키텍처"으로 합니다.

클린 아키텍처 응용 프로그램의 가운데에 비즈니스 논리 및 응용 프로그램 모델을 전환합니다. 이 종속성 데이터 액세스 또는 기타 인프라 고려 사항에 의존 하는 비즈니스 논리를 대신 반전: 응용 프로그램 코어에 인프라 및 구현 세부 사항에 따라 달라 집니다. 이 다음 인프라 계층에 정의 된 형식에 의해 구현 되는 응용 프로그램 핵심에서 추상화를 또는 인터페이스를 정의 하 여 달성 됩니다. 이 아키텍처를 시각화 하는 일반적인 방법은 일련의 동심원는 양 파형 비슷합니다를 사용 하는 것입니다. 그림 5-X 아키텍처 표현의이 스타일의 예를 보여 줍니다.

![](./media/image5-7.png)

**그림 5-7입니다.** 아키텍처를 정리 합니다. 양 파형 보기

이 다이어그램에 종속성 가장 안쪽 원의 향해 흐릅니다. 따라서 (함이 다이어그램의 핵심 위치에서 해당 이름을 가진) 응용 프로그램 코어에 종속성이 없는 다른 응용 프로그램 계층에 있는지 확인할 수 있습니다. 매우 가운데에는 응용 프로그램의 엔터티 및 인터페이스입니다. 바로 바깥쪽 이지만 아직 응용 프로그램 코어에에서는 일반적으로 내부 원에 정의 된 인터페이스를 구현 하는 도메인 서비스입니다. 외부의 응용 프로그램 핵심 사용자 인터페이스 및 인프라 계층 모두 종속에 응용 프로그램 코어만 서로 (반드시).

그림 5-X UI 및 기타 계층 간에 종속성을 더 잘 반영 하는 보다 일반적인 가로 레이어 다이어그램을 보여 줍니다.

![](./media/image5-8.png)

**그림 5-8입니다.** 아키텍처를 정리 합니다. 가로 계층 보기

참고는 실선으로 된 화살표는 나타내고 컴파일 시간 종속성 파선된 화살표는 런타임 전용 종속성을 나타냅니다. 정리 아키텍처를 사용 하 여 UI 계층으로 컴파일 타임에 응용 프로그램 코어에 정의 된 인터페이스를 이상적 해야가 구현 형식에 대 한 지식에에서 정의 되어 있지 인프라 계층. 하지만 런타임 시, 이러한 구현 형식이 됩니다 응용 프로그램을 실행 하는 데 필요한 때문 있어야 하 고 종속성 주입을 통해 응용 프로그램 코어 인터페이스까지 유선 해야 합니다.

그림 5-9에서는 이러한 권장 사항을 따르면 빌드할 때 ASP.NET Core 응용 프로그램의 아키텍처를 보다 자세하게 표시를 보여 줍니다.

![ASPNET 핵심 아키텍처](./media/image5-9.png)

**그림 5-9입니다.** ASP.NET Core 아키텍처 다이어그램 아키텍처 정리를 수행 합니다.

응용 프로그램 핵심 인프라에 의존 하지, 때문에이 계층에 대 한 자동화 된 단위 테스트를 작성 하려면 매우 쉽습니다. 그림 5-10 및 11 5 테스트가이 아키텍처에 맞추는 방법을 보여 줍니다.

![UnitTestCore](./media/image5-10.png)

**그림 5-10입니다.** 에서 단위 테스트를 응용 프로그램 코어 격리 합니다.

![IntegrationTests](./media/image5-11.png)

**그림 5-11입니다.** 통합 인프라 구현 외부 종속성이 테스트 합니다.

UI 계층 직접 종속성 인프라 프로젝트에 정의 된 형식에 대 한를 매우 쉽게 구현을을 쉽게 테스트할 하나 걸러 내 거 나 응용 프로그램 요구 사항의 변화에 대 한 응답에도 마찬가지로 합니다. ASP.NET Core의 기본 제공 사용 및 종속성 주입에 대 한 지원 구조 특수 모놀리식 응용 프로그램에 가장 적합 한 방식으로이 아키텍처를 사용 하면 합니다.

단일 응용 프로그램에 대 한 응용 프로그램 코어, 인프라 및 사용자 인터페이스 프로젝트는 모든 실행 단일 응용 프로그램으로. 런타임 응용 프로그램 아키텍처 그림 5-12와 같은 문제가 나타날 수 있습니다.

![ASPNET 핵심 아키텍처 2](./media/image5-12.png)

**그림 5-12입니다.** 샘플 ASP.NET Core 응용 프로그램의 런타임 아키텍처입니다.

### <a name="organizing-code-in-clean-architecture"></a>코드 새로 아키텍처의 구성

클린 아키텍처 솔루션에서는 각 프로젝트는 명확한 책임이 있습니다. 따라서 각 프로젝트에 속하는 특정 형식 및 자주 적절 한 프로젝트에서 이러한 형식에 해당 폴더를 찾을 수 있습니다.

응용 프로그램 코어 엔터티, 서비스 및 인터페이스를 포함 하는 비즈니스 모델을 보유 합니다. 이러한 인터페이스는 데이터 액세스, 파일 시스템 액세스, 네트워크 호출 등의 인프라를 사용 하 여 수행 되는 작업에 대 한 추상화를 포함 합니다. 경우에 따라 서비스 또는이 계층에 정의 된 인터페이스 UI 또는 인프라에 없는 종속 되어 있는 비 엔터티 형식에서 실행 되도록 할 수 있습니다. 이러한 간단한 데이터 전송 개체 (Dto)로 정의할 수 있습니다.

> ### <a name="application-core-types"></a>응용 프로그램 코어 유형
> -   (비즈니스 모델 클래스 유지 되는) 엔터티
> -   인터페이스
> -   서비스
> -   Dto

인프라 프로젝트에는 데이터 액세스 구현 일반적으로 포함 됩니다. 일반적인 ASP.NET Core 웹 응용 프로그램을이 엔터티 프레임 워크 DbContext, 정의 된 모든 EF 코어 마이그레이션 및 데이터 액세스 구현 클래스 포함 됩니다. 사용 하 여 데이터 액세스 구현 코드를 추상화 하는 가장 일반적인 방법은는 [저장소 디자인 패턴](http://deviq.com/repository-pattern/)합니다.

데이터 액세스 구현 외에도 인프라 프로젝트 인프라 문제가 상호 작용 해야 하는 서비스의 구현을 포함 되어야 합니다. 이러한 서비스 응용 프로그램 필수 요소에 정의 된 인터페이스를 구현 해야 하 이며 따라서 인프라 Application Core 프로젝트에 대 한 참조가 있어야 합니다.

> ### <a name="infrastructure-types"></a>인프라 유형
> -   EF 코어 유형 (DbContext, 마이그레이션)
> -   데이터 액세스 구현 형식 (리포지토리)
> -   인프라 관련 서비스 (FileLogger, SmtpNotifier 등)

ASP.NET Core MVC 응용 프로그램에서 사용자 인터페이스 계층을 응용 프로그램에 대 한 진입점 되며 ASP.NET Core MVC 프로젝트 됩니다. 이 프로젝트는 응용 프로그램 코어 프로젝트를 참조 해야 하 고 인프라 코어 응용 프로그램에에서 정의 된 인터페이스를 통해 엄격 하 게 상호 작용 하는 자체의 형식입니다. 없음의 직접 인스턴스화 (또는에 대 한 정적 호출) UI 계층의 인프라 계층 유형을 허용 해야 합니다.

> ### <a name="ui-layer-types"></a>UI 레이어 형식
> -   컨트롤러
> -   필터
> -   보기
> -   Viewmodel
> -   시작

시작 클래스는 응용 프로그램을 구성 하는 것에 대 한 마우스 구현 형식 연결은 대 한 인터페이스를 런타임 시 제대로 작동 하려면 종속성 주입을 허용 하 합니다.

> [!NOTE]
> UI 프로젝트의 ConfigureServices Startup.cs 파일에서의 종속성 주입을 연결 하기 위해 인프라 프로젝트 참조 프로젝트 해야 합니다. 가장 쉽게 사용자 지정 DI 컨테이너를 사용 하 여이 종속성은 제거 될 수 있습니다. 이 샘플에서는 UI 프로젝트 인프라 프로젝트 참조를 허용 하는 가장 간단한 방법이입니다.

## <a name="monolithic-applications-and-containers"></a>단일 응용 프로그램 및 컨테이너 

단일 및 모놀리식 배포 기반된 웹 응용 프로그램 또는 서비스 빌드하고 컨테이너로 배포할 수 있습니다. 응용 프로그램 내에서 모놀리식 하지만 구성 된 여러 라이브러리, 구성 요소 또는 계층에는 수 있습니다. 외부에서 단일 프로세스, 단일 웹 응용 프로그램 또는 단일 서비스와 같은 단일의 컨테이너입니다.

이 모델을 관리 하려면 응용 프로그램을 나타내는 단일 컨테이너를 배포 합니다. 을 크기 조정 하려면 앞에 부하 분산 장치 추가 복사본이 추가 됩니다. 간단 하 게 단일 컨테이너 또는 VM에 단일 배포를 관리에서 제공 됩니다.

![](./media/image5-13.png)

그림 5-X와 같이 여러 구성 요소/라이브러리 또는 각 컨테이너 내에서 내부 레이어를 포함할 수 있습니다. 그러나의 컨테이너 주체를 따라 *"컨테이너는 하나의 작업을 수행 하며 하나의 프로세스에는*", 모놀리식 패턴 충돌이 발생할 수 있습니다.

이 방법의 단점은/응용 프로그램 증가 확장할 필요 하면 제공 됩니다. 전체 응용 프로그램의 배율 조정 없는 경우 실제로 문제가 있습니다. 그러나 대부분의 경우에서 응용 프로그램의 몇 가지 파트는 다른 구성 요소는 크기 조정 요구 좁게 포인트를 사용 하 작은입니다.

일반적인 전자 상거래 예제;를 사용 하 여 가능성이 필요한 크기를 조정 하는 제품 정보 구성 요소입니다. 보다 많은 고객 구입 보다 제품을 찾습니다. 더 많은 고객 결제 파이프라인을 사용 하는 보다 자신의 바구니를 사용 합니다. 더 적은 수의 고객 주석을 추가 하거나 자신의 구매 기록을 봅니다. 있고 가능성이는 소수의 콘텐츠 및 마케팅 캠페인을 관리 해야 하는 단일 지역에서 직원입니다. 모놀리식 디자인을 조정 하 여 모든 코드가 여러 번 배포 됩니다.

눈금 외에도 모든 문제를 단일 구성 요소에 대 한 변경 필요는 전체 응용 프로그램 및 모든 인스턴스의 전체 배포 시의 전체 다시 테스트 합니다.

일반적으로 모놀리식 접근 방식 및 대부분의 조직에서는이 아키텍처 접근 방법을 사용 하 여 개발 합니다. 많은 발생 양호 충분 한 결과 다른 제한 도달 하는 동안. 여러 도구 및 인프라 서비스 지향 아키텍처 soa (권한)을 작성 하기 너무 어렵습니다 되 고 응용 프로그램 증가 될 때까지 필요-표시 하지 않은 때문에이 모델에서 응용 프로그램의 설계 되었습니다. 모놀리식 접근 방법의 제한에 도달 하는 경우 컨테이너와 microservices 더 잘 활용할 수 있도록 앱을 분할 해 다음 논리 단계 수 있습니다.

![](./media/image5-14.png)

Microsoft Azure에서 단일 응용 프로그램 배포 각 인스턴스에 대 한 전용된 Vm을 사용 하 여 구현할 수 있습니다. 사용 하 여 [Azure VM 크기 집합이](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), Vm을 쉽게 확장할 수 있습니다. [Azure 앱 서비스](https://azure.microsoft.com/services/app-service/) 모놀리식 응용 프로그램을 실행 하 고 Vm을 관리 하지 않고도 인스턴스를 쉽게 확장할 수 있습니다. Azure 앱 서비스 배포를 단순화 뿐, Docker 컨테이너의 단일 인스턴스를 실행할 수 있습니다. Docker를 사용 하는 Docker 호스트에 단일 VM을 배포 하 고 여러 인스턴스를 실행할 수 있습니다. 그림 5-14에 표시 된 것 처럼 Azure 분산 장치를 사용 하 여, 크기 조정을 관리할 수 있습니다.

일반적인 배포 방법으로 다양 한 호스트에 배포를 관리할 수 있습니다. 와 같은 명령을 사용 하 여 Docker 호스트를 관리 **docker 실행** 지속적인 배달 (CD) 파이프라인 등을 수동으로 또는 자동화를 통해 수행 합니다.

### <a name="monolithic-application-deployed-as-a-container"></a>컨테이너 배포 되는 모놀리식 응용 프로그램

컨테이너를 사용 하 여 단일 응용 프로그램 배포를 관리 하는 이점 있습니다. 컨테이너의 인스턴스를 확장 하는 것은 훨씬 보다 쉽고 빠르게 추가 Vm을 배포 합니다. VM 크기 집합을 사용 하 여 Vm의 크기를 조정를 하는 경우에 하는 데 걸리는 시간 인스턴스. 주 서버 인스턴스 응용 프로그램 인스턴스를 배포할 때 응용 프로그램의 구성은 VM의 일부로 관리 됩니다.

Docker 이미지는 훨씬 더 빠른 업데이트를 배포 하 고 효율적인 네트워크입니다. Docker 이미지 롤아웃 속도 (초) 일반적으로 시작 합니다. Docker 인스턴스를 중지 하는 것은 발급 하는 것 만큼 쉽게는 **docker stop** 명령, 일반적으로 몇 초에서 완료 합니다.

컨테이너를 기본적으로 디자인 하 여 변경할 수 없는 경우 처럼 필요가 있습니다 손상 된 Vm에 대해서는 걱정 반면 디스크에 몇 가지 특정 구성 또는 남아 있는 파일에 대 한 설명 하기 위해 업데이트 스크립트 제거 될 수 있습니다.

구식 응용 프로그램에서 단일 응용 프로그램 배율을 조정할 수 있는 하위 시스템을 손상 시 키 지 Docker 이점을 얻을 수 있습니다 하는 동안 개발 하 고 개별적으로 배포 microservices의 영역에 진입점이 될 수 있습니다.

> ### <a name="references--common-web-architectures"></a>참조 – 일반적인 웹 아키텍처
> - **정리 아키텍처**  
> <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - **양 파형 아키텍처**  
> <http://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - **리포지토리 패턴**  
> <http://deviq.com/repository-pattern/>
> - **클린 아키텍처 솔루션 예제**  
> <https://github.com/ardalis/cleanarchitecture>
> - **Microservices 전자책 설계** <http://aka.ms/MicroservicesEbook>

>[!div class="step-by-step"]
[이전] (아키텍처-principles.md) [다음] (공통-클라이언트-쪽-웹-technologies.md)

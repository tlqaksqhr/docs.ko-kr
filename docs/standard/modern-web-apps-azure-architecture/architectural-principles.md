---
title: "아키텍처 원칙"
description: "ASP.NET Core와 Azure의 최신 웹 응용 프로그램을 설계 | 아키텍처 원칙"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: 20524c8aa0e64fd40a1a4a6811063557f74074d2
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
#<a name="architectural-principles"></a><span data-ttu-id="57eac-103">아키텍처 원칙</span><span class="sxs-lookup"><span data-stu-id="57eac-103">Architectural Principles</span></span>

> <span data-ttu-id="57eac-104">"빌더 건물 빌드된 경우 방법은 프로그래머가 프로그램을 작성 했습니다. 다음와 함께 제공 된 첫 번째 woodpecker 문명이 손상 됩니다."</span><span class="sxs-lookup"><span data-stu-id="57eac-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="57eac-105">_\-Gerald Weinberg_</span><span class="sxs-lookup"><span data-stu-id="57eac-105">_\- Gerald Weinberg_</span></span>

## <a name="summary"></a><span data-ttu-id="57eac-106">요약</span><span class="sxs-lookup"><span data-stu-id="57eac-106">Summary</span></span>

<span data-ttu-id="57eac-107">설계 하 고 염두에서 유지 관리와 소프트웨어 솔루션을 디자인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-107">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="57eac-108">이 섹션에서 설명 하는 원칙 잘 정리 되 고 유지 가능한 응용 프로그램에서 발생 시키는 아키텍처 결정을 향해 안내해 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-108">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="57eac-109">일반적으로 이러한 원칙은 안내 메시징 시스템 또는 응용 프로그램의 다른 부분에 긴밀히 연결 되어 있지 않지만 대신 명시적 인터페이스를 통해 통신 하는 개별 구성 요소에서 응용 프로그램을 구축 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-109">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="57eac-110">일반적인 디자인 원칙</span><span class="sxs-lookup"><span data-stu-id="57eac-110">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="57eac-111">문제의 분리</span><span class="sxs-lookup"><span data-stu-id="57eac-111">Separation of Concerns</span></span>

<span data-ttu-id="57eac-112">개발 하는 경우 기본 원칙은 **Separation**합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-112">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="57eac-113">이 원칙은 어설션 소프트웨어를 구분 하도록 수행 된 작업의 종류에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-113">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="57eac-114">예를 들어 응용 프로그램에서 사용자에 게 표시할 주목할 만한 항목을 식별 하기 위한 논리를 포함 하 고 더욱 분명 하 게 되도록 특정 방식에서 등의 항목 형식을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-114">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="57eac-115">동작의 서식을 지정 하려면 어떤 항목이 선택에 대 한 책임만 동시 서로 관련 된 문제를 분리 하므로 이러한 항목을 서식 지정에 대 한 책임 동작와에서 별도로 유지 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-115">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="57eac-116">아키텍처 측면에서 응용 프로그램 인프라 및 사용자 인터페이스 논리의 핵심 비즈니스 동작을 분리 하 여이 원칙을 따르며를 논리적으로 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-116">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user interface logic.</span></span> <span data-ttu-id="57eac-117">이상적으로 비즈니스 규칙 및 논리는 응용 프로그램의 다른 프로젝트에 종속 되는 별도 프로젝트에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-117">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="57eac-118">이렇게 하면 비즈니스 모델은 쉽게 테스트 하 고 하위 수준 구현 세부 정보를 완벽 하 게 결합 되지 않고 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-118">This helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="57eac-119">분리 하는 응용 프로그램 아키텍처의 계층 사용는 주요 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-119">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="57eac-120">캡슐화</span><span class="sxs-lookup"><span data-stu-id="57eac-120">Encapsulation</span></span>

<span data-ttu-id="57eac-121">응용 프로그램의 다른 부분을 사용할지 **캡슐화** 를 응용 프로그램의 다른 부분에서 분리 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-121">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="57eac-122">응용 프로그램 구성 요소 및 레이어는 외부 계약을 위반 하지 않는 상태로 자신의 공동 작업자를 중단시 키 지 않고도 내부 구현을 조정 할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-122">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="57eac-123">캡슐화의 적절 한 사용 하므로 개체 및 패키지도 동일한 인터페이스 유지 대체 구현으로 바꿀 수 있습니다 느슨한 결합 및 모듈식 방식으로 응용 프로그램 디자인을 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-123">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="57eac-124">클래스 캡슐화를 바깥쪽 클래스의 내부 상태에 대 한 액세스를 제한 하 여 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-124">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="57eac-125">외부 행위자를 개체의 상태를 처리 하려는 경우 개체의 전용 상태에 대 한 직접 액세스는 것이 아니라 잘 정의 된 함수 (또는 속성 setter)를 통해 수행 해야 것입니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-125">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="57eac-126">마찬가지로, 응용 프로그램 구성 요소 및 응용 프로그램 자체의 공동 작업자 상태를 직접 수정할 수로 허용 되지 않고 사용에 대 한 잘 정의 된 인터페이스를 노출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-126">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="57eac-127">으로 공용 계약 유지 관리를 수행 하므로 끊긴다는 공동 작업자 걱정 하지 않고 시간에 따라 진화 하는 응용 프로그램의 내부 디자인을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-127">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="57eac-128">종속성 반전</span><span class="sxs-lookup"><span data-stu-id="57eac-128">Dependency Inversion</span></span>

<span data-ttu-id="57eac-129">응용 프로그램 내에서 종속성 방향 세부 정보를 구현 하지 추상화의 방향에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-129">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="57eac-130">대부분의 응용 프로그램의 런타임 실행 방향 흐름에서는 컴파일 시간 종속성 되도록 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-130">Most applications are written such that compile-time dependency flows in the direction of runtime execution.</span></span> <span data-ttu-id="57eac-131">이 직접 종속성 그래프를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-131">This produces a direct dependency graph.</span></span> <span data-ttu-id="57eac-132">즉, C, 모듈에서 다음 컴파일 타임 A에서 함수를 호출 하는 함수 B 모듈에서 모듈 A 호출이 그림 4-1에 나와 있는 것 처럼 C에 따라 달라 집니다 B에 종속 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="57eac-132">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B which will depend on C, as shown in Figure 4-1.</span></span>

![](./media/image4-1.png)

<span data-ttu-id="57eac-133">**그림 4-1입니다.**</span><span class="sxs-lookup"><span data-stu-id="57eac-133">**Figure 4-1.**</span></span> <span data-ttu-id="57eac-134">직접 종속성 그래프입니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-134">Direct dependency graph.</span></span>

<span data-ttu-id="57eac-135">메서드를 호출할 수 있도록 A에 대 한 런타임 시 호출 B B에서 구현 하는 추상화에 A를 허용 하지만 인터페이스에 따라 달라 지도록 B에 의해 제어는 컴파일 타임에 종속성 반전 원칙 적용 (따라서 *반전* 일반적인 컴파일 시간 종속성)입니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-135">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="57eac-136">런타임 시 프로그램 실행의 흐름을 그대로 유지 인터페이스 소개 의미 이러한 인터페이스의 다른 구현을 쉽게 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-136">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![](./media/image4-2.png)

<span data-ttu-id="57eac-137">**그림 4-2입니다.**</span><span class="sxs-lookup"><span data-stu-id="57eac-137">**Figure 4-2.**</span></span> <span data-ttu-id="57eac-138">반전 된 종속성 그래프입니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-138">Inverted dependency graph.</span></span>

<span data-ttu-id="57eac-139">**종속성 반전** 의 구현 세부 사항에 따라 다르며 구현 방식은 그 보다는 상위 수준의 추상화에 쓸 수 있으므로 느슨하게 결합 된 응용 프로그램을 빌드할 때 핵심 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-139">**Dependency inversion** is a key part of building loosely-coupled applications, since implementation details can be written to depend on and implement higher level abstractions, rather than the other way around.</span></span> <span data-ttu-id="57eac-140">결과 응용 프로그램은 결과적으로 더 테스트할 수, 모듈식 및 유지 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-140">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="57eac-141">연습 *종속성 주입* 종속성 반전 원칙에 따라 가능한 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-141">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="57eac-142">명시적 종속 관계</span><span class="sxs-lookup"><span data-stu-id="57eac-142">Explicit Dependencies</span></span>

<span data-ttu-id="57eac-143">**메서드 및 클래스 올바르게 작동 하는 데 필요한 모든 공동 개체를 명시적으로 요구 해야 합니다.**</span><span class="sxs-lookup"><span data-stu-id="57eac-143">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="57eac-144">클래스 생성자는 유효한 상태에 있으려면와 제대로 작동 하는 데 필요한 작업을 식별 하는 클래스에 대 한 기회를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-144">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="57eac-145">이러한 클래스는 되 고 있는 제대로 동작 특정 전역 또는 인프라 구성 요소가 충족 되는지는 생성 된 나누고를 호출할 수 있는 클래스를 정의 하는 경우 *악의적인* 해당 클라이언트와 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-145">If you define classes that can be constructed and called, but which will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="57eac-146">생성자 계약 이지만 다음 개체 사실은 런타임에 (가능한 경우 아무 것도 클래스는 기본 생성자를 사용 하 여 방금), 지정 된 것만 하면 되는 클라이언트 게이트웨이가 필요한 다른 지정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-146">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a default constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="57eac-147">명시적 종속 관계 원칙을 따르면 클래스와 메서드가 작동 하는 데 필요한 수준에 대 한 고객에 게 되는 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-147">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="57eac-148">이렇게 하면 코드를 더 많은 자동 문서화 및 하는 방법의 형태로 요구 하는 제공으로 신뢰 되는 이후 보다 사용자 친화적인 계약 여 코딩 또는 생성자 매개 변수를 사용 하 고 개체가 작동 하는 올바르게 런타임에 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-148">This makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at runtime.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="57eac-149">단일 책임</span><span class="sxs-lookup"><span data-stu-id="57eac-149">Single Responsibility</span></span>

<span data-ttu-id="57eac-150">단일 책임 원칙 개체 지향 디자인에 적용 되지만 비슷한 분리 하는 아키텍처 원칙으로 간주할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-150">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="57eac-151">대화 상자가 표시 개체 하나만 책임에 있어야 하 고 변경할 이유가 하나만 가져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-151">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="57eac-152">특히 개체 변경 해야 하는 경우에만 한 책임을 실행 하는 방식으로 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-152">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="57eac-153">이 원칙은 더 생성 하는 데 도움이 느슨하게 결합 된 및 모듈식 시스템 다양 한 종류의 새로운 동작은 이후 구현 될 수 있습니다 추가 해야 기존 클래스를 추가 하는 대신 새 클래스로 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-153">Following this principle helps to produce more loosely-coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="57eac-154">새 클래스 추가 항상 코드가 없는 이후 기존 클래스를 변경 하는 보다 더 안전 하 게 아직 새 클래스에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-154">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="57eac-155">모놀리식 응용 프로그램에서 응용 프로그램의 계층을 높은 수준에서 단일 책임 원칙을 적용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-155">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="57eac-156">프레젠테이션 책임 UI 프로젝트에 유지 해야, 데이터 액세스 동안 책임 인프라 프로젝트 내에서 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-156">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="57eac-157">비즈니스 논리를 쉽게 테스트할 수 고 다른 책임에서 독립적으로 개발할 수 있는 응용 프로그램 core 프로젝트에 유지 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-157">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="57eac-158">이 원칙은 응용 프로그램 아키텍처에 적용 하 고 논리적 끝점에 해당 하는 데 걸리는 microservices를 얻게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-158">When this principle is applied to application architecture, and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="57eac-159">지정 된 마이크로 서비스를 단일 책임이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-159">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="57eac-160">시스템의 동작을 확장 해야 할 경우 기존 작업을 추가 하는 대신 추가 microservices를 추가 하 여 작업을 수행할 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-160">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="57eac-161">Microservices 아키텍처에 대 한 자세한 정보</span><span class="sxs-lookup"><span data-stu-id="57eac-161">Learn more about microservices architecture</span></span>](http://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="57eac-162">(건조) 직접 반복 안 함</span><span class="sxs-lookup"><span data-stu-id="57eac-162">Don't Repeat Yourself (DRY)</span></span>

<span data-ttu-id="57eac-163">응용 프로그램 오류의 자주 소스 이것은 여러 위치에서 특정 개념이 관련 된 동작을 지정 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-163">The application should avoid specifying behavior related to a particular concept in multiple places as this is a frequent source of errors.</span></span> <span data-ttu-id="57eac-164">어느 시점 부터는 요구 사항에 대 한 변경 내용이 가능성 및이 동작을 변경 해야 합니다 해당 동작의 인스턴스를 하나 이상 업데이트 되지 것입니다는 시스템의 일관 되지 않은 동작이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-164">At some point, a change in requirements will require changing this behavior and the likelihood that at least one instance of the behavior will fail to be updated will result in inconsistent behavior of the system.</span></span>

<span data-ttu-id="57eac-165">논리를 복제 하는 대신 프로그래밍 구문에 캡슐화 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-165">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="57eac-166">이 동작을 통해 단일 기관을 생성 하 고 새 구문을이 동작으로 사용 해야 하는 응용 프로그램의 다른 부분에는이 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-166">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="57eac-167">바인딩 함께 동시 반복 되는 동작 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-167">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="57eac-168">예를 들어 두 개의 서로 다른 상수 모두 동일한 값을 포함 해 서 한다는 의미 하나만 상수 나면 개념적으로 서로 다른 것을 참조 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="57eac-168">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="57eac-169">지 속성 무시</span><span class="sxs-lookup"><span data-stu-id="57eac-169">Persistence Ignorance</span></span>

<span data-ttu-id="57eac-170">**지 속성 무시** (PI) 형식을 참조 유지 해야 하지만 해당 코드를 지 속성 기술 선택 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-170">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="57eac-171">이러한 형식은.net에서은 라고도 일반 이전 CLR 개체 (POCOs)는 특정 기본 클래스에서 상속 하거나 특정 인터페이스를 구현 하는 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-171">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="57eac-172">지 속성 무시 동일한 비즈니스 모델 응용 프로그램에 대 한 추가적인 유연성을 제공 하는 여러 가지 방법으로 유지 될 수 있기 때문에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-172">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="57eac-173">지 속성 선택 항목을 다른 한 데이터베이스 기술에서 시간이 지남에 따라 변경 될 수 있습니다 또는 추가적인 지 속성 형식의와 관계 없이 응용 프로그램이 시작 하는 것 외에도 해야 할 수 있습니다 (예를 들어 Redis 캐시 또는 외에 Azure DocumentDb를 사용 하는 관계형 데이터베이스)입니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-173">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure DocumentDb in addition to a relational database).</span></span>

<span data-ttu-id="57eac-174">이 원칙을 위반의 몇 가지 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-174">Some examples of violations of this principle include:</span></span>

-   <span data-ttu-id="57eac-175">필수 기본 클래스</span><span class="sxs-lookup"><span data-stu-id="57eac-175">A required base class</span></span>

-   <span data-ttu-id="57eac-176">필요한 인터페이스 구현</span><span class="sxs-lookup"><span data-stu-id="57eac-176">A required interface implementation</span></span>

-   <span data-ttu-id="57eac-177">자체 (예: 활성 레코드 패턴)를 저장 해야 하는 클래스</span><span class="sxs-lookup"><span data-stu-id="57eac-177">Classes responsible for saving themselves (such as the Active Record pattern)</span></span>

-   <span data-ttu-id="57eac-178">필수 기본 생성자</span><span class="sxs-lookup"><span data-stu-id="57eac-178">Required default constructor</span></span>

-   <span data-ttu-id="57eac-179">Virtual 키워드를 요구 하는 속성</span><span class="sxs-lookup"><span data-stu-id="57eac-179">Properties requiring virtual keyword</span></span>

-   <span data-ttu-id="57eac-180">지 속성 관련 필수 특성</span><span class="sxs-lookup"><span data-stu-id="57eac-180">Persistence-specific required attributes</span></span>

<span data-ttu-id="57eac-181">클래스 위의 기능이 나 동작 중 하나일 요구 사항을 유지 되어야 하는 형식과 지 속성 기술, 나중에 새 데이터 액세스 전략을 채택 하는 것이 어려울 선택 간의 결합을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-181">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="57eac-182">Bounded 컨텍스트</span><span class="sxs-lookup"><span data-stu-id="57eac-182">Bounded Contexts</span></span>

<span data-ttu-id="57eac-183">**컨텍스트 제한** Domain-Driven 디자인에서 중앙 패턴 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-183">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="57eac-184">별도 개념적 모듈로 분할 하 여 대규모 응용 프로그램 또는 조직에 복잡성이 수행 하는 작업량과 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-184">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="57eac-185">각 개념적 모듈 다음는 다른 컨텍스트에서 분리 되는 컨텍스트를 나타냅니다 (따라서 경계)와 독립적으로 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-185">Each conceptual module then represents a context which is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="57eac-186">각 경계 컨텍스트 내부에 개념에 대 한 고유 이름을 선택할 가능 해야 합니다. 및 지 속성 저장소에 대 한 단독 액세스 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-186">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="57eac-187">여기에 최소한 개별 웹 응용 프로그램 데이터베이스를 다른 응용 프로그램과 공유 하지 않고 자신의 비즈니스 모델에 대 한 자신의 지 속성 저장소와 함께 자체 bounded 컨텍스트 위해 노력 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-187">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="57eac-188">공유 데이터베이스에 대 한 비즈니스 논리를 메뉴를 사용 하는 대신 프로그래밍 방식 인터페이스를 통해 바인딩된 컨텍스트 간 통신에서 발생 하 고 수행 하는 이벤트를 발생 하는 변경 사항에 따라 배치 키를 누릅니다.</span><span class="sxs-lookup"><span data-stu-id="57eac-188">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="57eac-189">컨텍스트 맵도 자신의 개별 bounded 컨텍스트도 구현 이상적으로 microservices에 밀접 하 게 제한.</span><span class="sxs-lookup"><span data-stu-id="57eac-189">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

> ### <a name="references--modern-web-applications"></a><span data-ttu-id="57eac-190">참조-최신 웹 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="57eac-190">References – Modern Web Applications</span></span>
> - <span data-ttu-id="57eac-191">**문제의 분리**</span><span class="sxs-lookup"><span data-stu-id="57eac-191">**Separation of Concerns**</span></span>  
> <span data-ttu-id="57eac-192"><http://deviq.com/separation-of-concerns/></span><span class="sxs-lookup"><span data-stu-id="57eac-192"><http://deviq.com/separation-of-concerns/></span></span>
> - <span data-ttu-id="57eac-193">**캡슐화** <http://deviq.com/encapsulation/></span><span class="sxs-lookup"><span data-stu-id="57eac-193">**Encapsulation** <http://deviq.com/encapsulation/></span></span>
> - <span data-ttu-id="57eac-194">**종속성 반전 원칙**</span><span class="sxs-lookup"><span data-stu-id="57eac-194">**Dependency Inversion Principle**</span></span>  
> <span data-ttu-id="57eac-195"><http://deviq.com/dependency-inversion-principle/></span><span class="sxs-lookup"><span data-stu-id="57eac-195"><http://deviq.com/dependency-inversion-principle/></span></span>
> - <span data-ttu-id="57eac-196">**명시적 종속 관계 원칙**</span><span class="sxs-lookup"><span data-stu-id="57eac-196">**Explicit Dependencies Principle**</span></span>  
> <span data-ttu-id="57eac-197"><http://deviq.com/explicit-dependencies-principle/></span><span class="sxs-lookup"><span data-stu-id="57eac-197"><http://deviq.com/explicit-dependencies-principle/></span></span>
> - <span data-ttu-id="57eac-198">**사용자가 직접 반복 안 함**</span><span class="sxs-lookup"><span data-stu-id="57eac-198">**Don't Repeat Yourself**</span></span>  
> <span data-ttu-id="57eac-199"><http://deviq.com/don-t-repeat-yourself/></span><span class="sxs-lookup"><span data-stu-id="57eac-199"><http://deviq.com/don-t-repeat-yourself/></span></span>
> - <span data-ttu-id="57eac-200">**지 속성 무시**</span><span class="sxs-lookup"><span data-stu-id="57eac-200">**Persistence Ignorance**</span></span>  
> <span data-ttu-id="57eac-201"><http://deviq.com/persistence-ignorance/></span><span class="sxs-lookup"><span data-stu-id="57eac-201"><http://deviq.com/persistence-ignorance/></span></span>
> - <span data-ttu-id="57eac-202">**Bounded 컨텍스트**</span><span class="sxs-lookup"><span data-stu-id="57eac-202">**Bounded Context**</span></span>  
> <span data-ttu-id="57eac-203"><https://martinfowler.com/bliki/BoundedContext.html></span><span class="sxs-lookup"><span data-stu-id="57eac-203"><https://martinfowler.com/bliki/BoundedContext.html></span></span>

> [!div class="step-by-step"]
<span data-ttu-id="57eac-204">[이전] [다음] (공통-웹-응용 프로그램-architectures.md) (choose-between-traditional-web-and-single-page-apps.md)</span><span class="sxs-lookup"><span data-stu-id="57eac-204">[Previous] (choose-between-traditional-web-and-single-page-apps.md) [Next] (common-web-application-architectures.md)</span></span>

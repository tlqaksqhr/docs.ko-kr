---
title: 최선의 이벤트 기반 비동기 패턴 구현 방법
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- Event-based Asynchronous Pattern
- ProgressChangedEventArgs class
- BackgroundWorker component
- events [.NET Framework], asynchronous
- AsyncOperationManager class
- threading [.NET Framework], asynchronous features
- AsyncOperation class
- AsyncCompletedEventArgs class
ms.assetid: 4acd2094-4f46-4eff-9190-92d0d9ff47db
ms.openlocfilehash: eaf410fa198fdb38a39a0474e9e147542919df8e
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
---
# <a name="best-practices-for-implementing-the-event-based-asynchronous-pattern"></a><span data-ttu-id="8bbd1-102">최선의 이벤트 기반 비동기 패턴 구현 방법</span><span class="sxs-lookup"><span data-stu-id="8bbd1-102">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>
<span data-ttu-id="8bbd1-103">이벤트 기반 비동기 패턴은 익숙한 이벤트 및 대리자 의미 체계를 사용하여 클래스에 비동기 동작을 노출하는 효과적인 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-103">The Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics.</span></span> <span data-ttu-id="8bbd1-104">이벤트 기반 비동기 패턴을 구현하려면 몇 가지 구체적인 동작 요구 사항을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-104">To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements.</span></span> <span data-ttu-id="8bbd1-105">다음 섹션에서는 이벤트 기반 비동기 패턴을 따르는 클래스를 구현할 때 고려해야 할 요구 사항 및 지침을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-105">The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.</span></span>  
  
 <span data-ttu-id="8bbd1-106">개요를 보려면 [이벤트 기반 비동기 패턴 구현](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-106">For an overview, see [Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="required-behavioral-guarantees"></a><span data-ttu-id="8bbd1-107">필요한 동작 보장</span><span class="sxs-lookup"><span data-stu-id="8bbd1-107">Required Behavioral Guarantees</span></span>  
 <span data-ttu-id="8bbd1-108">이벤트 기반 비동기 패턴을 구현하는 경우 클래스가 올바르게 동작하고 클래스의 클라이언트가 해당 동작을 사용할 수 있도록 보장하는 다양한 보장을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-108">If you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.</span></span>  
  
### <a name="completion"></a><span data-ttu-id="8bbd1-109">완료</span><span class="sxs-lookup"><span data-stu-id="8bbd1-109">Completion</span></span>  
 <span data-ttu-id="8bbd1-110">성공적인 완료, 오류 또는 취소가 있는 경우 항상 *MethodName***Completed** 이벤트 처리기를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-110">Always invoke the *MethodName***Completed** event handler when you have successful completion, an error, or a cancellation.</span></span> <span data-ttu-id="8bbd1-111">응용 프로그램이 유휴 상태로 유지되고 절대 완료되지 않는 상황이 응용 프로그램에 발생해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-111">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span> <span data-ttu-id="8bbd1-112">이 규칙에 대한 한 가지 예외는 비동기 작업 자체가 절대 완료되지 않도록 디자인된 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-112">One exception to this rule is if the asynchronous operation itself it designed so that it never completes.</span></span>  
  
### <a name="completed-event-and-eventargs"></a><span data-ttu-id="8bbd1-113">완료된 이벤트 및 EventArgs</span><span class="sxs-lookup"><span data-stu-id="8bbd1-113">Completed Event and EventArgs</span></span>  
 <span data-ttu-id="8bbd1-114">별개의 각 *MethodName***Async** 메서드의 경우 다음 디자인 요구 사항을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-114">For each separate *MethodName***Async** method, apply the following design requirements:</span></span>  
  
-   <span data-ttu-id="8bbd1-115">동일한 클래스에서 *MethodName***Completed** 이벤트를 메서드로 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-115">Define a *MethodName***Completed** event on the same class as the method.</span></span>  
  
-   <span data-ttu-id="8bbd1-116"><xref:System.EventArgs> 클래스에서 파생되는 *MethodName***Completed** 이벤트에 대한 <xref:System.ComponentModel.AsyncCompletedEventArgs> 클래스 및 수반하는 대리자를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-116">Define an <xref:System.EventArgs> class and accompanying delegate for the *MethodName***Completed** event that derives from the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span> <span data-ttu-id="8bbd1-117">기본 클래스 이름은 *MethodName***CompletedEventArgs** 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-117">The default class name should be of the form *MethodName***CompletedEventArgs**.</span></span>  
  
-   <span data-ttu-id="8bbd1-118"><xref:System.EventArgs> 클래스가 *MethodName* 메서드의 반환 값에 관련되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-118">Ensure that the <xref:System.EventArgs> class is specific to the return values of the *MethodName* method.</span></span> <span data-ttu-id="8bbd1-119"><xref:System.EventArgs> 클래스를 사용할 경우 개발자가 결과를 캐스팅할 필요가 없도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-119">When you use the <xref:System.EventArgs> class, you should never require developers to cast the result.</span></span>  
  
     <span data-ttu-id="8bbd1-120">다음 코드 예제에서는 각각 이 디자인 요구 사항의 좋은 구현과 나쁜 구현을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-120">The following code example shows good and bad implementation of this design requirement respectively.</span></span>  
  
```csharp  
// Good design  
private void Form1_MethodNameCompleted(object sender, xxxCompletedEventArgs e)   
{   
    DemoType result = e.Result;  
}  
  
// Bad design  
private void Form1_MethodNameCompleted(object sender, MethodNameCompletedEventArgs e)   
{   
    DemoType result = (DemoType)(e.Result);  
}  
```  
  
-   <span data-ttu-id="8bbd1-121"><xref:System.EventArgs>를 반환하는 반환 메서드에 대해 `void` 클래스를 정의하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-121">Do not define an <xref:System.EventArgs> class for returning methods that return `void`.</span></span> <span data-ttu-id="8bbd1-122">대신 <xref:System.ComponentModel.AsyncCompletedEventArgs> 클래스의 인스턴스를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-122">Instead, use an instance of the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span>  
  
-   <span data-ttu-id="8bbd1-123">항상 *MethodName***Completed** 이벤트가 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-123">Ensure that you always raise the *MethodName***Completed** event.</span></span> <span data-ttu-id="8bbd1-124">이 이벤트는 성공적인 완료, 오류 또는 취소 시 발생해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-124">This event should be raised on successful completion, on an error, or on cancellation.</span></span> <span data-ttu-id="8bbd1-125">응용 프로그램이 유휴 상태로 유지되고 절대 완료되지 않는 상황이 응용 프로그램에 발생해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-125">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span>  
  
-   <span data-ttu-id="8bbd1-126">비동기 작업에서 발생하는 모든 예외를 catch하고 catch된 예외를 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 속성에 할당하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-126">Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
-   <span data-ttu-id="8bbd1-127">작업을 완료하는 중에 오류가 발생한 경우 결과에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-127">If there was an error completing the task, the results should not be accessible.</span></span> <span data-ttu-id="8bbd1-128"><xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 속성이 `null`이 아닌 경우 <xref:System.EventArgs> 구조의 모든 속성에 액세스할 때 예외가 발생해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-128">When the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property is not `null`, ensure that accessing any property in the <xref:System.EventArgs> structure raises an exception.</span></span> <span data-ttu-id="8bbd1-129"><xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> 메서드를 사용하여 이 확인을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-129">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method to perform this verification.</span></span>  
  
-   <span data-ttu-id="8bbd1-130">제한 시간 초과를 오류로 모델링합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-130">Model a time out as an error.</span></span> <span data-ttu-id="8bbd1-131">제한 시간 초과가 발생하면 *MethodName***Completed** 이벤트를 발생시키고 <xref:System.TimeoutException>을 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 속성에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-131">When a time out occurs, raise the *MethodName***Completed** event and assign a <xref:System.TimeoutException> to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
-   <span data-ttu-id="8bbd1-132">클래스가 여러 동시 호출을 지원하는 경우 *MethodName***Completed** 이벤트에 `userSuppliedState` 개체가 포함되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-132">If your class supports multiple concurrent invocations, ensure that the *MethodName***Completed** event contains the appropriate `userSuppliedState` object.</span></span>  
  
-   <span data-ttu-id="8bbd1-133">적절한 스레드 및 응용 프로그램 수명 주기의 적절한 시간에 *MethodName***Completed** 이벤트가 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-133">Ensure that the *MethodName***Completed** event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="8bbd1-134">자세한 내용은 스레딩 및 컨텍스트 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-134">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="simultaneously-executing-operations"></a><span data-ttu-id="8bbd1-135">작업 동시 실행</span><span class="sxs-lookup"><span data-stu-id="8bbd1-135">Simultaneously Executing Operations</span></span>  
  
-   <span data-ttu-id="8bbd1-136">클래스가 여러 동시 호출을 지원하는 경우 개발자가 개체 반환 상태 매개 변수 또는 `userSuppliedState`라는 작업 ID를 사용하는 *MethodName***Async** 오버로드를 별도로 정의하여 각 호출을 추적할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-136">If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the *MethodName***Async** overload that takes an object-valued state parameter, or task ID, called `userSuppliedState`.</span></span> <span data-ttu-id="8bbd1-137">이 매개 변수는 항상 *MethodName***Async** 메서드 시그니처의 마지막 매개 변수여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-137">This parameter should always be the last parameter in the *MethodName***Async** method's signature.</span></span>  
  
-   <span data-ttu-id="8bbd1-138">클래스가 개체 반환 상태 매개 변수 또는 작업 ID를 사용하는 *MethodName***Async** 오버로드를 정의하는 경우 해당 작업 ID로 작업의 수명을 추적해야 하며, 해당 작업 ID를 완료 처리기에 다시 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-138">If your class defines the *MethodName***Async** overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler.</span></span> <span data-ttu-id="8bbd1-139">도움이 되는 도우미 클래스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-139">There are helper classes available to assist.</span></span> <span data-ttu-id="8bbd1-140">동시성 관리에 대한 자세한 내용은 [연습: 이벤트 기반 비동기 패턴을 지원하는 구성 요소 구현](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-140">For more information on concurrency management, see [Walkthrough: Implementing a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
-   <span data-ttu-id="8bbd1-141">클래스가 상태 매개 변수 없이 *MethodName***Async** 메서드를 정의하고 클래스가 여러 동시 호출을 지원하지 않는 경우 이전 *MethodName***Async** 호출이 완료되기 전에 *MethodName***Async**를 호출하려는 시도에서 <xref:System.InvalidOperationException>이 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-141">If your class defines the *MethodName***Async** method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke *MethodName***Async** before the prior *MethodName***Async** invocation has completed raises an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="8bbd1-142">일반적으로 처리 중인 작업이 여러 개 있도록 `userSuppliedState` 매개 변수 없이 *MethodName***Async** 메서드를 여러 번 호출한 경우 예외를 발생시키지 마세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-142">In general, do not raise an exception if the *MethodName***Async** method without the `userSuppliedState` parameter is invoked multiple times so that there are multiple outstanding operations.</span></span> <span data-ttu-id="8bbd1-143">클래스가 명시적으로 해당 상황을 처리할 수 없는 경우 예외를 발생시킬 수 있지만 개발자가 구분할 수 없는 이러한 여러 콜백을 처리할 수 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-143">You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks</span></span>  
  
### <a name="accessing-results"></a><span data-ttu-id="8bbd1-144">결과 액세스</span><span class="sxs-lookup"><span data-stu-id="8bbd1-144">Accessing Results</span></span>  
  
-   <span data-ttu-id="8bbd1-145">비동기 작업을 실행하는 중에 오류가 발생한 경우 결과에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-145">If there was an error during execution of the asynchronous operation, the results should not be accessible.</span></span> <span data-ttu-id="8bbd1-146"><xref:System.ComponentModel.AsyncCompletedEventArgs>가 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>이 아닌 경우 `null`의 속성에 액세스하면 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>에서 참조하는 예외가 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-146">Ensure that accessing any property in the <xref:System.ComponentModel.AsyncCompletedEventArgs> when <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> is not `null` raises the exception referenced by <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span></span> <span data-ttu-id="8bbd1-147"><xref:System.ComponentModel.AsyncCompletedEventArgs> 클래스는 이 용도로 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-147">The <xref:System.ComponentModel.AsyncCompletedEventArgs> class provides the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method for this purpose.</span></span>  
  
-   <span data-ttu-id="8bbd1-148">결과에 액세스하려는 모든 시도에서 작업이 취소되었음을 나타내는 <xref:System.InvalidOperationException>이 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-148">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="8bbd1-149"><xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> 메서드를 사용하여 이 확인을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-149">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
### <a name="progress-reporting"></a><span data-ttu-id="8bbd1-150">진행률 보고</span><span class="sxs-lookup"><span data-stu-id="8bbd1-150">Progress Reporting</span></span>  
  
-   <span data-ttu-id="8bbd1-151">가능한 경우 진행률 보고를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-151">Support progress reporting, if possible.</span></span> <span data-ttu-id="8bbd1-152">그러면 개발자가 클래스를 사용할 때 더 나은 응용 프로그램 사용자 경험을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-152">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
-   <span data-ttu-id="8bbd1-153">**ProgressChanged** 또는 *MethodName***ProgressChanged** 이벤트를 구현하는 경우 특정 비동기 작업의 *MethodName***Completed** 이벤트가 발생한 후 해당 작업에 대해 그러한 이벤트가 발생하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-153">If you implement a **ProgressChanged** or *MethodName***ProgressChanged** event, ensure that there are no such events raised for a particular asynchronous operation after that operation's *MethodName***Completed** event has been raised.</span></span>  
  
-   <span data-ttu-id="8bbd1-154">표준 <xref:System.ComponentModel.ProgressChangedEventArgs>를 채우는 경우 <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A>가 항상 백분율로 해석될 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-154">If the standard <xref:System.ComponentModel.ProgressChangedEventArgs> is being populated, ensure that the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> can always be interpreted as a percentage.</span></span> <span data-ttu-id="8bbd1-155">백분율이 정확할 필요는 없지만 백분율을 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-155">The percentage does not need to be accurate, but it should represent a percentage.</span></span> <span data-ttu-id="8bbd1-156">진행률 보고 메트릭이 백분율이 아닌 다른 메트릭이어야 하는 경우 <xref:System.ComponentModel.ProgressChangedEventArgs> 클래스에서 클래스를 파생시키고 <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A>를 0으로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-156">If your progress reporting metric must be something other than a percentage, derive a class from the <xref:System.ComponentModel.ProgressChangedEventArgs> class and leave <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> at 0.</span></span> <span data-ttu-id="8bbd1-157">백분율이 아닌 보고 메트릭을 사용하는 것을 피하세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-157">Avoid using a reporting metric other than a percentage.</span></span>  
  
-   <span data-ttu-id="8bbd1-158">적절한 스레드 및 응용 프로그램 수명 주기의 적절한 시간에 `ProgressChanged` 이벤트가 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-158">Ensure that the `ProgressChanged` event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="8bbd1-159">자세한 내용은 스레딩 및 컨텍스트 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-159">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="isbusy-implementation"></a><span data-ttu-id="8bbd1-160">IsBusy 구현</span><span class="sxs-lookup"><span data-stu-id="8bbd1-160">IsBusy Implementation</span></span>  
  
-   <span data-ttu-id="8bbd1-161">클래스가 여러 동시 호출을 지원하는 경우 `IsBusy` 속성을 노출하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-161">Do not expose an `IsBusy` property if your class supports multiple concurrent invocations.</span></span> <span data-ttu-id="8bbd1-162">예를 들어, XML 웹 서비스 프록시는 비동기 메서드의 여러 동시 호출을 지원하므로 `IsBusy` 속성을 노출하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-162">For example, XML Web service proxies do not expose an `IsBusy` property because they support multiple concurrent invocations of asynchronous methods.</span></span>  
  
-   <span data-ttu-id="8bbd1-163">`IsBusy` 속성은 *MethodName***Async** 메서드가 호출된 후 *MethodName***Completed** 이벤트가 발생하기 전에 `true`를 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-163">The `IsBusy` property should return `true` after the *MethodName***Async** method has been called and before the *MethodName***Completed** event has been raised.</span></span> <span data-ttu-id="8bbd1-164">그렇지 않으면 `false`를 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-164">Otherwise it should return `false`.</span></span> <span data-ttu-id="8bbd1-165"><xref:System.ComponentModel.BackgroundWorker> 및 <xref:System.Net.WebClient> 구성 요소는 `IsBusy` 속성을 노출하는 클래스의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-165">The <xref:System.ComponentModel.BackgroundWorker> and <xref:System.Net.WebClient> components are examples of classes that expose an `IsBusy` property.</span></span>  
  
### <a name="cancellation"></a><span data-ttu-id="8bbd1-166">취소</span><span class="sxs-lookup"><span data-stu-id="8bbd1-166">Cancellation</span></span>  
  
-   <span data-ttu-id="8bbd1-167">가능한 경우 취소를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-167">Support cancellation, if possible.</span></span> <span data-ttu-id="8bbd1-168">그러면 개발자가 클래스를 사용할 때 더 나은 응용 프로그램 사용자 경험을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-168">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
-   <span data-ttu-id="8bbd1-169">취소의 경우 <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> 개체에 <xref:System.ComponentModel.AsyncCompletedEventArgs> 플래그를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-169">In the case of cancellation, set the <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag in the <xref:System.ComponentModel.AsyncCompletedEventArgs> object.</span></span>  
  
-   <span data-ttu-id="8bbd1-170">결과에 액세스하려는 모든 시도에서 작업이 취소되었음을 나타내는 <xref:System.InvalidOperationException>이 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-170">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="8bbd1-171"><xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> 메서드를 사용하여 이 확인을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-171">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
-   <span data-ttu-id="8bbd1-172">취소 메서드에 대한 호출은 항상 성공적으로 반환되고 예외를 발생시키지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-172">Ensure that calls to a cancellation method always return successfully, and never raise an exception.</span></span> <span data-ttu-id="8bbd1-173">일반적으로 클라이언트는 어느 시점에서든 작업이 진정으로 취소 가능한지에 대한 알림을 받지 않으며, 이전에 발생한 취소가 성공적인지에 대한 알림도 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-173">In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded.</span></span> <span data-ttu-id="8bbd1-174">그러나 응용 프로그램은 완료 상태에 참여하므로 취소가 성공적일 때 응용 프로그램에는 항상 알림이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-174">However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.</span></span>  
  
-   <span data-ttu-id="8bbd1-175">작업이 취소되면 *MethodName***Completed** 이벤트를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-175">Raise the *MethodName***Completed** event when the operation is canceled.</span></span>  
  
### <a name="errors-and-exceptions"></a><span data-ttu-id="8bbd1-176">오류 및 예외</span><span class="sxs-lookup"><span data-stu-id="8bbd1-176">Errors and Exceptions</span></span>  
  
-   <span data-ttu-id="8bbd1-177">비동기 작업에서 발생하는 모든 예외를 catch하고 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> 속성 값을 해당 예외로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-177">Catch any exceptions that occur in the asynchronous operation and set the value of the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> property to that exception.</span></span>  
  
### <a name="threading-and-contexts"></a><span data-ttu-id="8bbd1-178">스레딩 및 컨텍스트</span><span class="sxs-lookup"><span data-stu-id="8bbd1-178">Threading and Contexts</span></span>  
 <span data-ttu-id="8bbd1-179">클래스가 올바로 작동하도록 하려면 [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] 및 Windows Forms 응용 프로그램을 비롯한 지정된 응용 프로그램 모델에 대해 올바른 스레드 또는 컨텍스트에서 클라이언트의 이벤트 처리기가 호출되도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-179">For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] and Windows Forms applications.</span></span> <span data-ttu-id="8bbd1-180">모든 응용 프로그램 모델에서 비동기 클래스가 올바르게 동작하도록 하기 위해 두 개의 중요한 도우미 클래스인 <xref:System.ComponentModel.AsyncOperation> 및 <xref:System.ComponentModel.AsyncOperationManager>가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-180">Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager>.</span></span>  
  
 <span data-ttu-id="8bbd1-181"><xref:System.ComponentModel.AsyncOperationManager>는 <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>을 반환하는 하나의 메서드 <xref:System.ComponentModel.AsyncOperation>을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-181"><xref:System.ComponentModel.AsyncOperationManager> provides one method, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, which returns an <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="8bbd1-182">*MethodName***Async** 메서드는 <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>을 호출하고 클래스는 반환된 <xref:System.ComponentModel.AsyncOperation>을 사용하여 비동기 작업의 수명을 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-182">Your *MethodName***Async** method calls <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> and your class uses the returned <xref:System.ComponentModel.AsyncOperation> to track the lifetime of the asynchronous task.</span></span>  
  
 <span data-ttu-id="8bbd1-183">클라이언트에 진행률, 증분 결과 및 완료를 보고하려면 <xref:System.ComponentModel.AsyncOperation.Post%2A>에 대해 <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> 및 <xref:System.ComponentModel.AsyncOperation> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-183">To report progress, incremental results, and completion to the client, call the <xref:System.ComponentModel.AsyncOperation.Post%2A> and <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> methods on the <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="8bbd1-184"><xref:System.ComponentModel.AsyncOperation>은 클라이언트의 이벤트 처리기에 대한 호출을 올바른 스레드 또는 컨텍스트로 마샬링하는 작업을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-184"><xref:System.ComponentModel.AsyncOperation> is responsible for marshaling calls to the client's event handlers to the proper thread or context.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8bbd1-185">명시적으로 응용 프로그램 모델의 정책에 반대하되 이벤트 기반 비동기 패턴 사용의 다른 이점을 이용하려는 경우 이러한 규칙을 피해 갈 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-185">You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern.</span></span> <span data-ttu-id="8bbd1-186">예를 들어, Windows Forms에서 작동하는 클래스가 자유 스레드가 되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-186">For example, you may want a class operating in Windows Forms to be free threaded.</span></span> <span data-ttu-id="8bbd1-187">개발자가 암시된 제한 사항을 이해하는 한 자유 스레드 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-187">You can create a free threaded class, as long as developers understand the implied restrictions.</span></span> <span data-ttu-id="8bbd1-188">콘솔 응용 프로그램은 <xref:System.ComponentModel.AsyncOperation.Post%2A> 호출 실행을 동기화하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-188">Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls.</span></span> <span data-ttu-id="8bbd1-189">이로 인해 `ProgressChanged` 이벤트가 잘못 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-189">This can cause `ProgressChanged` events to be raised out of order.</span></span> <span data-ttu-id="8bbd1-190"><xref:System.ComponentModel.AsyncOperation.Post%2A> 호출이 serialize되어 실행되도록 하려면 <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> 클래스를 구현하여 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-190">If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="8bbd1-191"><xref:System.ComponentModel.AsyncOperation> 및 <xref:System.ComponentModel.AsyncOperationManager>를 사용하여 비동기 작업을 사용하도록 설정하는 방법에 대한 자세한 내용은 [연습: 이벤트 기반 비동기 패턴을 지원하는 구성 요소 구현](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-191">For more information about using <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager> to enable your asynchronous operations, see [Walkthrough: Implementing a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="guidelines"></a><span data-ttu-id="8bbd1-192">지침</span><span class="sxs-lookup"><span data-stu-id="8bbd1-192">Guidelines</span></span>  
  
-   <span data-ttu-id="8bbd1-193">이상적으로는 각 메서드 호출이 다른 메서드 호출과 별개여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-193">Ideally, each method invocation should be independent of others.</span></span> <span data-ttu-id="8bbd1-194">호출을 공유 리소스와 결합하는 것을 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-194">You should avoid coupling invocations with shared resources.</span></span> <span data-ttu-id="8bbd1-195">리소스가 호출 간에 공유되는 경우 구현에 적절한 동기화 메커니즘을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-195">If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.</span></span>  
  
-   <span data-ttu-id="8bbd1-196">클라이언트가 동기화를 구현해야 하는 디자인은 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-196">Designs that require the client to implement synchronization are discouraged.</span></span> <span data-ttu-id="8bbd1-197">예를 들어, 전역 정적 개체를 매개 변수로 받는 비동기 메서드가 있을 수 있습니다. 이러한 메서드의 여러 동시 호출로 인해 데이터 손상이나 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-197">For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.</span></span>  
  
-   <span data-ttu-id="8bbd1-198">여러 호출 오버로드로 메서드를 구현하는 경우(시그니처에 `userState`가 있음) 클래스가 사용자 상태 또는 작업 ID 및 해당 보류 중인 작업의 컬렉션을 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-198">If you implement a method with the multiple-invocation overload (`userState` in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations.</span></span> <span data-ttu-id="8bbd1-199">다양한 호출에서 컬렉션에 `lock` 개체를 추가 및 제거하므로 이 컬렉션은 `userState` 영역으로 보호해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-199">This collection should be protected with `lock` regions, because the various invocations add and remove `userState` objects in the collection.</span></span>  
  
-   <span data-ttu-id="8bbd1-200">실현 가능하고 적절한 경우 `CompletedEventArgs` 클래스 재사용을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-200">Consider reusing `CompletedEventArgs` classes where feasible and appropriate.</span></span> <span data-ttu-id="8bbd1-201">이 경우 지정된 대리자 및 <xref:System.EventArgs> 형식이 단일 메서드에 연결된 것이 아니므로 명명이 메서드 이름과 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-201">In this case, the naming is not consistent with the method name, because a given delegate and <xref:System.EventArgs> type are not tied to a single method.</span></span> <span data-ttu-id="8bbd1-202">그러나 개발자가 <xref:System.EventArgs>에 대한 속성에서 검색된 값을 강제로 캐스팅하도록 하는 것은 절대 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-202">However, forcing developers to cast the value retrieved from a property on the <xref:System.EventArgs> is never acceptable.</span></span>  
  
-   <span data-ttu-id="8bbd1-203"><xref:System.ComponentModel.Component>에서 파생되는 클래스를 작성하는 경우 고유한 <xref:System.Threading.SynchronizationContext> 클래스를 구현하여 설치하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-203">If you are authoring a class that derives from <xref:System.ComponentModel.Component>, do not implement and install your own <xref:System.Threading.SynchronizationContext> class.</span></span> <span data-ttu-id="8bbd1-204">구성 요소가 아니라 응용 프로그램 모델이 사용되는 <xref:System.Threading.SynchronizationContext>를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-204">Application models, not components, control the <xref:System.Threading.SynchronizationContext> that is used.</span></span>  
  
-   <span data-ttu-id="8bbd1-205">모든 종류의 다중 스레딩을 사용할 때는 매우 심각하고 복잡한 버그에 잠재적으로 노출됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-205">When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs.</span></span> <span data-ttu-id="8bbd1-206">다중 스레딩을 사용하는 솔루션을 구현하기 전에 [관리되는 스레딩을 구현하는 최선의 방법](../../../docs/standard/threading/managed-threading-best-practices.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bbd1-206">Before implementing any solution that uses multithreading, see [Managed Threading Best Practices](../../../docs/standard/threading/managed-threading-best-practices.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8bbd1-207">참고 항목</span><span class="sxs-lookup"><span data-stu-id="8bbd1-207">See Also</span></span>  
 <xref:System.ComponentModel.AsyncOperation>  
 <xref:System.ComponentModel.AsyncOperationManager>  
 <xref:System.ComponentModel.AsyncCompletedEventArgs>  
 <xref:System.ComponentModel.ProgressChangedEventArgs>  
 <xref:System.ComponentModel.BackgroundWorker>  
 [<span data-ttu-id="8bbd1-208">이벤트 기반 비동기 패턴 구현</span><span class="sxs-lookup"><span data-stu-id="8bbd1-208">Implementing the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md)  
 [<span data-ttu-id="8bbd1-209">이벤트 기반 비동기 패턴을 사용한 다중 스레드 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="8bbd1-209">Multithreaded Programming with the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/multithreaded-programming-with-the-event-based-asynchronous-pattern.md)  
 [<span data-ttu-id="8bbd1-210">이벤트 기반 비동기 패턴 구현 시기 결정</span><span class="sxs-lookup"><span data-stu-id="8bbd1-210">Deciding When to Implement the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)  
 [<span data-ttu-id="8bbd1-211">최선의 이벤트 기반 비동기 패턴 구현 방법</span><span class="sxs-lookup"><span data-stu-id="8bbd1-211">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)  
 [<span data-ttu-id="8bbd1-212">방법: 이벤트 기반 비동기 패턴을 지원하는 구성 요소 사용</span><span class="sxs-lookup"><span data-stu-id="8bbd1-212">How to: Use Components That Support the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)  
 [<span data-ttu-id="8bbd1-213">연습: 이벤트 기반 비동기 패턴을 지원하는 구성 요소 구현</span><span class="sxs-lookup"><span data-stu-id="8bbd1-213">Walkthrough: Implementing a Component That Supports the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)

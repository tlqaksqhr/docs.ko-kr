---
title: 분산 데이터 관리를 위한 과제 및 해결 방법
description: 컨테이너화된 .NET 응용 프로그램용 .NET 마이크로 서비스 아키텍처 | 분산 데이터 관리를 위한 과제 및 해결 방법
keywords: Docker, 마이크로 서비스, ASP.NET, 컨테이너
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: a26f4243acee52e493a10f13ff18899823fd03ba
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/18/2018
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a>분산 데이터 관리를 위한 과제 및 해결 방법

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a>과제 \#1: 각 마이크로 서비스의 경계를 정의하는 방법

마이크로 서비스 경계를 정의하는 것은 아마도 처음 만나는 도전일 것입니다. 각 마이크로 서비스는 응용 프로그램의 일부여야 하며, 각 마이크로 서비스에서 제공하는 모든 이점과 과제를 통해 독립적으로 작동해야 합니다. 하지만 이러한 경계는 어떻게 알아볼 수 있을까요?

먼저 응용 프로그램의 논리 도메인 모델 및 관련 데이터에 집중해야 합니다. 동일한 응용 프로그램 내에서 분리된 위치의 데이터와 다양한 컨텍스트를 식별해야 합니다. 각 컨텍스트에는 다양한 비즈니스 언어(용어)가 있을 수 있습니다. 컨텍스트는 독립적으로 정의하고 관리해야 합니다. 이러한 다양한 컨텍스트에서 사용되는 용어와 엔터티는 비슷하지만, 특정 컨텍스트에서 하나의 비즈니스 개념이 다른 컨텍스트에서 다른 용도로 사용되고 다른 이름을 가질 수도 있다는 것을 알 수 있습니다. 예를 들어 사용자는 ID 또는 멤버 자격 컨텍스트에서 사용자, CRM 컨텍스트에서 고객, 주문 컨텍스트에서 구매자 등등으로 참조할 수 있습니다.

각 컨텍스트마다 다른 도메인이 있는 여러 응용 프로그램 컨텍스트 간에 경계를 식별하는 방법은 정확히 각 비즈니스 마이크로 서비스와 해당 도메인 모델 및 데이터에 대한 경계를 식별하는 방법입니다. 항상 이러한 마이크로 서비스 간의 결합을 최소화하려고 합니다. 이 가이드는 나중에 [각 마이크로 서비스에 대한 도메인 모델 경계 식별](#identifying-domain-model-boundaries-for-each-microservice) 섹션에서 이러한 식별 및 도메인 모델 디자인에 대해 자세히 설명합니다.

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a>과제 \#2: 여러 마이크로 서비스에서 데이터를 검색하는 쿼리를 만드는 방법

두 번째 과제는 원격 클라이언트 앱에서 마이크로 서비스에 대한 번거로운 통신을 피하면서 여러 마이크로 서비스에서 데이터를 검색하는 쿼리를 구현하는 방법입니다. 예를 들어 장바구니, 카탈로그 및 사용자 ID 마이크로 서비스에서 소유한 사용자 정보를 표시해야 하는 모바일 앱의 단일 화면이 될 수 있습니다. 또 다른 예로 여러 마이크로 서비스에 있는 많은 테이블이 포함된 복잡한 보고서가 있습니다. 올바른 해결 방법은 쿼리의 복잡성에 따라 달라집니다. 그러나 어떤 경우이든 시스템 통신의 효율성을 높이려면 정보를 집계하는 방법이 필요합니다. 가장 인기 있는 해결 방법은 다음과 같습니다.

**API 게이트웨이** 서로 다른 데이터베이스를 소유한 여러 마이크로 서비스의 간단한 데이터 집계에 권장되는 방법은 API 게이트웨이라고 하는 집계 마이크로 서비스입니다. 그러나 시스템의 문제 지점(choke point)이 될 수 있고 마이크로 서비스의 자율 원칙을 위반할 수 있으므로 이 패턴을 구현하는 데 주의해야 합니다. 이러한 가능성을 줄이기 위해 각각 시스템의 수직적 "조각" 또는 비즈니스 영역에 집중하는 여러 개의 정교한 API 게이트웨이가 있을 수 있습니다. API 게이트웨이 패턴은 나중에 "API 게이트웨이 사용" 섹션에서 자세히 설명합니다.

**쿼리/읽기 테이블이 포함된 CQRS(명령과 쿼리의 역할 분리)** 여러 마이크로 서비스에서 데이터를 집계하는 또 다른 해결 방법은 [구체화된 뷰 패턴](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)입니다. 이 방법에서는 여러 마이크로 서비스에서 소유한 데이터가 있는 읽기 전용 테이블을 미리 생성합니다(실제 쿼리가 수행되기 전에 비정규화된 데이터 준비). 이 테이블에는 클라이언트 앱의 요구 사항에 적합한 형식이 있습니다.

모바일 앱에 대한 화면과 같은 것을 사용하는 것이 좋습니다. 단일 데이터베이스가 있는 경우 여러 테이블과 관련된 복잡한 조인을 수행하는 SQL 쿼리를 사용하여 해당 화면에 대한 데이터를 함께 가져올 수 있습니다. 그러나 여러 데이터베이스가 있고 다른 마이크로 서비스에서 각 데이터베이스를 소유하는 경우 이러한 데이터베이스를 쿼리하고 SQL 조인을 만들 수 없습니다. 복잡한 쿼리가 문제가 됩니다. CQRS 방법을 사용하여 요구 사항을 해결할 수 있습니다. 즉 쿼리에 대해서만 사용되는 다른 데이터베이스에 비정규화된 테이블을 만들 수 있습니다. 이 테이블은 복잡한 쿼리에 필요한 데이터에 맞게 특별히 설계할 수 있으며, 응용 프로그램의 화면에 필요한 필드와 쿼리 테이블의 열 사이에 일대일 관계가 있습니다. 또한 보고 목적으로도 사용될 수 있습니다.

이 방법은 원래의 문제(여러 마이크로 서비스 간에 쿼리하고 조인하는 방법)를 해결할 뿐만 아니라, 응용 프로그램에 필요한 데이터가 이미 쿼리 테이블에 있으므로 성능도 복잡한 조인에 비해 상당히 향상됩니다. 물론 쿼리/읽기 테이블이 포함된 CQRS를 사용하는 경우, 추가 개발 작업이 필요하고 최종 일관성을 수용해야 합니다. 그럼에도 불구하고 [공동 작업 시나리오](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/)(또는 관점에 따라 경쟁 시나리오)에서 성능 및 높은 확장성 요구 사항이 있는 경우, 여러 데이터베이스가 포함된 CQRS를 적용해야 합니다.

**중앙 데이터베이스의 "콜드 데이터"** 실시간 데이터가 필요하지 않을 수 있는 복잡한 보고서 및 쿼리의 경우, 일반적인 방법은 보고에만 사용되는 대형 데이터베이스에 "핫 데이터"(마이크로 서비스의 트랜잭션 데이터)를 "콜드 데이터"로 내보내는 것입니다. 이 중앙 데이터베이스 시스템은 빅 데이터 기반 시스템(예: Hadoop), 데이터 웨어하우스(예: Azure SQL Data Warehouse) 또는 보고서에만 사용되는 단일 SQL 데이터베이스(크기가 문제가 되지 않는 경우)일 수 있습니다.

이 중앙 집중식 데이터베이스는 실시간 데이터가 필요 없는 쿼리 및 보고서에만 사용됩니다. 원래의 업데이트 및 트랜잭션은 진실의 원본으로 마이크로 서비스 데이터에 있어야 합니다. 데이터를 동기화하는 방법은 이벤트 기반 통신(다음 섹션에서 설명됨)을 사용하거나 다른 데이터베이스 인프라 가져오기/내보내기 도구를 사용하는 것입니다. 이벤트 기반 통신을 사용하는 경우 해당 통합 프로세스는 CQRS 쿼리 테이블에 대해 앞에서 설명한 대로 데이터를 전파하는 방식과 비슷합니다.

그러나 응용 프로그램 디자인에서 복잡한 쿼리에 대해 여러 마이크로 서비스의 정보를 지속적으로 집계하는 경우 잘못된 디자인의 증상일 수 있습니다. 즉, 마이크로 서비스는 가능한 한 다른 마이크로 서비스로부터 격리되어야 합니다. (콜드 데이터 중앙 데이터베이스를 항상 사용해야 하는 보고서/분석은 제외됩니다.) 이 문제가 종종 마이크로 서비스를 병합하는 이유가 될 수 있습니다. 각 마이크로 서비스의 진화 및 배포의 자율성과 강력한 종속성, 응집력 및 데이터 집계의 균형을 유지해야 합니다.

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a>과제 \#3: 여러 마이크로 서비스 간에 일관성을 유지하는 방법

앞에서 설명한 대로 각 마이크로 서비스에서 소유한 데이터는 해당 마이크로 서비스 전용이며, 마이크로 서비스 API를 통해서만 액세스할 수 있습니다. 따라서 여러 마이크로 서비스 간에 일관성을 유지하면서 종단 간 비즈니스 프로세스를 구현하는 방법을 제시해야 합니다.

이 문제를 분석하기 위해 [eShopOnContainers 참조 응용 프로그램](http://aka.ms/eshoponcontainers)의 예제를 살펴보겠습니다. 카탈로그 마이크로 서비스는 재고 수준을 포함하여 모든 제품에 대한 정보를 유지 관리합니다. 주문 마이크로 서비스는 주문을 관리하며, 새 주문이 사용 가능한 카탈로그 제품 재고를 초과하지 않는지 확인해야 합니다. (또는 이월된 제품을 처리하는 논리가 시나리오에 포함될 수 있습니다.) 이 응용 프로그램의 가상 모놀리식 버전에서 주문 하위 시스템은 ACID 트랜잭션을 사용하여 사용 가능한 재고를 확인하고, 주문 테이블에서 주문을 만들고, 제품 테이블에서 사용 가능한 재고를 업데이트할 수 있습니다.

그러나 마이크로 서비스 기반 응용 프로그램의 경우 주문 및 제품 테이블은 각각의 마이크로 서비스에서 소유합니다. 그림 4-9와 같이 마이크로 서비스는 다른 마이크로 서비스에서 소유한 데이터베이스를 자체의 트랜잭션 또는 쿼리에 포함해서는 안됩니다.

![](./media/image9.PNG)

**그림 4-9** 다른 마이크로 서비스의 테이블에 직접 액세스할 수 없는 마이크로 서비스

제품 테이블은 카탈로그 마이크로 서비스에서 소유하고 있으므로 주문 마이크로 서비스에서 해당 제품 테이블을 직접 업데이트하지 않아야 합니다. 카탈로그 마이크로 서비스를 업데이트하려면 주문 마이크로 서비스에서 통합 이벤트(메시지 및 이벤트 기반 통신)와 같은 비동기 통신만 사용해야 합니다. 이는 [eShopOnContainers](http://aka.ms/eshoponcontainers) 참조 응용 프로그램에서 이러한 유형의 업데이트를 수행하는 방법입니다.

[CAP 정리](https://en.wikipedia.org/wiki/CAP_theorem)에서 명시한 대로 가용성과 강력한 ACID 일관성 중에서 선택해야 합니다. 대부분의 마이크로 서비스 기반 시나리오에서는 강력한 일관성과 달리 가용성과 높은 확장성을 요구합니다. 중요 업무용 응용 프로그램은 계속 유지되고 실행되어야 하고, 개발자는 약한 일관성 또는 최종 일관성 작업을 위한 기술을 사용하여 강력한 일관성을 해결할 수 있습니다. 이는 대부분의 마이크로 서비스 기반 아키텍처에서 사용하는 방법입니다.

ACID 방식 또는 2단계 커밋 트랜잭션은 마이크로 서비스 원칙에 위반되는 것이 아닙니다. 대부분의 NoSQL 데이터베이스(예: Azure Cosmos DB, MongoDB 등)는 2단계 커밋 트랜잭션을 지원하지 않습니다. 그러나 서비스와 데이터베이스 간의 데이터 일관성은 반드시 유지해야 합니다. 또한 이 과제는 특정 데이터가 중복될 필요가 있을 때(예: 카탈로그 마이크로 서비스 및 장바구니 마이크로 서비스에 제품의 이름 또는 설명이 있어야 할 때), 여러 마이크로 서비스에 변경 내용을 전파하는 방법에 대한 질문과 관련이 있습니다.

이 문제에 적합한 해결 방법은 이벤트 기반 통신과 게시 및 구독 시스템을 통해 연결된 마이크로 서비스 간에 최종 일관성을 사용하는 것입니다. 이러한 항목은 이 가이드의 뒷부분에 나오는 [비동기 이벤트 기반 통신](#async_event_driven_communication) 섹션에서 설명합니다.

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a>과제 \#4: 마이크로 서비스 경계 간에 통신을 설계하는 방법

마이크로 서비스 경계 간의 통신은 실제적인 과제입니다. 이 컨텍스트에서 통신은 사용해야 하는 프로토콜(HTTP 및 REST, AMQP, 메시징 등)을 참조하지 않습니다. 대신, 사용해야 하는 통신 방식, 특히 마이크로 서비스가 결합되어야 하는 방식을 해결해야 합니다. 오류가 발생하는 경우 결합 수준에 따라 시스템에 미치는 오류의 영향은 상당히 다를 수 있습니다.

마이크로 서비스 기반 응용 프로그램과 같은 분산 시스템에서는 여러 서버 또는 호스트에서 분산 서비스를 통해 많은 아티팩트가 이동하므로 결국에는 구성 요소가 실패합니다. 부분적인 실패와 더 큰 중단이 발생할 수 있으므로 이러한 유형의 분산 시스템에서 일반적인 위험을 고려하여 마이크로 서비스와 이들 간의 통신을 설계해야 합니다.

인기 있는 방법은 단순성으로 인해 HTTP(REST) 기반 마이크로 서비스를 구현하는 것입니다. HTTP 기반 방법은 완벽하게 허용됩니다. 여기서의 문제는 이를 사용하는 방법과 관련이 있습니다. HTTP 요청과 응답을 사용하여 클라이언트 응용 프로그램 또는 API 게이트웨이에서 마이크로 서비스와 상호 작용하는 경우에는 문제가 없습니다. 그러나 마이크로 서비스 전체에서 동기식 HTTP 호출의 긴 체인을 만들고 마이크로 서비스가 모놀리식 응용 프로그램의 개체인 것처럼 경계 간에 통신하는 경우 결국에는 응용 프로그램에 문제가 발생합니다.

예를 들어 클라이언트 응용 프로그램이 주문 마이크로 서비스와 같은 개별 마이크로 서비스에 대한 HTTP API 호출을 수행한다고 가정합니다. 이에 따라 주문 마이크로 서비스에서 동일한 요청/응답 주기 내에서 HTTP를 사용하여 마이크로 서비스를 추가로 호출하면 HTTP 호출 체인이 만들어집니다. 처음에는 합리적일 수도 있습니다. 그러나 다음과 같은 상황에 있을 때 고려해야 할 중요한 사항이 있습니다.

-   차단 및 성능 저하. HTTP의 동기식 특성으로 인해 모든 내부 HTTP 호출이 완료될 때까지 원래 요청에서 응답을 받지 못합니다. 이러한 호출 횟수가 크게 증가하는 동시에 마이크로 서비스에 대한 중간 HTTP 호출 중 하나가 차단되는 경우가 있다고 가정합니다. 그 결과 성능에 영향을 미치고, 추가 HTTP 요청이 증가함에 따라 전반적인 확장성이 기하급수적으로 영향을 받습니다.

-   마이크로 서비스와 HTTP의 결합. 비즈니스 마이크로 서비스는 다른 비즈니스 마이크로 서비스와 결합하면 안됩니다. 이상적으로 다른 마이크로 서비스의 존재에 대해 "인식하지" 못합니다. 예를 들어 응용 프로그램에서 마이크로 서비스의 결합을 사용하는 경우 마이크로 서비스별 자율성을 달성하는 것은 거의 불가능합니다.

-   어느 한 마이크로 서비스에서 발생한 오류. HTTP 호출로 연결되는 마이크로 서비스 체인을 구현한 경우, 마이크로 서비스 중 하나에 오류가 발생하면(결국에는 전체 마이크로 서비스가 실패함) 마이크로 서비스 체인 전체에 오류가 발생합니다. 마이크로 서비스 기반 시스템은 부분적인 오류 발생 시에도 가능한 한 계속 작동하도록 설계되어야 합니다. 지수 백오프 또는 회로 차단기 메커니즘을 사용하여 다시 시도 횟수를 사용하는 클라이언트 논리를 구현하는 경우에도 HTTP 호출 체인이 복잡할수록 HTTP 기반 오류 전략을 구현하는 것이 더 복잡해집니다.

실제로 내부 마이크로 서비스에서 설명한 대로 HTTP 요청 체인을 만들어 통신하는 경우, 모놀리식 응용 프로그램이 있지만 내부 처리 통신 메커니즘이 아닌 프로세스 간 HTTP를 기반으로 한다고 주장할 수 있습니다.

따라서 마이크로 서비스 자율성을 적용하고 복원력을 높이려면 마이크로 서비스 간에 요청/응답 통신 체인을 최소한으로 사용해야 합니다. 비동기 메시지 및 이벤트 기반 통신을 사용하거나 원래의 HTTP 요청/응답 주기와 별도로 HTTP 폴링을 사용하여 마이크로 서비스 간 통신에 비동기 상호 작용만 사용하는 것이 좋습니다.

비동기 통신 사용에 대한 자세한 내용은 이 가이드의 뒷부분에 나오는 [비동기식 마이크로 서비스 통합에서 마이크로 서비스 자율성 적용](#asynchronous-microservice-integration-enforce-microservices-autonomy) 및 [비동기 메시지 기반 통신](#asynchronous-message-based-communication) 섹션에서 설명합니다.

## <a name="additional-resources"></a>추가 자료

-   **CAP 원리**
    [*https://en.wikipedia.org/wiki/CAP\_원리*](https://en.wikipedia.org/wiki/CAP_theorem)

-   **최종 일관성**
    [*https://en.wikipedia.org/wiki/Eventual\_일관성*](https://en.wikipedia.org/wiki/Eventual_consistency)

-   **데이터 일관성 입문서**
    [*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)

-   **Martin Fowler. CQRS(명령과 쿼리의 역할 구분)**
    [*https://martinfowler.com/bliki/CQRS.html*](https://martinfowler.com/bliki/CQRS.html)

-   **구체화된 뷰**
    [*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)

-   **Charles Row 작성, ACID 및 베이스: 데이터베이스 트랜잭션 처리의 pH 이동**
    [*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)

-   **보상 트랜잭션**
    [*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)

-   **Udi Dahan. 서비스 지향 컴퍼지션**
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)


>[!div class="step-by-step"]
[이전] (logical-versus-physical-architecture.md) [다음] (identify-microservice-domain-model-boundaries.md)

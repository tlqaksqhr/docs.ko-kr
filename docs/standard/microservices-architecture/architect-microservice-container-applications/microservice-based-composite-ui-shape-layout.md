---
title: "여러 마이크로 서비스에서 생성된 시각적 UI 셰이프 및 레이아웃을 포함하여 마이크로 서비스를 기반으로 복합 UI 만들기"
description: "컨테이너화된 .NET 응용 프로그램의 .NET 마이크로 서비스 아키텍처 | 여러 마이크로 서비스에서 생성된 시각적 UI 셰이프 및 레이아웃을 포함하여 마이크로 서비스를 기반으로 복합 UI 만들기"
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 12b170e9d4c46fbb697f988596af6566d33099a4
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/23/2017
---
# <a name="creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices"></a><span data-ttu-id="e09e0-104">여러 마이크로 서비스에서 생성된 시각적 UI 셰이프 및 레이아웃을 포함하여 마이크로 서비스를 기반으로 복합 UI 만들기</span><span class="sxs-lookup"><span data-stu-id="e09e0-104">Creating composite UI based on microservices, including visual UI shape and layout generated by multiple microservices</span></span>

<span data-ttu-id="e09e0-105">마이크로 서비스 아키텍처는 서버 쪽에서 데이터 및 논리를 처리하기 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-105">Microservices architecture often starts with the server side handling data and logic.</span></span> <span data-ttu-id="e09e0-106">그러나 고급 방법은 마이크로 서비스에 따라 응용 프로그램 UI를 디자인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-106">However, a more advanced approach is to design your application UI based on microservices as well.</span></span> <span data-ttu-id="e09e0-107">즉, 서버에 마이크로 서비스를 배치하고 모놀리식 클라이언트 앱이 마이크로 서비스를 사용하는 대신 마이크로 서비스에서 생성되는 복합 UI가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-107">That means having a composite UI produced by the microservices, instead of having microservices on the server and just a monolithic client app consuming the microservices.</span></span> <span data-ttu-id="e09e0-108">이 방법으로 마이크로 서비스는 논리 및 시각적 표현 모두를 사용하여 완료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-108">With this approach, the microservices you build can be complete with both logic and visual representation.</span></span>

<span data-ttu-id="e09e0-109">그림 4-20에서는 모놀리식 클라이언트 응용 프로그램에서 마이크로 서비스를 사용하는 간단한 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-109">Figure 4-20 shows the simpler approach of just consuming microservices from a monolithic client application.</span></span> <span data-ttu-id="e09e0-110">물론 HTML 및 JavaScript를 생성하면 ASP.NET MVC 서비스가 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-110">Of course, you could have an ASP.NET MVC service in between producing the HTML and JavaScript.</span></span> <span data-ttu-id="e09e0-111">그림은 마이크로 서비스를 사용하는 단일(모놀리식) 클라이언트 UI가 있음을 간단히 강조 표시합니다. 여기서는 UI 셰이프(HTML 및 JavaScript)가 아니라 논리 및 데이터에만 집중합니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-111">The figure is a simplification that highlights that you have a single (monolithic) client UI consuming the microservices, which just focus on logic and data and not on the UI shape (HTML and JavaScript).</span></span>

![](./media/image20.png)

<span data-ttu-id="e09e0-112">**그림 4-20**.</span><span class="sxs-lookup"><span data-stu-id="e09e0-112">**Figure 4-20**.</span></span> <span data-ttu-id="e09e0-113">백 엔드 마이크로 서비스를 소비하는 모놀리식 UI 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="e09e0-113">A monolithic UI application consuming back-end microservices</span></span>

<span data-ttu-id="e09e0-114">반면, 복합 UI는 정확하게 마이크로 서비스 자체에서 생성하고 구성했습니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-114">In contrast, a composite UI is precisely generated and composed by the microservices themselves.</span></span> <span data-ttu-id="e09e0-115">일부 마이크로 서비스는 UI 특정 영역의 시각적 셰이프를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-115">Some of the microservices drive the visual shape of specific areas of the UI.</span></span> <span data-ttu-id="e09e0-116">주요 차이는 템플릿에 기반한 클라이언트 UI 구성 요소(예: TS 클래스)가 있으며 해당 템플릿에 대한 data-shaping-UI ViewModel가 각 마이크로 서비스에서 제공된다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-116">The key difference is that you have client UI components (TS classes, for example) based on templates, and the data-shaping-UI ViewModel for those templates comes from each microservice.</span></span>

<span data-ttu-id="e09e0-117">클라이언트 응용 프로그램 시작 시 클라이언트 UI 구성 요소(예: TypeScript 클래스)는 각각 지정된 시나리오에 ViewModels를 제공하는 인프라 마이크로 서비스를 사용하여 등록됩니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-117">At client application start-up time, each of the client UI components (TypeScript classes, for example) registers itself with an infrastructure microservice capable of providing ViewModels for a given scenario.</span></span> <span data-ttu-id="e09e0-118">마이크로 서비스가 모양을 변경하면 UI도 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-118">If the microservice changes the shape, the UI changes also.</span></span>

<span data-ttu-id="e09e0-119">그림 4-21은 복합 UI 방법의 버전을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-119">Figure 4-21 shows a version of this composite UI approach.</span></span> <span data-ttu-id="e09e0-120">다양한 기술을 기반으로 세분화된 부분을 집계하는 다른 마이크로 서비스가 있기 때문에 간소화됩니다. 이것은 기존 웹 접근 방식(ASP.NET MVC) 또는 SPA(단일 페이지 응용 프로그램)를 빌드하는지에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-120">This is simplified, because you might have other microservices that are aggregating granular parts based on different techniques—it depends on whether you are building a traditional web approach (ASP.NET MVC) or an SPA (Single Page Application).</span></span>

![](./media/image21.png)

<span data-ttu-id="e09e0-121">**그림 4-21**.</span><span class="sxs-lookup"><span data-stu-id="e09e0-121">**Figure 4-21**.</span></span> <span data-ttu-id="e09e0-122">백 엔드 마이크로 서비스에서 셰이프된 복합 UI 응용 프로그램 예제</span><span class="sxs-lookup"><span data-stu-id="e09e0-122">Example of a composite UI application shaped by back-end microservices</span></span>

<span data-ttu-id="e09e0-123">해당 UI 컴퍼지션 마이크로 서비스는 각각 작은 API 게이트웨이와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-123">Each of those UI composition microservices would be similar to a small API Gateway.</span></span> <span data-ttu-id="e09e0-124">그러나 이 경우에는 각각 작은 UI 영역을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-124">But in this case each is responsible for a small UI area.</span></span>

<span data-ttu-id="e09e0-125">따라서 마이크로 서비스에서 제어하는 복합 UI 방법은 사용 중인 UI 기술에 따라 더 어렵거나 쉬워질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-125">A composite UI approach that is driven by microservices can be more challenging or less so, depending on what UI technologies you are using.</span></span> <span data-ttu-id="e09e0-126">예를 들어, SPA 또는 네이티브 모바일 앱을 빌드하기 위해 기존 웹 응용 프로그램을 빌드하는 동일한 기술을 사용하지 않습니다(Xamarin 앱을 개발하는 경우 마찬가지로 이 방법이 좀 더 어려울 수 있음).</span><span class="sxs-lookup"><span data-stu-id="e09e0-126">For instance, you will not use the same techniques for building a traditional web application that you use for building an SPA or for native mobile app (as when developing Xamarin apps, which can be more challenging for this approach).</span></span>

<span data-ttu-id="e09e0-127">[eShopOnContainers](http://aka.ms/MicroservicesArchitecture) 응용 프로그램 예제는 여러 가지 이유로 모놀리식 UI 방법을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-127">The [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) sample application uses the monolithic UI approach for multiple reasons.</span></span> <span data-ttu-id="e09e0-128">먼저 마이크로 서비스 및 컨테이너에 대한 소개입니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-128">First, it is an introduction to microservices and containers.</span></span> <span data-ttu-id="e09e0-129">UI를 디자인하고 개발하는 경우 복합 UI를 사용하는 것이 고급 기능이지만 더 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-129">A composite UI is more advanced but also requires further complexity when designing and developing the UI.</span></span> <span data-ttu-id="e09e0-130">다음으로 eShopOnContainers는 Xamarin에 기반한 기본 모바일 앱을 제공합니다. 그러면 클라이언트 C\#에서 더 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-130">Second, eShopOnContainers also provides a native mobile app based on Xamarin, which would make it more complex on the client C\# side.</span></span>

<span data-ttu-id="e09e0-131">그러나 다음 참조를 사용하여 마이크로 서비스를 기반으로 하는 복합 UI에 대해 자세히 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="e09e0-131">However, we encourage you to use the following references to learn more about composite UI based on microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="e09e0-132">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="e09e0-132">Additional resources</span></span>

-   <span data-ttu-id="e09e0-133">**ASP.NET을 사용하는 복합 UI(특정 워크샵)**
    [*http://go.particular.net/workshop-composite-ui-demo*](http://go.particular.net/workshop-composite-ui-demo)</span><span class="sxs-lookup"><span data-stu-id="e09e0-133">**Composite UI using ASP.NET (Particular’s Workshop)**
[*http://go.particular.net/workshop-composite-ui-demo*](http://go.particular.net/workshop-composite-ui-demo)</span></span>

-   <span data-ttu-id="e09e0-134">**Ruben Oostinga 마이크로 서비스 아키텍처의 모놀리식 프런트 엔드**
    [*http://blog.xebia.com/the-monolithic-frontend-in-the-microservices-architecture/*](http://blog.xebia.com/the-monolithic-frontend-in-the-microservices-architecture/)</span><span class="sxs-lookup"><span data-stu-id="e09e0-134">**Ruben Oostinga. The Monolithic Frontend in the Microservices Architecture**
[*http://blog.xebia.com/the-monolithic-frontend-in-the-microservices-architecture/*](http://blog.xebia.com/the-monolithic-frontend-in-the-microservices-architecture/)</span></span>

-   <span data-ttu-id="e09e0-135">**Mauro Servienti UI 컴포지션 개선 방법**
    [*https://particular.net/blog/secret-of-better-ui-composition*](https://particular.net/blog/secret-of-better-ui-composition)</span><span class="sxs-lookup"><span data-stu-id="e09e0-135">**Mauro Servienti. The secret of better UI composition**
[*https://particular.net/blog/secret-of-better-ui-composition*](https://particular.net/blog/secret-of-better-ui-composition)</span></span>

-   <span data-ttu-id="e09e0-136">**Viktor Farcic 마이크로 서비스에 대한 프런트 엔드 구성 요소 포함**
    [*https://technologyconversations.com/2015/08/09/including-front-end-web-components-into-microservices/*](https://technologyconversations.com/2015/08/09/including-front-end-web-components-into-microservices/)</span><span class="sxs-lookup"><span data-stu-id="e09e0-136">**Viktor Farcic. Including Front-End Web Components Into Microservices**
[*https://technologyconversations.com/2015/08/09/including-front-end-web-components-into-microservices/*](https://technologyconversations.com/2015/08/09/including-front-end-web-components-into-microservices/)</span></span>

-   <span data-ttu-id="e09e0-137">**마이크로 서비스 아키텍처에서 프런트 엔드 관리**\\</span><span class="sxs-lookup"><span data-stu-id="e09e0-137">**Managing Frontend in the Microservices Architecture**\\</span></span>
    [<span data-ttu-id="e09e0-138">*http://allegro.tech/2016/03/Managing-Frontend-in-the-microservices-architecture.html*</span><span class="sxs-lookup"><span data-stu-id="e09e0-138">*http://allegro.tech/2016/03/Managing-Frontend-in-the-microservices-architecture.html*</span></span>](http://allegro.tech/2016/03/Managing-Frontend-in-the-microservices-architecture.html)


>[!div class="step-by-step"]
<span data-ttu-id="e09e0-139">[이전](microservices-addressability-service-registry.md) [다음](resilient-high-availability-microservices.md)</span><span class="sxs-lookup"><span data-stu-id="e09e0-139">[Previous] (microservices-addressability-service-registry.md) [Next] (resilient-high-availability-microservices.md)</span></span>

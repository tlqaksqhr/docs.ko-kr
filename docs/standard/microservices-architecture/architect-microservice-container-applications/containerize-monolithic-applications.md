---
title: 모놀리식 응용 프로그램 컨테이너화
description: 컨테이너화된 .NET 응용 프로그램을 위한 .NET 마이크로 서비스 아키텍처 | 모놀리식 응용 프로그램 컨테이너화
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: 4e5b7a8202a0af26c8d61e315c3aa8f592ed45d9
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/29/2018
ms.locfileid: "37105925"
---
# <a name="containerizing-monolithic-applications"></a><span data-ttu-id="3c223-103">모놀리식 응용 프로그램 컨테이너화</span><span class="sxs-lookup"><span data-stu-id="3c223-103">Containerizing monolithic applications</span></span>

<span data-ttu-id="3c223-104">단일 모놀리식 배포 웹 응용 프로그램 또는 서비스를 빌드하고 컨테이너로 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-104">You might want to build a single, monolithically deployed web application or service and deploy it as a container.</span></span> <span data-ttu-id="3c223-105">응용 프로그램 자체는 내부적으로 모놀리식이지만 여러 라이브러리, 구성 요소, 또는 계층(응용 프로그램 계층, 도메인 계층, 데이터 액세스 계층 등)으로 구성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-105">The application itself might not be internally monolithic, but structured as several libraries, components, or even layers (application layer, domain layer, data-access layer, etc.).</span></span> <span data-ttu-id="3c223-106">그러나 외부적으로는 단일 컨테이너(단일 프로세스, 단일 웹 응용 프로그램 또는 단일 서비스)입니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-106">Externally, however, it is a single container—a single process, a single web application, or a single service.</span></span>

<span data-ttu-id="3c223-107">이 모델을 관리하려면 응용 프로그램을 나타내는 단일 컨테이너를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="3c223-108">강화하려면 부하 분산 장치 앞에 여러 복사본을 추가하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-108">To scale up, you just add more copies with a load balancer in front.</span></span> <span data-ttu-id="3c223-109">단일 컨테이너 또는 VM에서 단일 배포를 관리하면 단순성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-109">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image1.png)

<span data-ttu-id="3c223-110">**그림 4-1**</span><span class="sxs-lookup"><span data-stu-id="3c223-110">**Figure 4-1**.</span></span> <span data-ttu-id="3c223-111">컨테이너화된 모놀리식 응용 프로그램의 아키텍처 예제</span><span class="sxs-lookup"><span data-stu-id="3c223-111">Example of the architecture of a containerized monolithic application</span></span>

<span data-ttu-id="3c223-112">그림 4-1에서 보여준 대로 각 컨테이너에 여러 구성 요소, 라이브러리 또는 내부 계층이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-112">You can include multiple components, libraries, or internal layers in each container, as illustrated in Figure 4-1.</span></span> <span data-ttu-id="3c223-113">하지만 이 모놀리식 패턴은 "컨테이너는 한 가지 작업을 하나의 프로세스에서 수행합니다."라는 컨테이너 원칙과 충돌할 수 있지만 어떤 경우에는 문제가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-113">However, this monolithic pattern might conflict with the container principle “a container does one thing, and does it in one process”, but might be ok for some cases.</span></span>

<span data-ttu-id="3c223-114">이 방법의 단점은 응용 프로그램이 증가하면 분명히 크기를 조정해야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-114">The downside of this approach becomes evident if the application grows, requiring it to scale.</span></span> <span data-ttu-id="3c223-115">전체 응용 프로그램의 크기를 조정하는 경우 문제가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-115">If the entire application can scale, it is not really a problem.</span></span> <span data-ttu-id="3c223-116">그러나 대부분의 경우에 다른 구성 요소를 적게 사용하는 반면 일부 응용 프로그램은 크기 조정이 요구되는 문제 지점(choke points)에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-116">However, in most cases, just a few parts of the application are the choke points that requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="3c223-117">예를 들어 많은 고객이 제품을 구입하지 않고 찾아보기 때문에 일반적인 전자 상거래 응용 프로그램에서는 제품 정보 하위 시스템의 크기를 조정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-117">For example, in a typical e-commerce application, you likely need to scale the product information subsystem, because many more customers browse products than purchase them.</span></span> <span data-ttu-id="3c223-118">많은 고객이 결제 파이프라인을 사용하지 않고 자신의 바구니를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-118">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="3c223-119">적은 수의 고객이 주석을 추가하거나 자신의 구매 기록을 봅니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-119">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="3c223-120">또한 직원 중 소수가 콘텐츠 및 마케팅 캠페인을 관리해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-120">And you might have only a handful of employees, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="3c223-121">모놀리식 디자인을 크기를 조정하는 경우 이러한 다른 작업의 모든 코드는 여러 번 배포되고 동일한 등급으로 크기가 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-121">If you scale the monolithic design, all the code for these different tasks is deployed multiple times and scaled at the same grade.</span></span>

<span data-ttu-id="3c223-122">가로 복제, 응용 프로그램의 다양한 영역 분할 및 비즈니스 개념 또는 데이터와 유사한 분할 등 응용 프로그램의 크기를 조정하는 여러 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-122">There are multiple ways to scale an application—horizontal duplication, splitting different areas of the application, and partitioning similar business concepts or data.</span></span> <span data-ttu-id="3c223-123">하지만 모든 구성 요소의 크기를 조정하는 문제 외에도 단일 구성 요소를 변경하려면 전체 응용 프로그램을 모두 다시 테스트하고 전체 인스턴스를 모두 다시 배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-123">But, in addition to the problem of scaling all components, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="3c223-124">그러나 마이크로 서비스의 접근 방법보다 응용 프로그램 개발이 처음부터 쉽기 때문에 모놀리식 접근 방법이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-124">However, the monolithic approach is common, because the development of the application is initially easier than for microservices approaches.</span></span> <span data-ttu-id="3c223-125">따라서 대부분의 조직에서는 이 아키텍처 방법을 사용하여 개발합니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-125">Thus, many organizations develop using this architectural approach.</span></span> <span data-ttu-id="3c223-126">일부 조직의 결과는 훌륭한 반면 다른 조직은 한계에 도달했습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-126">While some organizations have had good enough results, others are hitting limits.</span></span> <span data-ttu-id="3c223-127">수 년 전에는 도구 및 인프라가 SOA(서비스 지향 아키텍처)를 빌드하기 어려웠고 필요성을 느끼지 못했기 때문에 응용 프로그램이 개발될 때까지 대부분의 조직에서는 이 모델을 사용하여 응용 프로그램을 디자인했습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-127">Many organizations designed their applications using this model because tools and infrastructure made it too difficult to build service oriented architectures (SOA) years ago, and they did not see the need—until the application grew.</span></span>

<span data-ttu-id="3c223-128">인프라 측면에서 볼 때 각 서버는 동일한 호스트 내에서 많은 응용 프로그램을 실행하고 그림 4-2에 표시된 대로 리소스 사용량에서 효율성의 허용 가능한 비율을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-128">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in resources usage, as shown in Figure 4-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="3c223-129">**그림 4-2**</span><span class="sxs-lookup"><span data-stu-id="3c223-129">**Figure 4-2**.</span></span> <span data-ttu-id="3c223-130">모놀리식 방법: 호스트에서 실행 중인 여러 앱, 컨테이너로 실행되는 각 앱</span><span class="sxs-lookup"><span data-stu-id="3c223-130">Monolithic approach: Host running multiple apps, each app running as a container</span></span>

<span data-ttu-id="3c223-131">Microsoft Azure의 모놀리식 응용 프로그램은 각 인스턴스에 전용 VM을 사용하여 배포될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-131">Monolithic applications in Microsoft Azure can be deployed using dedicated VMs for each instance.</span></span> <span data-ttu-id="3c223-132">또한 [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)를 사용하여 VM의 크기를 쉽게 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-132">Additionally, using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="3c223-133">[Azure App Service](https://azure.microsoft.com/services/app-service/)는 VM을 관리하지 않고 모놀리식 응용 프로그램을 실행하고 인스턴스의 크기를 쉽게 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-133">[Azure App Service](https://azure.microsoft.com/services/app-service/) can also run monolithic applications and easily scale instances without requiring you to manage the VMs.</span></span> <span data-ttu-id="3c223-134">2016년부터 Azure App Services는 배포를 단순화할 뿐만 아니라 Docker 컨테이너의 단일 인스턴스를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-134">Since 2016, Azure App Services can run single instances of Docker containers as well, simplifying deployment.</span></span>

<span data-ttu-id="3c223-135">그림 4-3에 표시된 대로 QA 환경 또는 제한된 프로덕션 환경으로 여러 Docker 호스트 VM을 배포하고 Azure 분산 장치를 사용하여 균형을 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-135">As a QA environment or a limited production environment, you can deploy multiple Docker host VMs and balance them using the Azure balancer, as shown in Figure 4-3.</span></span> <span data-ttu-id="3c223-136">그러면 전체 응용 프로그램이 단일 컨테이너 내에 위치하기 때문에 조립(coarse-grain) 방법으로 크기를 조정하도록 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-136">This lets you manage scaling with a coarse-grain approach, because the whole application lives within a single container.</span></span>

![](./media/image3.png)

<span data-ttu-id="3c223-137">**그림 4-3**</span><span class="sxs-lookup"><span data-stu-id="3c223-137">**Figure 4-3**.</span></span> <span data-ttu-id="3c223-138">단일 컨테이너 응용 프로그램의 크기를 조정하는 여러 호스트 예제</span><span class="sxs-lookup"><span data-stu-id="3c223-138">Example of multiple hosts scaling up a single container application</span></span>

<span data-ttu-id="3c223-139">일반적인 배포 방법으로 다양한 호스트에 대한 배포를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-139">Deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="3c223-140">`docker run` 또는 `docker-compose`와 같은 명령을 사용하거나 또는 CD(지속적인 업데이트) 파이프라인과 같은 자동화를 통해 Docker 호스트를 수동으로 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-140">Docker hosts can be managed with commands like `docker run` or `docker-compose` performed manually, or through automation such as continuous delivery (CD) pipelines.</span></span>

## <a name="deploying-a-monolithic-application-as-a-container"></a><span data-ttu-id="3c223-141">컨테이너로 모놀리식 응용 프로그램 배포</span><span class="sxs-lookup"><span data-stu-id="3c223-141">Deploying a monolithic application as a container</span></span>

<span data-ttu-id="3c223-142">단일 응용 프로그램 배포를 관리하기 위해 컨테이너를 사용하는 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-142">There are benefits to using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="3c223-143">컨테이너 인스턴스의 크기를 확장하는 것은 추가 VM을 배포하는 것보다 훨씬 쉽고 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-143">Scaling container instances is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="3c223-144">VM Scale Sets를 사용하더라도 VM을 시작하는 데 시간이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-144">Even if you use VM Scale Sets, VMs take time to start.</span></span> <span data-ttu-id="3c223-145">이상적이지 않지만 컨테이너 대신 기존 응용 프로그램 인스턴스를 배포하는 경우 응용 프로그램의 구성은 VM의 일부로 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-145">When deployed as traditional application instances instead of containers, the configuration of the application is managed as part of the VM, which is not ideal.</span></span>

<span data-ttu-id="3c223-146">Docker 이미지로 업데이트를 배포하는 것이 훨씬 더 빠르고 네트워크 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-146">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="3c223-147">Docker 이미지는 일반적으로 몇 초 내에 시작됩니다. 그러면 롤아웃 속도가 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-147">Docker images typically start in seconds, which speeds rollouts.</span></span> <span data-ttu-id="3c223-148">Docker 이미지 인스턴스를 중지하는 것은 `docker stop` 명령을 실행하는 것만큼 쉬우며 일반적으로 몇 초 내에 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-148">Tearing down a Docker image instance is as easy as issuing a `docker stop` command, and typically completes in less than a second.</span></span>

<span data-ttu-id="3c223-149">디자인에서 컨테이너를 변경할 수 없기 때문에 VM이 손상될 것을 걱정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-149">Because containers are immutable by design, you never need to worry about corrupted VMs.</span></span> <span data-ttu-id="3c223-150">반면, VM의 업데이트 스크립트는 디스크에 남아 있는 몇 가지 특정 구성 또는 파일에서 고려되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-150">In contrast, update scripts for a VM might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="3c223-151">모놀리식 응용 프로그램이 Docker를 활용할 때의 이점에 대해서만 다루었습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-151">While monolithic applications can benefit from Docker, we are touching only on the benefits.</span></span> <span data-ttu-id="3c223-152">컨테이너를 관리하는 추가 이점은 컨테이너 오케스트레이터를 사용하는 배포에서 제공됩니다. 그러면 다양한 인스턴스 및 각 컨테이너 인스턴스의 수명 주기를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-152">Additional benefits of managing containers come from deploying with container orchestrators, which manage the various instances and lifecycle of each container instance.</span></span> <span data-ttu-id="3c223-153">개별적으로 크기를 조정하고, 개발하고, 배포할 수 있는 하위 시스템으로 모놀리식 응용 프로그램을 나누는 작업은 마이크로 서비스 영역의 진입점입니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-153">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-container-based-application-to-azure-app-service"></a><span data-ttu-id="3c223-154">Azure App Service에 단일 컨테이너 기반 응용 프로그램 게시</span><span class="sxs-lookup"><span data-stu-id="3c223-154">Publishing a single-container-based application to Azure App Service</span></span>

<span data-ttu-id="3c223-155">Azure에 배포된 컨테이너의 유효성 검사를 수행하거나 응용 프로그램이 단일 컨테이너 응용 프로그램인 경우 Azure App Service를 사용하여 확장성 있는 단일 컨테이너 기반 서비스를 제공하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-155">Whether you want to get validation of a container deployed to Azure or when an application is simply a single-container application, Azure App Service provides a great way to provide scalable single-container-based services.</span></span> <span data-ttu-id="3c223-156">Azure App Service를 사용하는 방법은 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-156">Using Azure App Service is simple.</span></span> <span data-ttu-id="3c223-157">를 통해 Git와 통합하여 코드를 사용하고, Visual Studio에서 빌드하고, Azure에 직접 배포하는 작업이 용이해집니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-157">It provides great integration with Git to make it easy to take your code, build it in Visual Studio, and deploy it directly to Azure.</span></span>

![](./media/image4.png)

<span data-ttu-id="3c223-158">**그림 4-4**</span><span class="sxs-lookup"><span data-stu-id="3c223-158">**Figure 4-4**.</span></span> <span data-ttu-id="3c223-159">Visual Studio에서 Azure App Service에 단일 컨테이너 응용 프로그램 게시</span><span class="sxs-lookup"><span data-stu-id="3c223-159">Publishing a single-container application to Azure App Service from Visual Studio</span></span>

<span data-ttu-id="3c223-160">Docker 없이 Azure App Service에서 지원되지 않는 다른 기능, 프레임워크 또는 종속성이 필요한 경우 Azure 팀이 App Service에서 해당 종속성을 업데이트할 때까지 기다려야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-160">Without Docker, if you needed other capabilities, frameworks, or dependencies that are not supported in Azure App Service, you had to wait until the Azure team updated those dependencies in App Service.</span></span> <span data-ttu-id="3c223-161">또는 Azure Service Fabric, Azure Cloud Services 또는 VM과 같은 다른 서비스도 전환해야 했습니다. 여기서는 추가적으로 제어하고 응용 프로그램에 대한 필수 구성 요소 또는 프레임워크를 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-161">Or you had to switch to other services like Azure Service Fabric, Azure Cloud Services, or even VMs, where you had further control and you could install a required component or framework for your application.</span></span>

<span data-ttu-id="3c223-162">Visual Studio 2017의 컨테이너 지원은 그림 4-4에 표시된 대로 응용 프로그램 환경에서 원하는 작업이 무엇이든 포함할 수 있는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-162">Container support in Visual Studio 2017 gives you the ability to include whatever you want in your application environment, as shown in Figure 4-4.</span></span> <span data-ttu-id="3c223-163">이를 컨테이너에서 실행하므로 응용 프로그램에 종속성을 추가하는 경우 Dockerfile 또는 Docker 이미지에서 종속성을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-163">Since you are running it in a container, if you add a dependency to your application, you can include the dependency in your Dockerfile or Docker image.</span></span>

<span data-ttu-id="3c223-164">또한 그림 4-4에 표시된 대로 게시 흐름은 컨테이너 레지스트리를 통해 이미지를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-164">As also shown in Figure 4-4, the publish flow pushes an image through a container registry.</span></span> <span data-ttu-id="3c223-165">Azure Container Registry(Azure에서 배포와 가깝고 Azure Active Directory 그룹 및 계정에 의해 보호되는 레지스트리) 또는 Docker 허브 또는 온-프레미스 레지스트리와 같은 다른 Docker 레지스트리일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c223-165">This can be the Azure Container Registry (a registry close to your deployments in Azure and secured by Azure Active Directory groups and accounts), or any other Docker registry, like Docker Hub or an on-premises registry.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="3c223-166">[이전](index.md)
[다음](docker-application-state-data.md)</span><span class="sxs-lookup"><span data-stu-id="3c223-166">[Previous](index.md)
[Next](docker-application-state-data.md)</span></span>

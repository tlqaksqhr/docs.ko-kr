---
title: 마이크로 서비스에서 간소화된 CQRS 및 DDD 패턴 적용
description: 컨테이너화된 .NET 응용 프로그램을 위한 .NET 마이크로 서비스 아키텍처 | 마이크로 서비스에서 간소화된 CQRS 및 DDD 패턴 적용
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: 4e30b4755af001f85649e611c9f1f976ed294cab
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
---
# <a name="applying-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="ec5bf-103">마이크로 서비스에서 간소화된 CQRS 및 DDD 패턴 적용</span><span class="sxs-lookup"><span data-stu-id="ec5bf-103">Applying simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="ec5bf-104">CQRS는 데이터를 읽고 쓰기 위해 모델을 구분하는 아키텍처 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-104">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="ec5bf-105">관련 용어 [CQS(명령 쿼리 분리)](https://martinfowler.com/bliki/CommandQuerySeparation.html)는 원래 Bertrand Meyer가 작성한 책 *개체 지향 소프트웨어 생성*에서 정의되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-105">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="ec5bf-106">기본 개념은 시스템의 작업을 완벽히 분리된 두 가지 범주로 나눌 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-106">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

-   <span data-ttu-id="ec5bf-107">쿼리</span><span class="sxs-lookup"><span data-stu-id="ec5bf-107">Queries.</span></span> <span data-ttu-id="ec5bf-108">결과를 반환하고 시스템의 상태를 변경하지 않으며 부작용이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-108">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

-   <span data-ttu-id="ec5bf-109">명령</span><span class="sxs-lookup"><span data-stu-id="ec5bf-109">Commands.</span></span> <span data-ttu-id="ec5bf-110">시스템의 상태를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-110">These change the state of a system.</span></span>

<span data-ttu-id="ec5bf-111">CQS는 간단한 개념으로 쿼리 또는 명령인 동일한 개체 내의 메서드에 대한 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-111">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="ec5bf-112">각 메서드는 상태를 반환하거나 상태를 변경하는 작업 중 하나를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-112">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="ec5bf-113">단일 리포지토리 패턴 개체도 CQS를 따를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-113">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="ec5bf-114">CQS는 CQRS에 대한 기본 원칙으로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-114">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="ec5bf-115">[CQRS(명령 및 쿼리 책임 분리)](https://martinfowler.com/bliki/CQRS.html)는 Greg Young이 소개하고 Udi Dahan 및 다른 사용자가 전적으로 지원했습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-115">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="ec5bf-116">CQS 원칙에 기반하지만 보다 자세히 설명됩니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-116">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="ec5bf-117">명령 및 이벤트, 필요에 따라 비동기 메시지에 따라 패턴이라고 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-117">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="ec5bf-118">대부분의 경우 CQRS는 쓰기(업데이트)보다 읽기(쿼리)를 위해 다양한 물리적 데이터베이스를 보유하는 등 고급 시나리오와 관련됩니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-118">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="ec5bf-119">또한 현재 상태 데이터를 저장하는 대신 도메인 모델에 이벤트만을 저장하도록 더 진화된 CQRS 시스템은 업데이트 데이터베이스에 [ES(이벤트 소싱)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/)을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-119">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="ec5bf-120">그러나 이것은 이 가이드에서 사용한 접근 방법이 아닙니다. 명령에서 쿼리를 분리하는 작업으로 구성된 단순한 CQRS 접근 방법을 사용하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-120">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="ec5bf-121">CQRS의 분리 양상은 한 계층의 쿼리 작업 및 또 다른 계층의 명령을 그룹화하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-121">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="ec5bf-122">각 계층에는 고유한 데이터 모델(모델은 다른 데이터베이스가 아닐 수 있음)이 있고 패턴 및 기술을 고유하게 조합하여 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-122">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="ec5bf-123">무엇보다도 두 계층은 이 가이드에 사용된 예제(마이크로 서비스 순서)처럼 동일한 계층 또는 마이크로 서비스 내에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-123">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="ec5bf-124">또는 서로 영향을 주지 않고 개별적으로 확장할 수 있도록 다른 마이크로 서비스 또는 프로세스에서 구현될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-124">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="ec5bf-125">CQRS에는 읽기/쓰기 작업에 대해 두 개의 개체가 있습니다. 여기서 다른 컨텍스트에는 하나의 개체만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-125">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="ec5bf-126">비정규화된 읽기 데이터베이스가 있어야 하는 이유가 있으며 추가 고급 CQRS 문헌에 대해 알아볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-126">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="ec5bf-127">하지만 여기서는 접근 방법을 ֲ사용하지 않으며 집계와 같은 DDD 패턴에서 제약 조건을 사용하여 쿼리를 제한하는 대신 쿼리를 유연하게 만드는 것이 목적입니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-127">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="ec5bf-128">이러한 종류의 서비스 예로 eShopOnContainers 참조 응용 프로그램에서 마이크로 서비스 정렬이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-128">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="ec5bf-129">이 서비스는 간소화된 CQRS 접근 방식에 따라 마이크로 서비스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-129">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="ec5bf-130">그림9-2에서처럼 단일 데이터 원본 또는 데이터베이스를 사용하지만 패턴 트랜잭션 도메인에 대한 두 가지 논리 모델과 DDD를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-130">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 9-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="ec5bf-131">**그림9-2**</span><span class="sxs-lookup"><span data-stu-id="ec5bf-131">**Figure 9-2**.</span></span> <span data-ttu-id="ec5bf-132">간소화된 CQRS 및 DDD 기반 마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="ec5bf-132">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="ec5bf-133">응용 프로그램 계층은 Web API 자체일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-133">The application layer can be the Web API itself.</span></span> <span data-ttu-id="ec5bf-134">여기서 중요한 디자인 측면은 마이크로 서비스가 CQRS 패턴을 따라 명령, 도메인 모델 및 트랜잭션에서 쿼리 및 ViewModels(특히 클라이언트 응용 프로그램에 생성된 데이터 모델)을 분할한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-134">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="ec5bf-135">이 방법은 뒤의 섹션에 설명된 대로 트랜잭션 및 업데이트에 대해서만 의미가 있는 DDD 패턴에서 들어오는 제한 사항 및 제약 조건과 독립된 쿼리를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="ec5bf-135">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="ec5bf-136">[이전] (index.md) [다음] (eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="ec5bf-136">[Previous] (index.md) [Next] (eshoponcontainers-cqrs-ddd-microservice.md)</span></span>

---
title: "컬렉션에 대한 지침"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
caps.latest.revision: "4"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 9eea60dafef508748df53e23c211f5778250e7f2
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="guidelines-for-collections"></a><span data-ttu-id="5f5b5-102">컬렉션에 대한 지침</span><span class="sxs-lookup"><span data-stu-id="5f5b5-102">Guidelines for Collections</span></span>
<span data-ttu-id="5f5b5-103">일부 일반적인 특성에 포함 된 개체의 그룹을 조작 하도록 특별히 설계 된 모든 형식은 컬렉션을 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-103">Any type designed specifically to manipulate a group of objects having some common characteristic can be considered a collection.</span></span> <span data-ttu-id="5f5b5-104">구현 하는 이러한 형식에 대 한 적절 한 것은 항상 <xref:System.Collections.IEnumerable> 또는 <xref:System.Collections.Generic.IEnumerable%601>이므로이 섹션의만 이라고 생각 컬렉션 수를 하나 또는 둘 다 인터페이스를 구현 하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-104">It is almost always appropriate for such types to implement <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>, so in this section we only consider types implementing one or both of those interfaces to be collections.</span></span>  
  
 <span data-ttu-id="5f5b5-105">**X 하지 않으면** 공용 Api에서 약한 형식의 컬렉션을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-105">**X DO NOT** use weakly typed collections in public APIs.</span></span>  
  
 <span data-ttu-id="5f5b5-106">모든 컬렉션 항목을 나타내는 매개 변수 및 반환 값의 형식을 해당 형식의 기본 형식 (컬렉션의 공용 멤버에만 적용)는 정확한 항목 유형, 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-106">The type of all return values and parameters representing collection items should be the exact item type, not any of its base types (this applies only to public members of the collection).</span></span>  
  
 <span data-ttu-id="5f5b5-107">**X 하지 않으면** 사용 <xref:System.Collections.ArrayList> 또는 <xref:System.Collections.Generic.List%601> 공용 Api에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-107">**X DO NOT** use <xref:System.Collections.ArrayList> or <xref:System.Collections.Generic.List%601> in public APIs.</span></span>  
  
 <span data-ttu-id="5f5b5-108">이러한 형식은 데이터 구조 공용 Api에 없는 내부 구현에 사용할 수 있도록 설계 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-108">These types are data structures designed to be used in internal implementation, not in public APIs.</span></span> <span data-ttu-id="5f5b5-109">`List<T>`성능 및 유연성과 Api cleanness 대신 전원에 대해 최적화 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-109">`List<T>` is optimized for performance and power at the cost of cleanness of the APIs and flexibility.</span></span> <span data-ttu-id="5f5b5-110">예를 들어, 반환 하는 경우 `List<T>`, 현재까지 됩니다 클라이언트 코드에서 컬렉션을 수정할 때 알림을 받을 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-110">For example, if you return `List<T>`, you will not ever be able to receive notifications when client code modifies the collection.</span></span> <span data-ttu-id="5f5b5-111">또한 `List<T>` 와 같은 많은 멤버를 노출 <xref:System.Collections.Generic.List%601.BinarySearch%2A>, 되지 않은 유용 하거나 다양 한 시나리오에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-111">Also, `List<T>` exposes many members, such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>, that are not useful or applicable in many scenarios.</span></span> <span data-ttu-id="5f5b5-112">다음 두 섹션에서는 형식 (추상화) 공용 Api에서 사용 하도록 특별히 설계에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-112">The following two sections describe types (abstractions) designed specifically for use in public APIs.</span></span>  
  
 <span data-ttu-id="5f5b5-113">**X 하지 않으면** 사용 `Hashtable` 또는 `Dictionary<TKey,TValue>` 공용 Api에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-113">**X DO NOT** use `Hashtable` or `Dictionary<TKey,TValue>` in public APIs.</span></span>  
  
 <span data-ttu-id="5f5b5-114">이러한 형식은 데이터 구조 내부 구현에 사용할 수 있도록 설계 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-114">These types are data structures designed to be used in internal implementation.</span></span> <span data-ttu-id="5f5b5-115">공용 Api를 사용 해야 <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, 또는 인터페이스 중 하나 또는 모두를 구현 하는 사용자 지정 형식을 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-115">Public APIs should use <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, or a custom type implementing one or both of the interfaces.</span></span>  
  
 <span data-ttu-id="5f5b5-116">**X 하지 않으면** 사용 <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, 또는 다른 종류의 반환 형식으로 제외 하 고 이러한 인터페이스를 구현 하는 `GetEnumerator` 메서드.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-116">**X DO NOT** use <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, or any other type that implements either of these interfaces, except as the return type of a `GetEnumerator` method.</span></span>  
  
 <span data-ttu-id="5f5b5-117">이외의 다른 방법 중에서 열거자를 반환 하는 형식 `GetEnumerator` 함께 사용할 수 없습니다는 `foreach` 문.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-117">Types returning enumerators from methods other than `GetEnumerator` cannot be used with the `foreach` statement.</span></span>  
  
 <span data-ttu-id="5f5b5-118">**X 하지 않으면** 둘 다 구현 `IEnumerator<T>` 및 `IEnumerable<T>` 을 같은 형식의 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-118">**X DO NOT** implement both `IEnumerator<T>` and `IEnumerable<T>` on the same type.</span></span> <span data-ttu-id="5f5b5-119">제네릭이 아닌 인터페이스에 적용 되는 동일한 `IEnumerator` 및 `IEnumerable`합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-119">The same applies to the nongeneric interfaces `IEnumerator` and `IEnumerable`.</span></span>  
  
## <a name="collection-parameters"></a><span data-ttu-id="5f5b5-120">컬렉션 매개 변수</span><span class="sxs-lookup"><span data-stu-id="5f5b5-120">Collection Parameters</span></span>  
 <span data-ttu-id="5f5b5-121">**✓ 않습니다** 는 최소 특수 형식 가능한 매개 변수 형식으로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-121">**✓ DO** use the least-specialized type possible as a parameter type.</span></span> <span data-ttu-id="5f5b5-122">매개 변수를 사용 하 여 컬렉션을 수행 합니다. 대부분의 멤버는 `IEnumerable<T>` 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-122">Most members taking collections as parameters use the `IEnumerable<T>` interface.</span></span>  
  
 <span data-ttu-id="5f5b5-123">**하지 말고 X** 를 사용 하 여 <xref:System.Collections.Generic.ICollection%601> 또는 <xref:System.Collections.ICollection> 액세스를 매개 변수로 `Count` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-123">**X AVOID** using <xref:System.Collections.Generic.ICollection%601> or <xref:System.Collections.ICollection> as a parameter just to access the `Count` property.</span></span>  
  
 <span data-ttu-id="5f5b5-124">대신 사용을 고려 `IEnumerable<T>` 또는 `IEnumerable` 동적으로 개체를 구현 하는지 확인 하 고 `ICollection<T>` 또는 `ICollection`합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-124">Instead, consider using `IEnumerable<T>` or `IEnumerable` and dynamically checking whether the object implements `ICollection<T>` or `ICollection`.</span></span>  
  
## <a name="collection-properties-and-return-values"></a><span data-ttu-id="5f5b5-125">컬렉션의 속성 및 반환 값</span><span class="sxs-lookup"><span data-stu-id="5f5b5-125">Collection Properties and Return Values</span></span>  
 <span data-ttu-id="5f5b5-126">**X 하지 않으면** 설정 가능한 컬렉션 속성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-126">**X DO NOT** provide settable collection properties.</span></span>  
  
 <span data-ttu-id="5f5b5-127">컬렉션을 먼저 선택 취소 한 다음 새 콘텐츠를 추가 하 여 컬렉션의 내용을 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-127">Users can replace the contents of the collection by clearing the collection first and then adding the new contents.</span></span> <span data-ttu-id="5f5b5-128">전체 컬렉션을 대체 일반적인 시나리오는 경우에 제공 하 여는 `AddRange` 메서드 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-128">If replacing the whole collection is a common scenario, consider providing the `AddRange` method on the collection.</span></span>  
  
 <span data-ttu-id="5f5b5-129">**✓ 않습니다** 사용 `Collection<T>` 또는 하위 클래스 `Collection<T>` 속성 또는 반환 값 나타내는 읽기/쓰기 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-129">**✓ DO** use `Collection<T>` or a subclass of `Collection<T>` for properties or return values representing read/write collections.</span></span>  
  
 <span data-ttu-id="5f5b5-130">경우 `Collection<T>` 몇 가지 요구 사항을 충족 하지 않습니다 (예: 컬렉션은 구현 하지 해야 <xref:System.Collections.IList>)를 구현 하 여 사용자 지정 컬렉션을 사용 하 여 `IEnumerable<T>`, `ICollection<T>`, 또는 <xref:System.Collections.Generic.IList%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-130">If `Collection<T>` does not meet some requirement (e.g., the collection must not implement <xref:System.Collections.IList>), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or <xref:System.Collections.Generic.IList%601>.</span></span>  
  
 <span data-ttu-id="5f5b5-131">**✓ 수행** 사용 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>의 서브 클래스 `ReadOnlyCollection<T>`, 또는 드물지만에서 `IEnumerable<T>` 속성 또는 반환 값을 나타내는 읽기 전용 컬렉션에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-131">**✓ DO** use <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, a subclass of `ReadOnlyCollection<T>`, or in rare cases `IEnumerable<T>` for properties or return values representing read-only collections.</span></span>  
  
 <span data-ttu-id="5f5b5-132">일반적으로 선호 `ReadOnlyCollection<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-132">In general, prefer `ReadOnlyCollection<T>`.</span></span> <span data-ttu-id="5f5b5-133">몇 가지 요구 사항을 충족 하지 않는 경우 (예: 컬렉션은 구현 하지 해야 `IList`)를 구현 하 여 사용자 지정 컬렉션을 사용 하 여 `IEnumerable<T>`, `ICollection<T>`, 또는 `IList<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-133">If it does not meet some requirement (e.g., the collection must not implement `IList`), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or `IList<T>`.</span></span> <span data-ttu-id="5f5b5-134">읽기 전용 컬렉션을 사용자 지정을 구현 하는 경우 구현 `ICollection<T>.ReadOnly` false를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-134">If you do implement a custom read-only collection, implement `ICollection<T>.ReadOnly` to return false.</span></span>  
  
 <span data-ttu-id="5f5b5-135">경우에만 지원 하려는 앞 으로만 이동 가능한 반복 인지는 경우에 사용 하면 `IEnumerable<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-135">In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use `IEnumerable<T>`.</span></span>  
  
 <span data-ttu-id="5f5b5-136">**✓ 고려** 제네릭 기본 컬렉션의 하위 클래스를 사용 하 여 컬렉션을 직접 사용 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-136">**✓ CONSIDER** using subclasses of generic base collections instead of using the collections directly.</span></span>  
  
 <span data-ttu-id="5f5b5-137">이렇게 하면 더 나은 이름일 고 기본 컬렉션 형식에 존재 하지 않는 도우미 구성원을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-137">This allows for a better name and for adding helper members that are not present on the base collection types.</span></span> <span data-ttu-id="5f5b5-138">이 높은 수준의 Api에 특히 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-138">This is especially applicable to high-level APIs.</span></span>  
  
 <span data-ttu-id="5f5b5-139">**✓ 고려** 의 서브 클래스를 반환 `Collection<T>` 또는 `ReadOnlyCollection<T>` 에서 매우 흔히 사용 되는 메서드 및 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-139">**✓ CONSIDER** returning a subclass of `Collection<T>` or `ReadOnlyCollection<T>` from very commonly used methods and properties.</span></span>  
  
 <span data-ttu-id="5f5b5-140">이렇게 하면 더욱 도우미 메서드를 추가 하거나 컬렉션 구현을 나중에 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-140">This will make it possible for you to add helper methods or change the collection implementation in the future.</span></span>  
  
 <span data-ttu-id="5f5b5-141">**✓ 고려** 컬렉션에 저장 된 항목에는 고유 키가 있는 경우 키 컬렉션을 사용 하 여 (이름, Id 등.).</span><span class="sxs-lookup"><span data-stu-id="5f5b5-141">**✓ CONSIDER** using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.).</span></span> <span data-ttu-id="5f5b5-142">키가 지정 된 컬렉션은 정수과 키로 인덱싱할 수 및에서 상속 하 여 일반적으로 구현 되는 컬렉션 `KeyedCollection<TKey,TItem>`합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-142">Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from `KeyedCollection<TKey,TItem>`.</span></span>  
  
 <span data-ttu-id="5f5b5-143">키 컬렉션 일반적으로 더 큰 메모리 용량 있고 메모리 오버 헤드는 키를 갖는 것의 이점 보다 중요 한 경우 사용 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-143">Keyed collections usually have larger memory footprints and should not be used if the memory overhead outweighs the benefits of having the keys.</span></span>  
  
 <span data-ttu-id="5f5b5-144">**X 하지 않으면** 컬렉션 속성에서 또는 컬렉션을 반환 하는 방법 중에서 null 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-144">**X DO NOT** return null values from collection properties or from methods returning collections.</span></span> <span data-ttu-id="5f5b5-145">빈 컬렉션 이거나 빈 배열 대신 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-145">Return an empty collection or an empty array instead.</span></span>  
  
 <span data-ttu-id="5f5b5-146">Null 및 빈 (0 항목) 컬렉션 또는 배열과 되어야 함을 일반적인 규칙은 동일 하 게 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-146">The general rule is that null and empty (0 item) collections or arrays should be treated the same.</span></span>  
  
### <a name="snapshots-versus-live-collections"></a><span data-ttu-id="5f5b5-147">스냅숏을 라이브 컬렉션 비교</span><span class="sxs-lookup"><span data-stu-id="5f5b5-147">Snapshots Versus Live Collections</span></span>  
 <span data-ttu-id="5f5b5-148">컬렉션의에서 특정 시점에 상태를 나타내는 스냅숏 컬렉션 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-148">Collections representing a state at some point in time are called snapshot collections.</span></span> <span data-ttu-id="5f5b5-149">예를 들어 데이터베이스 쿼리에서 반환 된 행을 포함 하는 컬렉션 스냅숏을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-149">For example, a collection containing rows returned from a database query would be a snapshot.</span></span> <span data-ttu-id="5f5b5-150">항상 현재 상태를 나타내는 컬렉션 라이브 컬렉션 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-150">Collections that always represent the current state are called live collections.</span></span> <span data-ttu-id="5f5b5-151">예를 들어 컬렉션의 `ComboBox` 항목은 라이브 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-151">For example, a collection of `ComboBox` items is a live collection.</span></span>  
  
 <span data-ttu-id="5f5b5-152">**X 하지 않으면** 속성에서 스냅숏 컬렉션을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-152">**X DO NOT** return snapshot collections from properties.</span></span> <span data-ttu-id="5f5b5-153">속성 라이브 컬렉션을 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-153">Properties should return live collections.</span></span>  
  
 <span data-ttu-id="5f5b5-154">속성 getter 매우 간단한 작업 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-154">Property getters should be very lightweight operations.</span></span> <span data-ttu-id="5f5b5-155">o (n) 작업에서 내부 컬렉션의 복사본을 만드는 필요 스냅숏을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-155">Returning a snapshot requires creating a copy of an internal collection in an O(n) operation.</span></span>  
  
 <span data-ttu-id="5f5b5-156">**✓ 않습니다** 스냅숏 컬렉션 또는 라이브를 사용 하 여 `IEnumerable<T>` (또는 해당 하위 유형)을 휘발성 하는 컬렉션을 나타내는 (즉, 하는 변경할 수 명시적으로 컬렉션을 수정 하지 않고).</span><span class="sxs-lookup"><span data-stu-id="5f5b5-156">**✓ DO** use either a snapshot collection or a live `IEnumerable<T>` (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection).</span></span>  
  
 <span data-ttu-id="5f5b5-157">일반적으로 공유 리소스 (예: 디렉터리의 파일)를 나타내는 모든 컬렉션은 일시적입니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-157">In general, all collections representing a shared resource (e.g., files in a directory) are volatile.</span></span> <span data-ttu-id="5f5b5-158">이러한 컬렉션 매우 어렵거나 구현에서 앞 으로만 이동 가능한 열거자 단순히 아닌 경우 라이브 컬렉션으로 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-158">Such collections are very difficult or impossible to implement as live collections unless the implementation is simply a forward-only enumerator.</span></span>  
  
## <a name="choosing-between-arrays-and-collections"></a><span data-ttu-id="5f5b5-159">배열 및 컬렉션 중에서 선택</span><span class="sxs-lookup"><span data-stu-id="5f5b5-159">Choosing Between Arrays and Collections</span></span>  
 <span data-ttu-id="5f5b5-160">**✓ 않습니다** 배열을 통해 컬렉션을 선호 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-160">**✓ DO** prefer collections over arrays.</span></span>  
  
 <span data-ttu-id="5f5b5-161">컬렉션 내용 보다 잘 제어할 시간이 지남에 따라 확장할 수 및 더 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-161">Collections provide more control over contents, can evolve over time, and are more usable.</span></span> <span data-ttu-id="5f5b5-162">또한 배열을 사용 하 여 읽기 전용 시나리오에 대 한 것이 좋습니다 배열을 복제 비용은 제한 된다는 가정 하기 때문에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-162">In addition, using arrays for read-only scenarios is discouraged because the cost of cloning the array is prohibitive.</span></span> <span data-ttu-id="5f5b5-163">유용성 연구 일부 개발자 컬렉션 기반 Api를 사용 하 여 더 잘 알고 있는지 설명 했습니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-163">Usability studies have shown that some developers feel more comfortable using collection-based APIs.</span></span>  
  
 <span data-ttu-id="5f5b5-164">그러나, 낮은 수준의 Api 개발 하는 경우 읽기 / 쓰기 시나리오에 대 한 배열을 사용 하 여 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-164">However, if you are developing low-level APIs, it might be better to use arrays for read-write scenarios.</span></span> <span data-ttu-id="5f5b5-165">배열 있으며 작업 집합을 줄일 수는 작은 메모리 사용 공간을 있고 런타임에서 최적화 되기 때문에 배열의 요소에 대 한 액세스 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-165">Arrays have a smaller memory footprint, which helps reduce the working set, and access to elements in an array is faster because it is optimized by the runtime.</span></span>  
  
 <span data-ttu-id="5f5b5-166">**✓ 고려** 메모리 소비를 최소화 하 고 성능을 최대화 하려면 배열 낮은 수준의 Api에서 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-166">**✓ CONSIDER** using arrays in low-level APIs to minimize memory consumption and maximize performance.</span></span>  
  
 <span data-ttu-id="5f5b5-167">**✓ 않습니다** 바이트 배열 바이트의 컬렉션 대신 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-167">**✓ DO** use byte arrays instead of collections of bytes.</span></span>  
  
 <span data-ttu-id="5f5b5-168">**X 하지 않으면** 속성 getter 속성을 호출할 때마다 새 배열 (예: 내부 배열 복사본)을 반환 해야 하는 경우 속성에 대 한 배열을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-168">**X DO NOT** use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called.</span></span>  
  
## <a name="implementing-custom-collections"></a><span data-ttu-id="5f5b5-169">사용자 지정 컬렉션을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-169">Implementing Custom Collections</span></span>  
 <span data-ttu-id="5f5b5-170">**✓ 고려** 에서 상속 `Collection<T>`, `ReadOnlyCollection<T>`, 또는 `KeyedCollection<TKey,TItem>` 새 컬렉션을 디자인 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-170">**✓ CONSIDER** inheriting from `Collection<T>`, `ReadOnlyCollection<T>`, or `KeyedCollection<TKey,TItem>` when designing new collections.</span></span>  
  
 <span data-ttu-id="5f5b5-171">**✓ 않습니다** 구현 `IEnumerable<T>` 새 컬렉션을 디자인 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-171">**✓ DO** implement `IEnumerable<T>` when designing new collections.</span></span> <span data-ttu-id="5f5b5-172">구현 하는 것이 좋습니다. `ICollection<T>` 또는 심지어 `IList<T>` 것이 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-172">Consider implementing `ICollection<T>` or even `IList<T>` where it makes sense.</span></span>  
  
 <span data-ttu-id="5f5b5-173">이러한 사용자 지정 컬렉션을 구현할 때에서 설정한 API 패턴을 따를 `Collection<T>` 및 `ReadOnlyCollection<T>` 최대한 근접 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-173">When implementing such custom collection, follow the API pattern established by `Collection<T>` and `ReadOnlyCollection<T>` as closely as possible.</span></span> <span data-ttu-id="5f5b5-174">즉, 동일한 멤버를 명시적으로 구현, 및 등이 두 컬렉션 이름 같은 매개 변수 이름을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-174">That is, implement the same members explicitly, name the parameters like these two collections name them, and so on.</span></span>  
  
 <span data-ttu-id="5f5b5-175">**✓ 고려** 제네릭이 아닌 컬렉션 인터페이스를 구현 (`IList` 및 `ICollection`) 컬렉션 입력으로 이러한 인터페이스를 라인 Api에 전달 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-175">**✓ CONSIDER** implementing nongeneric collection interfaces (`IList` and `ICollection`) if the collection will often be passed to APIs taking these interfaces as input.</span></span>  
  
 <span data-ttu-id="5f5b5-176">**하지 말고 X** 관련 되지 않은 컬렉션의 개념을 복잡 한 Api와 형식에 컬렉션 인터페이스를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-176">**X AVOID** implementing collection interfaces on types with complex APIs unrelated to the concept of a collection.</span></span>  
  
 <span data-ttu-id="5f5b5-177">**X 하지 않으면** 와 같은 제네릭이 아닌 기본 컬렉션에서 상속할 `CollectionBase`합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-177">**X DO NOT** inherit from nongeneric base collections such as `CollectionBase`.</span></span> <span data-ttu-id="5f5b5-178">사용 하 여 `Collection<T>`, `ReadOnlyCollection<T>`, 및 `KeyedCollection<TKey,TItem>` 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-178">Use `Collection<T>`, `ReadOnlyCollection<T>`, and `KeyedCollection<TKey,TItem>` instead.</span></span>  
  
### <a name="naming-custom-collections"></a><span data-ttu-id="5f5b5-179">사용자 지정 컬렉션 이름 지정</span><span class="sxs-lookup"><span data-stu-id="5f5b5-179">Naming Custom Collections</span></span>  
 <span data-ttu-id="5f5b5-180">컬렉션 (구현 하는 형식은 `IEnumerable`) 주로 두 가지 이유로 생성 됩니다: (1) 구조를 만들려면 새 데이터 구조 관련 작업 그리고 자주 기존 데이터 구조 보다 다양 한 성능 특성 (예: <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), 및 (2) 항목의 특정 집합을 보관 하기 위한 특수 한 컬렉션을 만듭니다 (예: <xref:System.Collections.Specialized.StringCollection>).</span><span class="sxs-lookup"><span data-stu-id="5f5b5-180">Collections (types that implement `IEnumerable`) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <xref:System.Collections.Specialized.StringCollection>).</span></span> <span data-ttu-id="5f5b5-181">데이터 구조는 응용 프로그램 및 라이브러리의 내부 구현에서 가장 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-181">Data structures are most often used in the internal implementation of applications and libraries.</span></span> <span data-ttu-id="5f5b5-182">특수 컬렉션은 주로 (속성 및 매개 변수 형식)와 Api에 노출 될를 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-182">Specialized collections are mainly to be exposed in APIs (as property and parameter types).</span></span>  
  
 <span data-ttu-id="5f5b5-183">**✓ 않습니다** 의 추상화를 구현 하는 이름에 "사전" 접미사를 사용 하 여 `IDictionary` 또는 `IDictionary<TKey,TValue>`합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-183">**✓ DO** use the "Dictionary" suffix in names of abstractions implementing `IDictionary` or `IDictionary<TKey,TValue>`.</span></span>  
  
 <span data-ttu-id="5f5b5-184">**✓ 않습니다** 구현 하는 형식 이름에 "Collection" 접미사 사용 `IEnumerable` (또는 해당 하위 항목의) 및 항목 목록을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-184">**✓ DO** use the "Collection" suffix in names of types implementing `IEnumerable` (or any of its descendants) and representing a list of items.</span></span>  
  
 <span data-ttu-id="5f5b5-185">**✓ 않습니다** 사용자 지정 데이터 구조에 대 한 적절 한 데이터 구조 이름을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-185">**✓ DO** use the appropriate data structure name for custom data structures.</span></span>  
  
 <span data-ttu-id="5f5b5-186">**하지 말고 X** 컬렉션 추상화의 이름에 "LinkedList" 또는 "Hashtable" 등의 특정 구현 암시 모든 접미사를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-186">**X AVOID** using any suffixes implying particular implementation, such as "LinkedList" or "Hashtable," in names of collection abstractions.</span></span>  
  
 <span data-ttu-id="5f5b5-187">**✓ 고려** 항목 형식의 이름이 포함 된 컬렉션 이름을 접두사로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-187">**✓ CONSIDER** prefixing collection names with the name of the item type.</span></span> <span data-ttu-id="5f5b5-188">예를 들어 형식의 항목을 저장 하는 컬렉션 `Address` (구현 `IEnumerable<Address>`) 명명할 `AddressCollection`합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-188">For example, a collection storing items of type `Address` (implementing `IEnumerable<Address>`) should be named `AddressCollection`.</span></span> <span data-ttu-id="5f5b5-189">접두사 "I" 항목 형식이 인터페이스인 경우 항목의 종류를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-189">If the item type is an interface, the "I" prefix of the item type can be omitted.</span></span> <span data-ttu-id="5f5b5-190">따라서 컬렉션 <xref:System.IDisposable> 항목을 호출할 수 있습니다 `DisposableCollection`합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-190">Thus, a collection of <xref:System.IDisposable> items can be called `DisposableCollection`.</span></span>  
  
 <span data-ttu-id="5f5b5-191">**✓ 고려** 해당 쓰기 가능한 컬렉션 추가 될 수 있는 프레임 워크에 이미 있는 경우 읽기 전용 컬렉션의 이름에 "ReadOnly" 접두사를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-191">**✓ CONSIDER** using the "ReadOnly" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework.</span></span>  
  
 <span data-ttu-id="5f5b5-192">문자열의 읽기 전용 컬렉션을 호출 해야 하는 예를 들어 `ReadOnlyStringCollection`합니다.</span><span class="sxs-lookup"><span data-stu-id="5f5b5-192">For example, a read-only collection of strings should be called `ReadOnlyStringCollection`.</span></span>  
  
 <span data-ttu-id="5f5b5-193">*일부 © 2005, 2009 Microsoft Corporation. 모든 권리 보유.*</span><span class="sxs-lookup"><span data-stu-id="5f5b5-193">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>  
  
 <span data-ttu-id="5f5b5-194">*피어슨 교육, Inc.에서의 사용 권한으로 재인쇄 [Framework 디자인 지침: 규칙, 특징 및 다시 사용할 수 있는.NET 라이브러리를 2nd Edition에 대 한 패턴](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina 및 Brad Abrams 게시 하 여 2008 년 10 월 22 일 Microsoft Windows 개발 시리즈의 일부로: Addison Wesley Professional.*</span><span class="sxs-lookup"><span data-stu-id="5f5b5-194">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5f5b5-195">참고 항목</span><span class="sxs-lookup"><span data-stu-id="5f5b5-195">See Also</span></span>  
 [<span data-ttu-id="5f5b5-196">프레임워크 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="5f5b5-196">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)  
 [<span data-ttu-id="5f5b5-197">사용 지침</span><span class="sxs-lookup"><span data-stu-id="5f5b5-197">Usage Guidelines</span></span>](../../../docs/standard/design-guidelines/usage-guidelines.md)

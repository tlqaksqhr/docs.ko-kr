---
title: "정규식 동작 정보"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
caps.latest.revision: "27"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: ac5ddfb0ac7ae83537717e9bd0cd46eb629641fe
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/18/2017
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="3bdac-102">정규식 동작 정보</span><span class="sxs-lookup"><span data-stu-id="3bdac-102">Details of Regular Expression Behavior</span></span>
<span data-ttu-id="3bdac-103">.NET Framework 정규식 엔진이 역 추적 정규식 검색 도구 Perl, Python, Emacs, 및 Tcl에서 사용 하는 것과 같은 기존 비결 정적 유한 NFA () 엔진을 통합 하는입니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="3bdac-104">이를 통해 해당 awk, egrep 또는 lex와 같은 빠르지만 제한적인 순수 정규식 DFA(Deterministic Finite Automaton) 엔진과 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="3bdac-105">또한 표준화되지만 느린 POSIX NFA과도 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="3bdac-106">다음 섹션에서는 세 가지 유형의 정규식 엔진 및 기존 NFA 엔진을 사용 하 여.NET Framework의 정규식은 구현 하는 이유를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>  
  
## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="3bdac-107">NFA 엔진의 이점</span><span class="sxs-lookup"><span data-stu-id="3bdac-107">Benefits of the NFA Engine</span></span>  
 <span data-ttu-id="3bdac-108">DFA 엔진에서 패턴 일치를 수행하는 경우 해당 처리 순서는 입력 문자열에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="3bdac-109">엔진은 입력 문자열의 처음부터 시작해서 순차적으로 다음 문자가 정규식 패턴과 일치하는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="3bdac-110">가능한 가장 긴 문자열을 찾도록 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="3bdac-111">동일한 문자를 두 번 테스트하지 않기 때문에 DFA 엔진은 역추적을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="3bdac-112">그러나 DFA 엔진에 유한 상태만 포함되기 때문에 역참조를 사용하는 패턴과 일치하지 않으며 명시적 확장을 생성하지 않기 때문에 하위 식을 캡처할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>  
  
 <span data-ttu-id="3bdac-113">DFA 엔진과 달리 기존의 NFA 엔진이 패턴 일치를 수행할 경우 해당 처리 순서는 정규식 패턴에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="3bdac-114">특정 언어 요소를 처리하는 경우와 같이 엔진은 탐욕적 일치를 사용합니다. 즉, 가능한 한 입력 문자열의 수만큼 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="3bdac-115">하지만 성공적으로 하위 식을 찾은 후에 해당 상태를 저장하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="3bdac-116">일치에 결국 실패하면 엔진이 추가 일치를 시도할 수 있도록 저장된 상태로 돌아갈 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="3bdac-117">정규식에서 언어 요소 또한 일치 시킬 수 있도록 성공적인 하위 식 일치를 포기 하는이 과정 라고 *역 추적*합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="3bdac-118">NFA 엔진은 역추적을 사용하여 특정 순서에 따라 정규식에서 가능한 모든 확장을 테스트하고 첫 번째 일치 항목을 수락합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="3bdac-119">기존의 NFA 엔진이 성공적으로 일치를 수행하기 위해 정규식의 특정 확장을 구성하기 때문에 하위 식 일치 및 일치 역참조를 캡처할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="3bdac-120">그러나 기존의 NFA가 역추적하기 때문에 다른 경로를 통해 그 상태가 된 경우 여러 번 동일한 상태가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="3bdac-121">결과적으로 최악의 경우 상당히 느리게 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="3bdac-122">기존 NFA 엔진이 발견한 첫 번째 이치를 수용하기 때문에 다른 일치 항목(더 긴 일치일 가능성이 높음)도 밝히지 않은 상태로 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>  
  
 <span data-ttu-id="3bdac-123">POSIX NFA 엔진은 가장 긴 일치 항목을 발견했다고 보장할 수 있을 때까지 역추적을 계속한다는 점을 제외하면 기존의 NFA 엔진과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="3bdac-124">결과적으로 POSIX NFA 엔진은 기존 NFA 엔진보다 느립니다. 따라서 POSIX NFA 엔진을 사용하는 경우 역추적 검사의 순서를 변경하여 긴 일치 항목보다 짧은 일치 항목을 우선할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>  
  
 <span data-ttu-id="3bdac-125">기존의 NFA 엔진은 DFA 또는 POSIX NFA 엔진보다 일치하는 문자열을 효율적으로 제어하기 때문에 프로그래머로부터 선호되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="3bdac-126">최악의 경우 실행 속도가 느려질 수 있지만 모호성을 줄이고 역추적을 제한하는 패턴을 사용하여 선형 또는 다항 시간에서 일치 항목을 찾도록 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="3bdac-127">즉, NFA 엔진은 강력함과 유연성을 제공하는 대신 성능이 떨어지지만 대부분의 경우에 정규식을 잘 작성하여 역추적이 성능을 기하급수적으로 저하시키지 않도록 방지한다면 사용 가능한 적절한 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3bdac-128">해결 하려면 과도 한 역 추적 및을 정규식을 만드는 방법으로 인 한 성능 저하에 대 한 정보를 참조 하십시오. [역 추적](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="3bdac-129">.NET Framework 엔진 기능</span><span class="sxs-lookup"><span data-stu-id="3bdac-129">.NET Framework Engine Capabilities</span></span>  
 <span data-ttu-id="3bdac-130">기존 NFA 엔진의 이점을 활용 하려면.NET Framework 정규식 엔진에는 프로그래머가 역행 검사 엔진을 조정할 수 있도록 구문에 대 한 전체 집합이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="3bdac-131">이러한 구문을 사용하여 일치 항목을 빠르게 찾거나 다른 일치 항목에 대한 특정 확장을 우선할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>  
  
 <span data-ttu-id="3bdac-132">.NET Framework 정규식 엔진의 다른 기능 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-132">Other features of the .NET Framework regular expression engine include the following:</span></span>  
  
-   <span data-ttu-id="3bdac-133">최소 일치 수량자: `??`, `*?`, `+?`, `{`  *n*  `,` *m*`}?`합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="3bdac-134">이러한 구문은 역추적 엔진이 최소 반복 횟수를 먼저 검색하도록 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="3bdac-135">반면, 일반적인 탐욕적 수량자는 먼저 최대 반복 횟수를 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="3bdac-136">다음 예제에서는 둘 사이의 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="3bdac-137">정규식은 숫자로 끝나는 문장을 찾고 캡처링 그룹은 해당 숫자를 추출하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="3bdac-138">정규식 `.+(\d+)\.`은 탐욕적 수량자 `.+`를 포함하며 이로 인해 정규식 엔진은 번호의 마지막 숫자만 캡처하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="3bdac-139">반대로 정규식 `.+?(\d+)\.`은 게으른 수량자 `.+?`를 포함하며 이로 인해 정규식 엔진은 전체 번호를 캡처하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]  
  
     <span data-ttu-id="3bdac-140">이 정규식의 최대 버전과 최소 다음 표와 같이 정의 됩니다.'</span><span class="sxs-lookup"><span data-stu-id="3bdac-140">The greedy and lazy versions of this regular expression are defined as shown in the following table.\`</span></span>  
  
    |<span data-ttu-id="3bdac-141">패턴</span><span class="sxs-lookup"><span data-stu-id="3bdac-141">Pattern</span></span>|<span data-ttu-id="3bdac-142">설명</span><span class="sxs-lookup"><span data-stu-id="3bdac-142">Description</span></span>|  
    |-------------|-----------------|  
    |<span data-ttu-id="3bdac-143">`.+`(탐욕적 수량자)</span><span class="sxs-lookup"><span data-stu-id="3bdac-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="3bdac-144">적어도 한 번 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="3bdac-145">그러면 정규식 엔진이 전체 문자열을 검색하고 필요한 패턴의 나머지 부분을 찾는 데 필요한 역추적을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|  
    |<span data-ttu-id="3bdac-146">`.+?`(게으른 수량자)</span><span class="sxs-lookup"><span data-stu-id="3bdac-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="3bdac-147">적어도 한 번 문자를 찾지만 가능한 한 적게 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|  
    |`(\d+)`|<span data-ttu-id="3bdac-148">적어도 하나의 숫자 문자를 찾아 첫 번째 캡처링 그룹에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|  
    |`\.`|<span data-ttu-id="3bdac-149">마침표를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-149">Match a period.</span></span>|  
  
     <span data-ttu-id="3bdac-150">최소 일치 수량자에 대 한 자세한 내용은 참조 [수량자](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="3bdac-151">긍정 lookahead: `(?=` *subexpression*`)`합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="3bdac-152">이 기능을 사용하면 역추적 검사 엔진이 하위 식을 찾은 후에 텍스트의 동일한 지점으로 돌아오게 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="3bdac-153">동일한 위치에서 시작하는 여러 패턴을 확인하여 전체 텍스트를 검색하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="3bdac-154">이를 통해 엔진은 찾은 텍스트에 부분 문자열을 포함하지 않고 부분 문자열이 일치 항목의 끝에 존재하는지 확인할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="3bdac-155">다음 예제에서는 긍정 lookahead를 사용하여 문장 부호 기호가 뒤에 오지 않는 문장에 있는 단어를 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]  
  
     <span data-ttu-id="3bdac-156">`\b[A-Z]+\b(?=\P{P})` 정규식은 다음 테이블과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="3bdac-157">무늬</span><span class="sxs-lookup"><span data-stu-id="3bdac-157">Pattern</span></span>|<span data-ttu-id="3bdac-158">설명</span><span class="sxs-lookup"><span data-stu-id="3bdac-158">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="3bdac-159">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-159">Begin the match at a word boundary.</span></span>|  
    |`[A-Z]+`|<span data-ttu-id="3bdac-160">알파벳 임의의 문자를 1회 이상 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="3bdac-161">때문에 <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> 메서드는 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 옵션 비교는 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|  
    |`\b`|<span data-ttu-id="3bdac-162">단어 경계에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-162">End the match at a word boundary.</span></span>|  
    |`(?=\P{P})`|<span data-ttu-id="3bdac-163">다음 문자가 문장 부호 기호인지 확인하기 위해 앞을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="3bdac-164">그렇지 않은 경우 일치가 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-164">If it is not, the match succeeds.</span></span>|  
  
     <span data-ttu-id="3bdac-165">긍정 lookahead 어설션에 대 한 자세한 내용은 참조 [그룹화 구문](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="3bdac-166">부정 lookahead: `(?!` *subexpression*`)`합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="3bdac-167">이 기능은 하위 식이 일치에 실패하는 경우 식을 찾는 기능을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="3bdac-168">이 기능은 정리 작업에 특히 유용합니다. 포함해야 하는 사례에 대한 식보다 제거해야 하는 경우에 대한 식을 제공하는 것이 더 간단하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="3bdac-169">예를 들어 "non"으로 시작하지 않는 단어에 대한 식을 작성하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="3bdac-170">다음 예제에서는 부정 lookahead를 사용하여 파일을 제외합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-170">The following example uses negative lookahead to exclude them.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]  
  
     <span data-ttu-id="3bdac-171">정규식 패턴 `\b(?!non)\w+\b`는 다음 테이블과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="3bdac-172">패턴</span><span class="sxs-lookup"><span data-stu-id="3bdac-172">Pattern</span></span>|<span data-ttu-id="3bdac-173">설명</span><span class="sxs-lookup"><span data-stu-id="3bdac-173">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="3bdac-174">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-174">Begin the match at a word boundary.</span></span>|  
    |`(?!non)`|<span data-ttu-id="3bdac-175">현재 문자열이 "non"으로 시작하지 않으면 조회합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="3bdac-176">그렇지 않으면 검색이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-176">If it does, the match fails.</span></span>|  
    |`(\w+)`|<span data-ttu-id="3bdac-177">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-177">Match one or more word characters.</span></span>|  
    |`\b`|<span data-ttu-id="3bdac-178">단어 경계에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-178">End the match at a word boundary.</span></span>|  
  
     <span data-ttu-id="3bdac-179">부정 lookahead 어설션에 대 한 자세한 내용은 참조 [그룹화 구문](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="3bdac-180">조건부 평가: `(?(` *식*`)`*예*`|`*없는* `)` 및 `(?(` *이름*`)`*예*`|`*없습니다*`)`여기서 *식* 은 일치 하는 하위 식 *이름* 캡처링 그룹의 이름인 *예* 은 경우에 일치 시킬 문자열 *식* 일치 또는 *이름* 유효한, 비어 있지 않은 캡처된 그룹 및 *없습니다* 경우 일치 하도록 하위 식입니다 *식* 일치 하지 않습니다. 또는 *이름* 유효 하 고 비어 있지 않은 캡처된 그룹이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="3bdac-181">엔진은 이 기능을 통해 이전 하위 식이 일치 결과 및 너비 0인 어설션 결과에 따라 둘 이상의 대체 패턴을 사용하여 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="3bdac-182">따라서 이전 하위 식이 일치하는지 여부에 따라 하위 식을 찾도록 허용하는 더 강력한 형식의 역참조가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="3bdac-183">다음 예제의 정규식은 공용으로 사용하고 내부적으로 사용하려는 단락을 모두 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="3bdac-184">내부적으로 사용하려는 단락은 `<PRIVATE>` 태그로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="3bdac-185">정규식 패턴 `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$`은 조건부 평가를 사용하여 공용으로 사용하고 내부적으로 사용하려는 단락의 콘텐츠를 별도의 캡처링 그룹에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="3bdac-186">이러한 단락은 다르게 처리될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-186">These paragraphs can then be handled differently.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]  
  
     <span data-ttu-id="3bdac-187">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-187">The regular expression pattern is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="3bdac-188">패턴</span><span class="sxs-lookup"><span data-stu-id="3bdac-188">Pattern</span></span>|<span data-ttu-id="3bdac-189">설명</span><span class="sxs-lookup"><span data-stu-id="3bdac-189">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="3bdac-190">줄의 시작 부분에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-190">Begin the match at the beginning of a line.</span></span>|  
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="3bdac-191">0개 또는 1개의 뒤에 공백 문자가 있는 `<PRIVATE>` 문자열을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="3bdac-192">명명 된 캡처링 그룹에 일치를 할당 `Pvt`합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-192">Assign the match to a capturing group named `Pvt`.</span></span>|  
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="3bdac-193">`Pvt` 캡처링 그룹이 있는 경우 뒤에 0개 이상의 문장 구분 기호와 하나의 공백 문자가 오는 하나 이상의 단어 문자를 한 번 이상 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="3bdac-194">첫 번째 캡처링 그룹에 부분 문자열을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-194">Assign the substring to the first capturing group.</span></span>|  
    |`&#124;((\w+\p{P}?\s)+))`|<span data-ttu-id="3bdac-195">`Pvt` 캡처링 그룹이 없는 경우 뒤에 0개 이상의 문장 구분 기호와 하나의 공백 문자가 오는 하나 이상의 단어 문자를 한 번 이상 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="3bdac-196">세 번째 캡처링 그룹에 부분 문자열을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-196">Assign the substring to the third capturing group.</span></span>|  
    |`\r?$`|<span data-ttu-id="3bdac-197">줄의 끝 또는 문자열의 끝을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-197">Match the end of a line or the end of the string.</span></span>|  
  
     <span data-ttu-id="3bdac-198">조건 평가 대 한 자세한 내용은 참조 [교체 구문](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="3bdac-199">균형 조정 그룹 정의: `(?<` *name1*`-`*name2* `>` *subexpression*`)`합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="3bdac-200">정규식 엔진은 이 기능을 통해 괄호 또는 열고 닫는 대괄호와 같은 중첩된 구문을 추적할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="3bdac-201">예를 들어 참조 [그룹화 구문](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="3bdac-202">역 추적 하지 않는 하위 식 (최대 일치 부분식): `(?>` *subexpression*`)`합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-202">Nonbacktracking subexpressions (also known as greedy subexpressions): `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="3bdac-203">식이 보유한 독립 항목을 실행하는 것처럼 역추적 엔진은 이 기능을 통해 하위 식이 보유한 첫 번째 일치 항목만을 찾는다고 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="3bdac-204">이 생성자를 사용하지 않는 경우 더 큰 식의 역추적 검색은 하위 식의 동작을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="3bdac-205">예를 들어 정규식 `(a+)\w`이 "a" 문자의 시퀀스를 따르는 단어 문자와 함께 하나 이상의 "a" 문자를 찾고 "a" 문자의 시퀀스를 첫 번째 캡처 그룹에 할당합니다. 하지만 입력 문자열의 마지막 문자가 "a"인 경우 `\w` 언어 요소에 의해 찾게 되며 캡처된 그룹에 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]  
  
     <span data-ttu-id="3bdac-206">정규식 `((?>a+))\w`은 이러한 동작을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-206">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="3bdac-207">연속되는 모든 "a" 문자를 역추적하지 않고 찾기 때문에 첫 번째 캡처링 그룹에는 연속되는 모든 "a" 문자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-207">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="3bdac-208">"a" 문자의 뒤에 "a" 이외의 문자가 적어도 하나 이상 있지 않으면 검색에 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-208">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]  
  
     <span data-ttu-id="3bdac-209">역 추적 하지 않는 하위 식에 대 한 자세한 내용은 참조 [그룹화 구문](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-209">For more information about nonbacktracking subexpressions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="3bdac-210">오른쪽에서 왼쪽으로 일치를 제공 하 여 지정 되는 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 옵션을 한 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자 또는 정적 인스턴스 일치 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="3bdac-210">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="3bdac-211">이 기능은 왼쪽에서 오른쪽이 아닌 오른쪽에서 왼쪽으로 찾는 경우에 유용하고 패턴의 왼쪽이 아닌 패턴의 오른쪽 부분에서 찾기를 시작하는 경우 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-211">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="3bdac-212">다음 예제와 같이 오른쪽에서 왼쪽 찾기를 사용하면 탐욕적 수량자의 동작을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-212">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="3bdac-213">예제에서는 숫자로 끝나는 문장에 대해 두 개의 검색을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-213">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="3bdac-214">오른쪽에서 왼쪽 검색이 6자리 모두와 일치하는 반면 탐욕적 수량자를 사용하는 왼쪽에서 오른쪽 검색 `+`은 문장에서 6자리 중 하나와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-214">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="3bdac-215">정규식 패턴에 대한 설명은 이 섹션 앞부분의 게으른 수량자를 보여 주는 예제를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3bdac-215">For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]  
  
     <span data-ttu-id="3bdac-216">오른쪽에서 왼쪽 찾기에 대한 자세한 내용은 [정규식 옵션](../../../docs/standard/base-types/regular-expression-options.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3bdac-216">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
-   <span data-ttu-id="3bdac-217">긍정 및 부정 lookbehind: `(?<=` *subexpression* `)` 긍정 lookbehind에 대 한 및 `(?<!` *subexpression* `)` 부정 lookbehind에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-217">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="3bdac-218">이 기능은 이 항목의 앞부분에서 설명한 lookahead와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-218">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="3bdac-219">정규식 엔진을 사용하면 오른쪽에서 왼쪽 찾기를 완료할 수 있기 때문에 정규식은 무제한 lookbehind를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-219">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="3bdac-220">긍정 및 부정 lookbehind는 중첩된 하위 식이 외부 식의 상위 집합인 경우 중첩된 수량자를 방지하는 데도 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-220">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="3bdac-221">이러한 중첩된 수량자가 있는 정규식은 종종 성능이 저하됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-221">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="3bdac-222">예를 들어 다음 예제에서는 문자열이 영숫자 문자로 시작하고 끝나고 문자열의 다른 문자가 큰 하위 집합 중 하나임을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-222">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="3bdac-223">이 식은 전자 메일 주소의 유효성을 검사하는 데 사용되는 정규식의 일부를 형성합니다. 자세한 내용은 [방법: 문자열이 올바른 전자 메일 서식인지 확인](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3bdac-223">It forms a portion of the regular expression used to validate e-mail addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]  
  
     <span data-ttu-id="3bdac-224">정규식 `^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$\`는 다음 테이블과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-224">The regular expression `^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$\` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="3bdac-225">패턴</span><span class="sxs-lookup"><span data-stu-id="3bdac-225">Pattern</span></span>|<span data-ttu-id="3bdac-226">설명</span><span class="sxs-lookup"><span data-stu-id="3bdac-226">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="3bdac-227">문자열의 시작 부분에서 검색을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-227">Begin the match at the beginning of the string.</span></span>|  
    |`[A-Z0-9]`|<span data-ttu-id="3bdac-228">숫자 또는 영숫자 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-228">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="3bdac-229">비교는 대소문자를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-229">(The comparison is case-insensitive.)</span></span>|  
    |<span data-ttu-id="3bdac-230">`([-!#$%&'.*+/=?^`{}&#124;~\w])*\`</span><span class="sxs-lookup"><span data-stu-id="3bdac-230">`([-!#$%&'.*+/=?^`{}&#124;~\w])*\`</span></span>|<span data-ttu-id="3bdac-231">일치 항목 0 개 이상의 단어 문자 또는 다음 문자:-,!, #, $, %, &, '., *, +, /, =,?, ^, ', {,}, &#124; 또는 ~ 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., *, +, /, =, ?, ^, \`, {, }, &#124;, or ~.</span></span>|  
    |`(?<=[A-Z0-9])`|<span data-ttu-id="3bdac-232">영숫자만 또는 숫자여야 하는 이전 문자를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="3bdac-233">비교는 대소문자를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-233">(The comparison is case-insensitive.)</span></span>|  
    |`$`|<span data-ttu-id="3bdac-234">문자열의 끝 부분에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-234">End the match at the end of the string.</span></span>|  
  
     <span data-ttu-id="3bdac-235">긍정 및 부정 lookbehind에 대 한 자세한 내용은 참조 [그룹화 구문](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-235">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="3bdac-236">관련 항목</span><span class="sxs-lookup"><span data-stu-id="3bdac-236">Related Topics</span></span>  
  
|<span data-ttu-id="3bdac-237">제목</span><span class="sxs-lookup"><span data-stu-id="3bdac-237">Title</span></span>|<span data-ttu-id="3bdac-238">설명</span><span class="sxs-lookup"><span data-stu-id="3bdac-238">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="3bdac-239">역추적</span><span class="sxs-lookup"><span data-stu-id="3bdac-239">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="3bdac-240">대체 일치 항목을 찾는 정규식 역추적 분기에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|  
|[<span data-ttu-id="3bdac-241">컴파일 및 다시 사용</span><span class="sxs-lookup"><span data-stu-id="3bdac-241">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="3bdac-242">성능 향상을 위해 정규식을 컴파일하고 다시 사용하는 방법에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|  
|[<span data-ttu-id="3bdac-243">스레드로부터의 안전성</span><span class="sxs-lookup"><span data-stu-id="3bdac-243">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="3bdac-244">정규식 스레드로부터의 안전성에 대한 정보를 제공하고 정규식 개체에 대한 액세스를 동기화해야 하는 경우를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|  
|[<span data-ttu-id="3bdac-245">.NET Framework 정규식</span><span class="sxs-lookup"><span data-stu-id="3bdac-245">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="3bdac-246">정규식의 프로그래밍 언어 측면에 대한 개요를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|  
|[<span data-ttu-id="3bdac-247">정규식 개체 모델</span><span class="sxs-lookup"><span data-stu-id="3bdac-247">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="3bdac-248">정규식 클래스를 사용하는 방법을 보여 주는 코드 예제 및 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|  
|[<span data-ttu-id="3bdac-249">정규식 예제</span><span class="sxs-lookup"><span data-stu-id="3bdac-249">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="3bdac-250">일반적인 응용 프로그램에서 정규식 사용을 보여 주는 코드 예제를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-250">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|  
|[<span data-ttu-id="3bdac-251">정규식 언어 - 빠른 참조</span><span class="sxs-lookup"><span data-stu-id="3bdac-251">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="3bdac-252">정규식을 정의하는 데 사용할 수 있는 문자, 연산자 및 생성자 집합에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3bdac-252">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="3bdac-253">참조</span><span class="sxs-lookup"><span data-stu-id="3bdac-253">Reference</span></span>  
 <xref:System.Text.RegularExpressions?displayProperty=nameWithType>

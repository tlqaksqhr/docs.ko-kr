---
title: 정규식의 교체 그룹화 구문
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 0830ec4022ca789d9aac0d1ae2c10ae6f76cc75e
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="0f7cc-102">정규식의 교체 그룹화 구문</span><span class="sxs-lookup"><span data-stu-id="0f7cc-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="0f7cc-103">그룹화 구문은 정규식의 하위 식을 나타내며 입력 문자열의 부분 문자열을 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="0f7cc-104">그룹화 구문은 다음과 같은 경우에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-104">You can use grouping constructs to do the following:</span></span>  
  
-   <span data-ttu-id="0f7cc-105">입력 문자열에서 반복되는 하위 식을 일치시킵니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-105">Match a subexpression that is repeated in the input string.</span></span>  
  
-   <span data-ttu-id="0f7cc-106">여러 정규식 언어 요소가 있는 하위 식에 수량자를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="0f7cc-107">수량자에 대한 자세한 내용은 [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-107">For more information about quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="0f7cc-108"><xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> 메서드에 의해 반환되는 문자열에 하위 식을 포함시킵니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
-   <span data-ttu-id="0f7cc-109"><xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 속성에서 개별 하위 식을 검색하여 전체적으로 일치하는 텍스트와 별도로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="0f7cc-110">다음 표에는 .NET 정규식 엔진에서 지원되는 그룹화 구문과 해당 그룹화 구문의 캡처링 또는 비 캡처링 여부가 표시되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="0f7cc-111">그룹화 구문</span><span class="sxs-lookup"><span data-stu-id="0f7cc-111">Grouping construct</span></span>|<span data-ttu-id="0f7cc-112">캡처링 또는 비 캡처링</span><span class="sxs-lookup"><span data-stu-id="0f7cc-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="0f7cc-113">일치하는 하위 식</span><span class="sxs-lookup"><span data-stu-id="0f7cc-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="0f7cc-114">캡처 중</span><span class="sxs-lookup"><span data-stu-id="0f7cc-114">Capturing</span></span>|  
|[<span data-ttu-id="0f7cc-115">명명된 일치하는 하위 식</span><span class="sxs-lookup"><span data-stu-id="0f7cc-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="0f7cc-116">캡처 중</span><span class="sxs-lookup"><span data-stu-id="0f7cc-116">Capturing</span></span>|  
|[<span data-ttu-id="0f7cc-117">균형 조정 그룹 정의</span><span class="sxs-lookup"><span data-stu-id="0f7cc-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="0f7cc-118">캡처 중</span><span class="sxs-lookup"><span data-stu-id="0f7cc-118">Capturing</span></span>|  
|[<span data-ttu-id="0f7cc-119">비 캡처링 그룹</span><span class="sxs-lookup"><span data-stu-id="0f7cc-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="0f7cc-120">비 캡처링</span><span class="sxs-lookup"><span data-stu-id="0f7cc-120">Noncapturing</span></span>|  
|[<span data-ttu-id="0f7cc-121">그룹 옵션</span><span class="sxs-lookup"><span data-stu-id="0f7cc-121">Group options</span></span>](#group_options)|<span data-ttu-id="0f7cc-122">비 캡처링</span><span class="sxs-lookup"><span data-stu-id="0f7cc-122">Noncapturing</span></span>|  
|[<span data-ttu-id="0f7cc-123">너비가 0인 긍정 lookahead 어설션</span><span class="sxs-lookup"><span data-stu-id="0f7cc-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="0f7cc-124">비 캡처링</span><span class="sxs-lookup"><span data-stu-id="0f7cc-124">Noncapturing</span></span>|  
|[<span data-ttu-id="0f7cc-125">너비가 0인 부정 lookahead 어설션</span><span class="sxs-lookup"><span data-stu-id="0f7cc-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="0f7cc-126">비 캡처링</span><span class="sxs-lookup"><span data-stu-id="0f7cc-126">Noncapturing</span></span>|  
|[<span data-ttu-id="0f7cc-127">너비가 0인 긍정 lookbehind 어설션</span><span class="sxs-lookup"><span data-stu-id="0f7cc-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="0f7cc-128">비 캡처링</span><span class="sxs-lookup"><span data-stu-id="0f7cc-128">Noncapturing</span></span>|  
|[<span data-ttu-id="0f7cc-129">너비가 0인 부정 lookbehind 어설션</span><span class="sxs-lookup"><span data-stu-id="0f7cc-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="0f7cc-130">비 캡처링</span><span class="sxs-lookup"><span data-stu-id="0f7cc-130">Noncapturing</span></span>|  
|[<span data-ttu-id="0f7cc-131">역추적하지 않는 하위 식</span><span class="sxs-lookup"><span data-stu-id="0f7cc-131">Nonbacktracking subexpressions</span></span>](#nonbacktracking_subexpression)|<span data-ttu-id="0f7cc-132">비 캡처링</span><span class="sxs-lookup"><span data-stu-id="0f7cc-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="0f7cc-133">그룹 및 정규식 개체 모델에 대한 자세한 내용은 [그룹화 구문 및 정규식 개체](#Objects)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>   
## <a name="matched-subexpressions"></a><span data-ttu-id="0f7cc-134">일치하는 하위 식</span><span class="sxs-lookup"><span data-stu-id="0f7cc-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="0f7cc-135">다음 그룹화 구문은 일치하는 하위 식을 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="0f7cc-136">`(` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="0f7cc-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="0f7cc-137">여기서 *subexpression* 은 임의의 유효한 정규식 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="0f7cc-138">괄호를 사용하는 캡처는 정규식에서 여는 괄호의 순서에 따라 왼쪽에서 오른쪽으로 자동으로 번호(1부터 시작)가 매겨집니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="0f7cc-139">번호가 0인 캡처는 전체 정규식 패턴에 의해 일치되는 텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0f7cc-140">기본적으로 `(`*subexpression*`)` 언어 요소는 일치하는 하위 식을 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="0f7cc-141">그러나 정규식 패턴 일치 메서드의 <xref:System.Text.RegularExpressions.RegexOptions> 매개 변수가 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> 플래그를 포함하거나, `n` 옵션이 이 하위 식에 적용된 경우(이 항목 뒷부분의 [그룹 옵션](#group_options) 참조) 일치하는 하위 식이 캡처되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="0f7cc-142">캡처된 그룹에는 다음과 같은 4가지 방법으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-142">You can access captured groups in four ways:</span></span>  
  
-   <span data-ttu-id="0f7cc-143">정규식 내의 역참조 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="0f7cc-144">일치하는 하위 식은 `\`*number*구문을 통해 동일한 정규식에서 참조됩니다. 여기서 *number* 는 캡처된 하위 식의 서수입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="0f7cc-145">정규식 내의 명명된 역참조 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="0f7cc-146">일치하는 하위 식은 `\k<`*name*`>`구문을 통해 동일한 정규식에서 참조됩니다. 여기서 *name* 은 캡처링 그룹의 이름) 또는 `\k<`*number*`>`구문을 통해 동일한 정규식에서 참조됩니다. 여기서 *number* 는 캡처링 그룹의 서수)을 통해 동일한 정규식에서 참조됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="0f7cc-147">캡처링 그룹은 해당 서수와 같은 기본 이름을 갖고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="0f7cc-148">자세한 내용은 이 항목 뒷부분의 [명명된 일치하는 하위 식](#named_matched_subexpression) 을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
-   <span data-ttu-id="0f7cc-149"><xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> 또는 <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> 메서드 호출에서 `$`*number* 바꾸기 시퀀스를 사용합니다. 여기서 *number*는 캡처된 하위 식의 서수입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="0f7cc-150">프로그래밍 방식으로 <xref:System.Text.RegularExpressions.GroupCollection> 속성에서 반환하는 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 개체를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="0f7cc-151">컬렉션에서 위치 0에 있는 멤버는 전체 정규식 일치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="0f7cc-152">각 후속 멤버는 일치하는 하위 식을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="0f7cc-153">자세한 내용은 [Grouping Constructs and Regular Expression Objects](#Objects) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="0f7cc-154">다음 예제에서는 텍스트에서 중복된 단어를 식별하는 정규식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="0f7cc-155">정규식 패턴의 두 캡처링 그룹은 중복된 단어의 두 인스턴스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="0f7cc-156">두 번째 인스턴스는 입력 문자열의 해당 시작 위치를 보고하기 위해 캡처됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="0f7cc-157">정규식 패턴은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-157">The regular expression pattern is the following:</span></span>  
  
```  
(\w+)\s(\1)\W  
```  
  
 <span data-ttu-id="0f7cc-158">다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="0f7cc-159">패턴</span><span class="sxs-lookup"><span data-stu-id="0f7cc-159">Pattern</span></span>|<span data-ttu-id="0f7cc-160">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="0f7cc-161">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-161">Match one or more word characters.</span></span> <span data-ttu-id="0f7cc-162">이 그룹은 첫 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="0f7cc-163">공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="0f7cc-164">캡처된 첫 번째 그룹의 문자열을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-164">Match the string in the first captured group.</span></span> <span data-ttu-id="0f7cc-165">이 그룹은 두 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-165">This is the second capturing group.</span></span> <span data-ttu-id="0f7cc-166">이 예제에서는 `Match.Index` 개체를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="0f7cc-167">공백 및 문장 부호를 포함하여 비단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="0f7cc-168">그러면 정규식 패턴이 캡처된 첫 번째 그룹의 단어로 시작하는 단어를 찾지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>   
## <a name="named-matched-subexpressions"></a><span data-ttu-id="0f7cc-169">명명된 일치하는 하위 식</span><span class="sxs-lookup"><span data-stu-id="0f7cc-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="0f7cc-170">다음 그룹화 구문은 일치하는 하위 식을 캡처하고 사용자가 이름 또는 번호로 해당 하위 식에 액세스할 수 있게 해줍니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
```  
(?<name>subexpression)  
```  
  
 <span data-ttu-id="0f7cc-171">또는</span><span class="sxs-lookup"><span data-stu-id="0f7cc-171">or:</span></span>  
  
```  
(?'name'subexpression)  
```  
  
 <span data-ttu-id="0f7cc-172">여기서 *name* 은 유효한 그룹 이름이고, *subexpression* 은 임의의 유효한 정규식 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="0f7cc-173">*name* 은 문장 부호 문자를 포함해서는 안 되며 숫자로 시작할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0f7cc-174">정규식 패턴 일치 메서드의 <xref:System.Text.RegularExpressions.RegexOptions> 매개 변수가 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> 플래그를 포함하거나, `n` 옵션이 이 하위 식에 적용된 경우(이 항목 뒷부분의 [그룹 옵션](#group_options) 참조) 하위 식을 캡처하는 유일한 방법은 명시적으로 캡처링 그룹의 이름을 지정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="0f7cc-175">명명된 캡처된 그룹에는 다음과 같은 방법으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-175">You can access named captured groups in the following ways:</span></span>  
  
-   <span data-ttu-id="0f7cc-176">정규식 내의 명명된 역참조 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="0f7cc-177">일치하는 하위 식은 `\k<`*name*`>`구문을 통해 동일한 정규식에서 참조됩니다. 여기서 *name* 은 캡처된 하위 식의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="0f7cc-178">정규식 내의 역참조 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="0f7cc-179">일치하는 하위 식은 `\`*number*구문을 통해 동일한 정규식에서 참조됩니다. 여기서 *number* 는 캡처된 하위 식의 서수입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="0f7cc-180">명명된 일치하는 하위 식은 하위 식을 일치시킨 후 왼쪽에서 오른쪽으로 연속적으로 번호가 매겨집니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
-   <span data-ttu-id="0f7cc-181"><xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> 또는 <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> 메서드 호출에서 `${`*name*`}` 바꾸기 시퀀스를 사용합니다. 여기서 *name*은 캡처된 하위 식의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="0f7cc-182"><xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> 또는 <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> 메서드 호출에서 `$`*number* 바꾸기 시퀀스를 사용합니다. 여기서 *number*는 캡처된 하위 식의 서수입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="0f7cc-183">프로그래밍 방식으로 <xref:System.Text.RegularExpressions.GroupCollection> 속성에서 반환하는 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 개체를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="0f7cc-184">컬렉션에서 위치 0에 있는 멤버는 전체 정규식 일치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="0f7cc-185">각 후속 멤버는 일치하는 하위 식을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="0f7cc-186">명명된 캡처된 그룹은 캡처된 그룹의 번호를 매긴 후 컬렉션에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
-   <span data-ttu-id="0f7cc-187">프로그래밍 방식으로 하위 식 이름을 <xref:System.Text.RegularExpressions.GroupCollection> 개체의 인덱서(C#의 경우) 또는 해당 <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> 속성(Visual Basic의 경우)에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="0f7cc-188">단순 정규식 패턴이 프로그래밍 방식으로 또는 정규식 언어 구문을 사용하여, 번호가 매겨진(명명되지 않은) 그룹 및 명명된 그룹을 참조할 수 있는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="0f7cc-189">정규식 `((?<One>abc)\d+)?(?<Two>xyz)(.*)` 는 번호 및 이름으로 다음 캡처링 그룹을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="0f7cc-190">첫 번째 캡처링 그룹(번호 0)은 항상 전체 패턴을 지칭합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="0f7cc-191">number</span><span class="sxs-lookup"><span data-stu-id="0f7cc-191">Number</span></span>|<span data-ttu-id="0f7cc-192">name</span><span class="sxs-lookup"><span data-stu-id="0f7cc-192">Name</span></span>|<span data-ttu-id="0f7cc-193">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="0f7cc-194">0</span><span class="sxs-lookup"><span data-stu-id="0f7cc-194">0</span></span>|<span data-ttu-id="0f7cc-195">0(기본 이름)</span><span class="sxs-lookup"><span data-stu-id="0f7cc-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="0f7cc-196">1</span><span class="sxs-lookup"><span data-stu-id="0f7cc-196">1</span></span>|<span data-ttu-id="0f7cc-197">1(기본 이름)</span><span class="sxs-lookup"><span data-stu-id="0f7cc-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="0f7cc-198">2</span><span class="sxs-lookup"><span data-stu-id="0f7cc-198">2</span></span>|<span data-ttu-id="0f7cc-199">2(기본 이름)</span><span class="sxs-lookup"><span data-stu-id="0f7cc-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="0f7cc-200">3</span><span class="sxs-lookup"><span data-stu-id="0f7cc-200">3</span></span>|<span data-ttu-id="0f7cc-201">1</span><span class="sxs-lookup"><span data-stu-id="0f7cc-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="0f7cc-202">4</span><span class="sxs-lookup"><span data-stu-id="0f7cc-202">4</span></span>|<span data-ttu-id="0f7cc-203">2</span><span class="sxs-lookup"><span data-stu-id="0f7cc-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="0f7cc-204">다음 예제에서는 중복된 단어와 중복된 각 단어 바로 뒤에 나오는 단어를 식별하는 정규식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="0f7cc-205">정규식 패턴은 두 개의 명명된 하위 식 즉, 중복된 단어를 나타내는 `duplicateWord`와 중복된 단어 뒤에 나오는 단어를 나타내는 `nextWord`를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="0f7cc-206">정규식 패턴은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-206">The regular expression pattern is as follows:</span></span>  
  
```  
(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)  
```  
  
 <span data-ttu-id="0f7cc-207">다음 테이블은 정규식이 해석되는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="0f7cc-208">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-208">Pattern</span></span>|<span data-ttu-id="0f7cc-209">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="0f7cc-210">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-210">Match one or more word characters.</span></span> <span data-ttu-id="0f7cc-211">이 캡처링 그룹의 이름을 `duplicateWord`로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="0f7cc-212">공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="0f7cc-213">`duplicateWord`라는 캡처된 그룹에서 문자열을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="0f7cc-214">공백 및 문장 부호를 포함하여 비단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="0f7cc-215">그러면 정규식 패턴이 캡처된 첫 번째 그룹의 단어로 시작하는 단어를 찾지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="0f7cc-216">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-216">Match one or more word characters.</span></span> <span data-ttu-id="0f7cc-217">이 캡처링 그룹의 이름을 `nextWord`로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="0f7cc-218">정규식에서 그룹 이름을 반복할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="0f7cc-219">예를 들어 다음 예제와 같이 둘 이상의 그룹에 `digit`라는 이름을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="0f7cc-220">중복된 이름의 경우 <xref:System.Text.RegularExpressions.Group> 개체의 값은 입력 문자열에서 마지막으로 성공한 캡처에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="0f7cc-221">또한 그룹 이름이 중복되지 않은 경우와 마찬가지로 <xref:System.Text.RegularExpressions.CaptureCollection> 에 각 캡처에 대한 정보가 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="0f7cc-222">다음 예제에서 `\D+(?<digit>\d+)\D+(?<digit>\d+)?` 정규식에는 `digit`라는 그룹 발생이 두 개 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="0f7cc-223">첫 번째 `digit` 그룹은 하나 이상의 숫자 문자를 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="0f7cc-224">두 번째 `digit` 그룹은 하나 이상 숫자 문자의 0개 또는 1개 발생을 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="0f7cc-225">예제의 출력에 표시된 것처럼 두 번째 캡처 그룹이 텍스트와 일치하면 해당 텍스트의 값이 <xref:System.Text.RegularExpressions.Group> 개체의 값을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="0f7cc-226">두 번째 캡처 그룹이 입력 문자열과 일치하지 않으면 마지막으로 성공한 일치의 값이 <xref:System.Text.RegularExpressions.Group> 개체의 값을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="0f7cc-227">다음 테이블은 정규식이 해석되는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="0f7cc-228">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-228">Pattern</span></span>|<span data-ttu-id="0f7cc-229">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="0f7cc-230">하나 이상의 10진수가 아닌 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="0f7cc-231">하나 이상의 10진수 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="0f7cc-232">명명된 그룹 `digit` 에 일치를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-232">Assign the match to the `digit` named group.</span></span>|  
|<span data-ttu-id="0f7cc-233">\D+</span><span class="sxs-lookup"><span data-stu-id="0f7cc-233">\D+</span></span>|<span data-ttu-id="0f7cc-234">하나 이상의 10진수가 아닌 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-234">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="0f7cc-235">하나 이상 10진수 문자의 0개 또는 1개 발생을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-235">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="0f7cc-236">명명된 그룹 `digit` 에 일치를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-236">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>   
## <a name="balancing-group-definitions"></a><span data-ttu-id="0f7cc-237">균형 조정 그룹 정의</span><span class="sxs-lookup"><span data-stu-id="0f7cc-237">Balancing Group Definitions</span></span>  
 <span data-ttu-id="0f7cc-238">균형 조정 그룹 정의는 이전에 정의된 그룹의 정의를 삭제하고 현재 그룹에 이전에 정의된 그룹과 현재 그룹 간의 간격을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-238">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="0f7cc-239">이 그룹화 구문의 형식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-239">This grouping construct has the following format:</span></span>  
  
```  
(?<name1-name2>subexpression)  
```  
  
 <span data-ttu-id="0f7cc-240">또는</span><span class="sxs-lookup"><span data-stu-id="0f7cc-240">or:</span></span>  
  
```  
(?'name1-name2' subexpression)  
```  
  
 <span data-ttu-id="0f7cc-241">여기서 *name1* 은 현재 그룹이고(선택 사항), *name2* 는 이전에 정의된 그룹이며, *subexpression* 은 임의의 유효한 정규식 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-241">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="0f7cc-242">균형 조정 그룹 정의는 *name2* 의 정의를 삭제하고 *name1* 에 *name2* 와 *name1*간의 간격을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-242">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="0f7cc-243">*name2* 그룹이 정의되어 있지 않으면 일치에서 역추적합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-243">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="0f7cc-244">*name2* 의 마지막 정의를 삭제하면 *name2*의 이전 정의가 표시되므로 이 구문을 통해 그룹 *name2* 에 대한 캡처 스택을 괄호 또는 여는 대괄호 및 닫는 대괄호와 같은 중첩된 구문을 추적하기 위한 카운터로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-244">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="0f7cc-245">균형 조정 그룹 정의에서는 *name2* 를 스택으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-245">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="0f7cc-246">각 중첩된 구문의 시작 문자는 그룹 및 해당 <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> 컬렉션에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-246">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="0f7cc-247">닫는 문자가 일치하면 해당 여는 문자가 그룹에서 제거되고 <xref:System.Text.RegularExpressions.Group.Captures%2A> 컬렉션이 하나 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-247">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="0f7cc-248">모든 중첩된 구문의 여는 문자와 닫는 문자가 일치하고 나면 *name1* 이 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-248">After the opening and closing characters of all nested constructs have been matched, *name1* is empty.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0f7cc-249">다음 예제에서 중첩된 구문의 적절한 여는 문자와 닫는 문자를 사용하도록 정규식을 수정하고 나면 이러한 정규식을 사용하여 가장 많이 중첩된 구문(예: 여러 중첩 메서드 호출을 포함하는 프로그램 코드 줄 또는 수학식)을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-249">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="0f7cc-250">다음 예제에서는 균형 조정 그룹 정의를 사용하여 입력 문자열에서 왼쪽 및 오른쪽 꺾쇠괄호(<>)를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-250">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="0f7cc-251">이 예제에서는 일치하는 꺾쇠괄호 쌍을 추적하는 데 스택처럼 사용되는 두 개의 명명된 그룹 `Open` 및 `Close`를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-251">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="0f7cc-252">캡처된 각 왼쪽 꺾쇠괄호는 `Open` 그룹의 캡처 컬렉션에 푸시되고, 캡처된 각 오른쪽 꺾쇠괄호는 `Close` 그룹의 캡처 컬렉션에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-252">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="0f7cc-253">균형 조정 그룹 정의는 각 왼쪽 꺾쇠괄호에 대해 일치하는 오른쪽 꺾쇠괄호가 있도록 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-253">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="0f7cc-254">일치하는 오른쪽 꺾쇠괄호가 없는 경우 최종 하위 패턴 `(?(Open)(?!))`는 `Open` 그룹이 비어 있지 않은 경우(및 따라서 모든 중첩된 구문이 닫히지 않은 경우)에만 평가됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-254">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="0f7cc-255">최종 하위 패턴이 평가되면 찾기가 실패하는데, `(?!)` 하위 패턴이 항상 실패하는 너비가 0인 부정 lookahead 어설션이기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-255">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="0f7cc-256">정규식 패턴은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-256">The regular expression pattern is:</span></span>  
  
```  
^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$  
```  
  
 <span data-ttu-id="0f7cc-257">정규식은 다음과 같이 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-257">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="0f7cc-258">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-258">Pattern</span></span>|<span data-ttu-id="0f7cc-259">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-259">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="0f7cc-260">문자열의 시작 부분에서 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-260">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="0f7cc-261">왼쪽 또는 오른쪽 꺾쇠괄호가 아닌 0개 이상의 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-261">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="0f7cc-262">왼쪽 꺾쇠괄호를 찾아 `Open`이라는 그룹에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-262">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="0f7cc-263">왼쪽 또는 오른쪽 꺾쇠괄호가 아닌 0개 이상의 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-263">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*) +`|<span data-ttu-id="0f7cc-264">하나 이상의 왼쪽 꺾쇠괄호 다음에 왼쪽 또는 오른쪽 꺾쇠괄호가 아닌 0개 이상의 문자가 있는 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-264">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="0f7cc-265">이 그룹은 두 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-265">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="0f7cc-266">오른쪽 꺾쇠괄호를 찾고 `Open` 그룹과 현재 그룹 간의 부분 문자열을 `Close` 그룹에 할당한 다음 `Open` 그룹의 정의를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-266">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="0f7cc-267">왼쪽 및 오른쪽 꺾쇠괄호가 아닌 0개 이상의 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-267">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="0f7cc-268">하나 이상의 오른쪽 꺾쇠괄호 다음에 왼쪽 및 오른쪽 꺾쇠괄호가 아닌 0개 이상의 문자가 있는 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-268">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="0f7cc-269">오른쪽 꺾쇠괄호를 찾을 때 `Open` 그룹과 현재 그룹 간의 부분 문자열을 `Close` 그룹에 할당하고 `Open` 그룹의 정의를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-269">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="0f7cc-270">이 그룹은 세 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-270">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="0f7cc-271">하나 이상의 왼쪽 꺾쇠괄호가 있고, 다음에 0개 이상의 꺾쇠괄호가 아닌 문자가 있고, 다음에 하나 이상의 오른쪽 꺾쇠괄호가 있고, 다음에 0개 이상의 꺾쇠괄호가 아닌 문자가 있는 패턴을 0개 이상 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-271">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="0f7cc-272">오른쪽 꺾쇠괄호를 찾을 때 `Open` 그룹의 정의를 삭제하고 `Open` 그룹과 현재 그룹 간의 부분 문자열을 `Close` 그룹에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-272">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="0f7cc-273">이 그룹은 첫 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-273">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="0f7cc-274">`Open` 그룹이 있는 경우 빈 문자열을 찾을 수 있으면 찾기를 중단하되, 문자열에서 정규식 엔진의 위치를 앞으로 이동하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-274">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="0f7cc-275">이는 너비가 0인 부정 lookahead 어설션입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-275">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="0f7cc-276">입력 문자열에는 항상 암시적으로 빈 문자열이 있기 때문에 이 찾기는 항상 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-276">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="0f7cc-277">이 찾기의 실패는 꺾쇠괄호의 짝이 맞지 않음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-277">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="0f7cc-278">입력 문자열의 끝 부분을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-278">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="0f7cc-279">최종 하위 식 `(?(Open)(?!))`는 입력 문자열의 중첩 구문이 짝이 올바르게 맞는지 여부를 나타냅니다(예: 각 왼쪽 꺾쇠괄호가 오른쪽 꺾쇠괄호와 일치하는지 여부).</span><span class="sxs-lookup"><span data-stu-id="0f7cc-279">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="0f7cc-280">최종 하위 식에서는 유효한 캡처된 그룹을 기반으로 조건부 일치를 사용합니다. 자세한 내용은 [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-280">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="0f7cc-281">`Open` 그룹이 정의되어 있는 경우 정규식 엔진은 입력 문자열에서 하위 식 `(?!)` 를 찾으려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-281">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="0f7cc-282">`Open` 그룹은 중첩 구문이 짝이 맞지 않는 경우에만 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-282">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="0f7cc-283">따라서 입력 문자열에서 찾을 패턴은 항상 찾기가 실패하도록 만드는 패턴이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-283">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="0f7cc-284">이 경우 `(?!)` 는 항상 실패하는 너비가 0인 부정 lookahead 어설션인데, 입력 문자열의 다음 위치에는 항상 암시적으로 빈 문자열이 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-284">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="0f7cc-285">이 예제에서 정규식 엔진은 다음 표에 나와 있는 것처럼 입력 문자열 “\<abc><mno\<xyz>>”를 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-285">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="0f7cc-286">단계</span><span class="sxs-lookup"><span data-stu-id="0f7cc-286">Step</span></span>|<span data-ttu-id="0f7cc-287">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-287">Pattern</span></span>|<span data-ttu-id="0f7cc-288">결과</span><span class="sxs-lookup"><span data-stu-id="0f7cc-288">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="0f7cc-289">1</span><span class="sxs-lookup"><span data-stu-id="0f7cc-289">1</span></span>|`^`|<span data-ttu-id="0f7cc-290">입력 문자열의 시작 부분에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-290">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="0f7cc-291">2</span><span class="sxs-lookup"><span data-stu-id="0f7cc-291">2</span></span>|`[^<>]*`|<span data-ttu-id="0f7cc-292">왼쪽 꺾쇠괄호 앞에서 꺾쇠괄호가 아닌 문자를 찾습니다. 일치 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-292">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="0f7cc-293">3</span><span class="sxs-lookup"><span data-stu-id="0f7cc-293">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="0f7cc-294">“\<abc>”에서 왼쪽 꺾쇠괄호를 찾아 `Open` 그룹에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-294">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="0f7cc-295">4</span><span class="sxs-lookup"><span data-stu-id="0f7cc-295">4</span></span>|`[^<>]*`|<span data-ttu-id="0f7cc-296">"abc"를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-296">Matches "abc".</span></span>|  
|<span data-ttu-id="0f7cc-297">5</span><span class="sxs-lookup"><span data-stu-id="0f7cc-297">5</span></span>|`)+`|<span data-ttu-id="0f7cc-298">"<abc"는 캡처된 두 번째 그룹의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-298">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="0f7cc-299">입력 문자열의 다음 문자가 왼쪽 꺾쇠괄호가 아니므로 정규식 엔진은 `(?'Open'<)[^<>]*)` 하위 패턴으로 루프백하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-299">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="0f7cc-300">6</span><span class="sxs-lookup"><span data-stu-id="0f7cc-300">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="0f7cc-301">“\<abc>”에서 오른쪽 꺾쇠괄호를 찾고 `Open` 그룹과 오른쪽 꺾쇠괄호 사이의 부분 문자열인 “abc”를 `Close` 그룹에 할당한 다음, `Open` 그룹의 현재 값(“<”)을 삭제하여 이 그룹을 비워 둡니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-301">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="0f7cc-302">7</span><span class="sxs-lookup"><span data-stu-id="0f7cc-302">7</span></span>|`[^<>]*`|<span data-ttu-id="0f7cc-303">오른쪽 꺾쇠괄호 뒤에서 꺾쇠괄호가 아닌 문자를 찾습니다. 일치 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-303">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="0f7cc-304">8</span><span class="sxs-lookup"><span data-stu-id="0f7cc-304">8</span></span>|`)+`|<span data-ttu-id="0f7cc-305">캡처된 세 번째 그룹의 값은 ">"입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-305">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="0f7cc-306">입력 문자열의 다음 문자가 오른쪽 꺾쇠괄호가 아니므로 정규식 엔진은 `((?'Close-Open'>)[^<>]*)` 하위 패턴으로 루프백하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-306">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="0f7cc-307">10</span><span class="sxs-lookup"><span data-stu-id="0f7cc-307">9</span></span>|`)*`|<span data-ttu-id="0f7cc-308">캡처된 첫 번째 그룹의 값은 “\<abc>”입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-308">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="0f7cc-309">입력 문자열의 다음 문자가 왼쪽 꺾쇠괄호이므로 정규식 엔진은 `(((?'Open'<)` 하위 패턴으로 루프백합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-309">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="0f7cc-310">10</span><span class="sxs-lookup"><span data-stu-id="0f7cc-310">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="0f7cc-311">“\<mno>”에서 왼쪽 꺾쇠괄호를 찾아 `Open` 그룹에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-311">Matches the left angle bracket in "\<mno>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="0f7cc-312">해당 <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> 컬렉션에는 이제 단일 값 "<"가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-312">Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="0f7cc-313">11</span><span class="sxs-lookup"><span data-stu-id="0f7cc-313">11</span></span>|`[^<>]*`|<span data-ttu-id="0f7cc-314">"mno"를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-314">Matches "mno".</span></span>|  
|<span data-ttu-id="0f7cc-315">12</span><span class="sxs-lookup"><span data-stu-id="0f7cc-315">12</span></span>|`)+`|<span data-ttu-id="0f7cc-316">"<mno"는 캡처된 두 번째 그룹의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-316">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="0f7cc-317">입력 문자열의 다음 문자가 왼쪽 꺾쇠괄호이므로 정규식 엔진은 `(?'Open'<)[^<>]*)` 하위 패턴으로 루프백합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-317">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="0f7cc-318">13</span><span class="sxs-lookup"><span data-stu-id="0f7cc-318">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="0f7cc-319">“\<xyz>”에서 왼쪽 꺾쇠괄호를 찾아 `Open` 그룹에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-319">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="0f7cc-320">이제 `Open` 그룹의 <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> 컬렉션에 두 개의 캡처 즉, “\<mno>”의 왼쪽 꺾쇠괄호와 “\<xyz>”의 왼쪽 꺾쇠괄호가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-320">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno>", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="0f7cc-321">14</span><span class="sxs-lookup"><span data-stu-id="0f7cc-321">14</span></span>|`[^<>]*`|<span data-ttu-id="0f7cc-322">"xyz"를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-322">Matches "xyz".</span></span>|  
|<span data-ttu-id="0f7cc-323">15</span><span class="sxs-lookup"><span data-stu-id="0f7cc-323">15</span></span>|`)+`|<span data-ttu-id="0f7cc-324">"<xyz"는 캡처된 두 번째 그룹의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-324">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="0f7cc-325">입력 문자열의 다음 문자가 왼쪽 꺾쇠괄호가 아니므로 정규식 엔진은 `(?'Open'<)[^<>]*)` 하위 패턴으로 루프백하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-325">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="0f7cc-326">16</span><span class="sxs-lookup"><span data-stu-id="0f7cc-326">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="0f7cc-327">“\<xyz>”에서 오른쪽 꺾쇠괄호를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-327">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="0f7cc-328">“xyz”는 `Open` 그룹과 오른쪽 꺾쇠괄호 간의 부분 문자열을 `Close` 그룹에 할당하고 `Open` 그룹의 현재 값을 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-328">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="0f7cc-329">이전 캡처의 값(“\<mno>”의 왼쪽 꺾쇠괄호)이 `Open` 그룹의 현재 값이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-329">The value of the previous capture (the left angle bracket in "\<mno>") becomes the current value of the `Open` group.</span></span> <span data-ttu-id="0f7cc-330">이제 `Open` 그룹의 <xref:System.Text.RegularExpressions.Group.Captures%2A> 컬렉션에 단일 캡처인 “\<xyz>”의 왼쪽 꺾쇠괄호가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-330">The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="0f7cc-331">17</span><span class="sxs-lookup"><span data-stu-id="0f7cc-331">17</span></span>|`[^<>]*`|<span data-ttu-id="0f7cc-332">꺾쇠괄호가 아닌 문자를 찾습니다. 일치 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-332">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="0f7cc-333">18</span><span class="sxs-lookup"><span data-stu-id="0f7cc-333">18</span></span>|`)+`|<span data-ttu-id="0f7cc-334">캡처된 세 번째 그룹의 값은 ">"입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-334">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="0f7cc-335">입력 문자열의 다음 문자가 오른쪽 꺾쇠괄호이므로 정규식 엔진은 `((?'Close-Open'>)[^<>]*)` 하위 패턴으로 루프백합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-335">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="0f7cc-336">19</span><span class="sxs-lookup"><span data-stu-id="0f7cc-336">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="0f7cc-337">“xyz>>”에서 최종 오른쪽 꺾쇠괄호를 찾고 `Open` 그룹과 오른쪽 꺾쇠괄호 사이의 부분 문자열인 “mno\<xyz>”를 `Close` 그룹에 할당한 다음, `Open` 그룹의 현재 값을 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-337">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="0f7cc-338">이제 `Open` 그룹이 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-338">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="0f7cc-339">20</span><span class="sxs-lookup"><span data-stu-id="0f7cc-339">20</span></span>|`[^<>]*`|<span data-ttu-id="0f7cc-340">꺾쇠괄호가 아닌 문자를 찾습니다. 일치 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-340">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="0f7cc-341">21</span><span class="sxs-lookup"><span data-stu-id="0f7cc-341">21</span></span>|`)+`|<span data-ttu-id="0f7cc-342">캡처된 세 번째 그룹의 값은 ">"입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-342">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="0f7cc-343">입력 문자열의 다음 문자가 오른쪽 꺾쇠괄호가 아니므로 정규식 엔진은 `((?'Close-Open'>)[^<>]*)` 하위 패턴으로 루프백하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-343">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="0f7cc-344">22</span><span class="sxs-lookup"><span data-stu-id="0f7cc-344">22</span></span>|`)*`|<span data-ttu-id="0f7cc-345">캡처된 첫 번째 그룹의 값은 “<mno\<xyz>>”입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-345">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="0f7cc-346">입력 문자열의 다음 문자가 왼쪽 꺾쇠괄호가 아니므로 정규식 엔진은 `(((?'Open'<)` 하위 패턴으로 루프백하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-346">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="0f7cc-347">23</span><span class="sxs-lookup"><span data-stu-id="0f7cc-347">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="0f7cc-348">`Open` 그룹이 정의되어 있지 않으므로 찾으려는 시도가 이루어지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-348">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="0f7cc-349">24</span><span class="sxs-lookup"><span data-stu-id="0f7cc-349">24</span></span>|`$`|<span data-ttu-id="0f7cc-350">입력 문자열의 끝 부분을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-350">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>   
## <a name="noncapturing-groups"></a><span data-ttu-id="0f7cc-351">비 캡처링 그룹</span><span class="sxs-lookup"><span data-stu-id="0f7cc-351">Noncapturing Groups</span></span>  
 <span data-ttu-id="0f7cc-352">다음 그룹화 구문은 하위 식과 일치하는 부분 문자열을 캡처하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-352">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
```  
(?:subexpression)  
```  
  
 <span data-ttu-id="0f7cc-353">여기서 *subexpression* 은 임의의 유효한 정규식 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-353">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="0f7cc-354">비 캡처링 그룹 구문은 일반적으로 수량자가 그룹에 적용될 때 사용되지만 그룹에 의해 캡처된 부분 문자열에는 관심을 두지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-354">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0f7cc-355">정규식에 중첩된 그룹화 구문이 포함된 경우 외부 비 캡처링 그룹 구문은 내부 중첩된 그룹 구문에 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-355">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="0f7cc-356">다음 예제에서는 비 캡처링 그룹을 포함하는 정규식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-356">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="0f7cc-357">출력에는 캡처된 그룹이 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-357">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="0f7cc-358">정규식 `(?:\b(?:\w+)\W*)+\.` 는 마침표로 종료된 문장을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-358">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="0f7cc-359">정규식은 개별 단어가 아닌 문장에 초점을 두므로 그룹화 구문은 단독으로 수량자로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-359">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="0f7cc-360">정규식 패턴은 다음 테이블과 같이 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-360">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="0f7cc-361">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-361">Pattern</span></span>|<span data-ttu-id="0f7cc-362">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-362">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="0f7cc-363">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-363">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="0f7cc-364">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-364">Match one or more word characters.</span></span> <span data-ttu-id="0f7cc-365">일치하는 텍스트를 캡처된 그룹에 할당하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-365">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="0f7cc-366">0개 이상의 단어가 아닌 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-366">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="0f7cc-367">단어 경계에서 시작하는 하나 이상의 단어 문자 뒤에 0개 이상의 단어가 아닌 문자가 한 번 이상 나타나는 패턴을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-367">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="0f7cc-368">일치하는 텍스트를 캡처된 그룹에 할당하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-368">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="0f7cc-369">마침표를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-369">Match a period.</span></span>|  
  
<a name="group_options"></a>   
## <a name="group-options"></a><span data-ttu-id="0f7cc-370">그룹 옵션</span><span class="sxs-lookup"><span data-stu-id="0f7cc-370">Group Options</span></span>  
 <span data-ttu-id="0f7cc-371">다음 그룹화 구문은 하위 식 내에서 지정된 옵션을 적용하거나 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-371">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="0f7cc-372">`(?imnsx-imnsx:` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="0f7cc-372">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="0f7cc-373">여기서 *subexpression* 은 임의의 유효한 정규식 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-373">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="0f7cc-374">예를 들어, `(?i-s:)` 는 대/소문자 구분하지 않음을 설정하고 한 줄 모드를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-374">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="0f7cc-375">지정할 수 있는 인라인 옵션에 대한 자세한 내용은 [정규식 옵션](../../../docs/standard/base-types/regular-expression-options.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-375">For more information about the inline options you can specify, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0f7cc-376"><xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> 클래스 생성자 또는 정적 메서드를 사용하여 하위 식이 아니라 전체 정규식에 적용되는 옵션을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-376">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="0f7cc-377">또한 `(?imnsx-imnsx)` 언어 구문을 사용하여 정규식에서 특정 지점 뒤에 적용되는 인라인 옵션을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-377">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="0f7cc-378">그룹 옵션 구문은 캡처링 그룹이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-378">The group options construct is not a capturing group.</span></span> <span data-ttu-id="0f7cc-379">즉, *subexpression* 에 의해 캡처된 문자열의 일부가 일치 항목에 포함되더라도 캡처된 그룹에 포함되지 않으며 <xref:System.Text.RegularExpressions.GroupCollection> 개체를 채우는 데 사용되지도 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-379">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="0f7cc-380">예를 들어, 다음 예제의 정규식 `\b(?ix: d \w+)\s`는 문자 "d"로 시작하는 모든 단어를 식별할 때 대/소문자를 구분하지 않는 일치를 사용하도록 설정하고 패턴 공백을 무시하기 위해 그룹화 구문에 인라인 옵션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-380">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern white space in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="0f7cc-381">정규식은 다음 테이블과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-381">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="0f7cc-382">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-382">Pattern</span></span>|<span data-ttu-id="0f7cc-383">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-383">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="0f7cc-384">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-384">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="0f7cc-385">이 패턴에서 대/소문자를 구분하지 않는 일치를 사용하고 공백을 무시하여 "d" 다음에 하나 이상의 단어 문자가 있는 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-385">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="0f7cc-386">공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-386">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>   
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="0f7cc-387">너비가 0인 긍정 lookahead 어설션</span><span class="sxs-lookup"><span data-stu-id="0f7cc-387">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="0f7cc-388">다음 그룹화 구문은 너비가 0인 긍정 lookahead 어설션을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-388">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="0f7cc-389">`(?=` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="0f7cc-389">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="0f7cc-390">여기서 *subexpression* 은 임의의 정규식 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-390">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="0f7cc-391">찾기가 성공하려면 일치하는 부분 문자열이 일치 결과에 포함되지 않더라도 입력 문자열이 *subexpression*의 정규식 패턴과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-391">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="0f7cc-392">너비가 0인 긍정 lookahead 어설션은 역추적하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-392">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="0f7cc-393">일반적으로 너비가 0인 긍정 lookahead 어설션은 정규식 패턴의 끝 부분에서 찾을 수 있으며,</span><span class="sxs-lookup"><span data-stu-id="0f7cc-393">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="0f7cc-394">일치가 발생하도록 문자열의 끝 부분에 있어야 하지만 일치에 포함되어서는 안 되는 부분 문자열을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-394">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="0f7cc-395">또한 이 어설션은 과도한 역추적을 방지하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-395">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="0f7cc-396">너비가 0인 긍정 lookahead 어설션을 사용하여, 특정 캡처된 그룹이 해당 캡처된 그룹에 대해 정의된 패턴의 하위 집합과 일치하는 텍스트로 시작하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-396">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="0f7cc-397">예를 들어, 캡처링 그룹이 연속 단어 문자와 일치하는 경우 너비가 0인 긍정 lookahead 어설션을 사용하여 첫 번째 문자가 대문자 영문자가 되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-397">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="0f7cc-398">다음 예제에서는 너비가 0인 긍정 lookahead 어설션을 사용하여 입력 문자열에서 동사 "is" 앞에 오는 단어를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-398">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="0f7cc-399">정규식 `\b\w+(?=\sis\b)` 는 다음 테이블과 같이 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-399">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="0f7cc-400">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-400">Pattern</span></span>|<span data-ttu-id="0f7cc-401">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-401">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="0f7cc-402">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-402">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="0f7cc-403">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-403">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="0f7cc-404">단어 문자 뒤에 공백 문자와 문자열 "is"(단어 경계에서 끝남)가 오는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-404">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="0f7cc-405">그럴 경우 찾기가 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-405">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>   
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="0f7cc-406">너비가 0인 부정 lookahead 어설션</span><span class="sxs-lookup"><span data-stu-id="0f7cc-406">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="0f7cc-407">다음 그룹화 구문은 너비가 0인 부정 lookahead 어설션을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-407">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="0f7cc-408">`(?!` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="0f7cc-408">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="0f7cc-409">여기서 *subexpression* 은 임의의 정규식 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-409">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="0f7cc-410">찾기가 성공하려면 일치하는 문자열이 일치 결과에 포함되지 않더라도 입력 문자열이 *subexpression*의 정규식 패턴과 일치해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-410">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="0f7cc-411">너비가 0인 부정 lookahead 어설션은 일반적으로 정규식의 시작 부분이나 끝 부분에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-411">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="0f7cc-412">정규식의 시작 부분에서 이 어설션은 정규식의 시작 부분이 유사하지만 더 일반적인 찾으려는 패턴을 정의할 때 일치해서는 안 되는 특정 패턴을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-412">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="0f7cc-413">이 경우 이 어설션은 흔히 역추적을 제한하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-413">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="0f7cc-414">정규식의 끝 부분에서 이 어설션은 일치의 끝 부분에서 발생할 수 없는 하위 식을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-414">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="0f7cc-415">다음 예제에서는 "un"으로 시작하지 않는 단어를 찾기 위해 정규식의 시작 부분에서 너비가 0인 lookahead 어설션을 사용하는 정규식을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-415">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="0f7cc-416">정규식 `\b(?!un)\w+\b` 는 다음 테이블과 같이 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-416">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="0f7cc-417">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-417">Pattern</span></span>|<span data-ttu-id="0f7cc-418">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-418">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="0f7cc-419">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-419">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="0f7cc-420">다음 두 문자가 "un"인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-420">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="0f7cc-421">그러지 않은 경우 일치가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-421">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="0f7cc-422">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-422">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="0f7cc-423">단어 경계에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-423">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="0f7cc-424">다음 예제에서는 문장 부호 문자로 끝나지 않는 단어를 찾기 위해 정규식의 끝 부분에서 너비가 0인 lookahead 어설션을 사용하는 정규식을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-424">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="0f7cc-425">정규식 `\b\w+\b(?!\p{P})` 는 다음 테이블과 같이 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-425">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="0f7cc-426">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-426">Pattern</span></span>|<span data-ttu-id="0f7cc-427">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-427">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="0f7cc-428">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-428">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="0f7cc-429">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-429">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="0f7cc-430">단어 경계에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-430">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="0f7cc-431">다음 문자가 문장 부호 기호(예: 마침표 또는 쉼표)가 아닌 경우 찾기가 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-431">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>   
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="0f7cc-432">너비가 0인 긍정 lookbehind 어설션</span><span class="sxs-lookup"><span data-stu-id="0f7cc-432">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="0f7cc-433">다음 그룹화 구문은 너비가 0인 긍정 lookbehind 어설션을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-433">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="0f7cc-434">`(?<=` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="0f7cc-434">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="0f7cc-435">여기서 *subexpression* 은 임의의 정규식 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-435">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="0f7cc-436">찾기가 성공하려면 `subexpression`이 일치 결과에 포함되지 않더라도 *subexpression*이 입력 문자열에서 현재 위치의 왼쪽에서 발생해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-436">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="0f7cc-437">너비가 0인 긍정 lookbehind 어설션은 역추적하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-437">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="0f7cc-438">너비가 0인 긍정 lookbehind 어설션은 일반적으로 정규식의 시작 부분에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-438">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="0f7cc-439">이 어설션이 정의하는 패턴은 이 패턴이 일치 결과에 포함되지 않더라도 일치에 대한 사전 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-439">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="0f7cc-440">예를 들어, 다음 예제에서는 21세기 연도의 마지막 두 자리를 찾습니다(즉, 숫자 "20"이 일치하는 문자열 앞에 와야 함).</span><span class="sxs-lookup"><span data-stu-id="0f7cc-440">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="0f7cc-441">정규식 패턴 `(?<=\b20)\d{2}\b` 는 다음 테이블과 같이 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-441">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="0f7cc-442">패턴</span><span class="sxs-lookup"><span data-stu-id="0f7cc-442">Pattern</span></span>|<span data-ttu-id="0f7cc-443">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-443">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="0f7cc-444">두 개의 10진수를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-444">Match two decimal digits.</span></span>|  
|`(?<=\b20)`|<span data-ttu-id="0f7cc-445">단어 경계에서 두 개의 10진수 앞에 10진수 "20"이 있는 경우 일치 항목 찾기를 계속합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-445">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="0f7cc-446">단어 경계에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-446">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="0f7cc-447">너비가 0인 긍정 lookbehind 어설션은 캡처된 그룹의 마지막 문자(하나 또는 여러 개)가 해당 그룹의 정규식 패턴과 일치하는 문자의 하위 집합이어야 하는 경우 역추적을 제한하는 데도 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-447">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="0f7cc-448">예를 들어, 그룹이 모든 연속 단어 문자를 캡처하는 경우 너비가 0인 긍정 lookbehind 어설션을 사용하여 마지막 문자가 사전순이 되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-448">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>   
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="0f7cc-449">너비가 0인 부정 lookbehind 어설션</span><span class="sxs-lookup"><span data-stu-id="0f7cc-449">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="0f7cc-450">다음 그룹화 구문은 너비가 0인 부정 lookbehind 어설션을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-450">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="0f7cc-451">`(?<!` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="0f7cc-451">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="0f7cc-452">여기서 *subexpression* 은 임의의 정규식 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-452">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="0f7cc-453">찾기가 성공하려면 *subexpression* 이 입력 문자열에서 현재 위치의 왼쪽에서 발생해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-453">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="0f7cc-454">그러나 `subexpression` 과 일치하지 않는 모든 부분 문자열은 일치 결과에 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-454">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="0f7cc-455">너비가 0인 부정 lookbehind 어설션은 일반적으로 정규식의 시작 부분에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-455">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="0f7cc-456">이 어설션이 정의하는 패턴은 뒤에 오는 문자열에서 일치가 불가능하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-456">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="0f7cc-457">또한 이 어설션은 캡처된 그룹의 마지막 문자(하나 또는 여러 개)가 해당 그룹의 정규식 패턴과 일치하는 하나 이상의 문자가 아니어야 하는 경우 역추적을 제한하는 데도 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-457">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="0f7cc-458">예를 들어, 그룹이 모든 연속 단어 문자를 캡처하는 경우 너비가 0인 긍정 lookbehind 어설션을 사용하여 마지막 문자가 밑줄(_)이 아니도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-458">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</span></span>  
  
 <span data-ttu-id="0f7cc-459">다음 예제에서는 주말이 아닌 평일인 날짜를 찾습니다(즉, 토요일 및 일요일이 아님).</span><span class="sxs-lookup"><span data-stu-id="0f7cc-459">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="0f7cc-460">정규식 패턴 `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` 는 다음 테이블과 같이 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-460">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="0f7cc-461">패턴</span><span class="sxs-lookup"><span data-stu-id="0f7cc-461">Pattern</span></span>|<span data-ttu-id="0f7cc-462">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-462">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="0f7cc-463">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-463">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="0f7cc-464">하나 이상의 단어 문자 다음에 공백 문자가 있는 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-464">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="0f7cc-465">한 개 또는 두 개의 10진수 다음에 공백 문자 하나와 쉼표 하나가 있는 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-465">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="0f7cc-466">네 개의 10진수를 찾고 단어 경계에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-466">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="0f7cc-467">일치 항목 앞에 문자열 "Saturday" 또는 "Sunday"가 아닌 문자열이 있고 해당 문자열 뒤에 공백이 하나 있으면 찾기가 성공한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-467">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="nonbacktracking_subexpression"></a>   
## <a name="nonbacktracking-subexpressions"></a><span data-ttu-id="0f7cc-468">역추적하지 않는 하위 식</span><span class="sxs-lookup"><span data-stu-id="0f7cc-468">Nonbacktracking Subexpressions</span></span>  
 <span data-ttu-id="0f7cc-469">다음 그룹화 구문은 역추적하지 않는 하위 식("greedy" 하위 식이라고도 함)을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-469">The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</span></span>  
  
 <span data-ttu-id="0f7cc-470">`(?>` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="0f7cc-470">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="0f7cc-471">여기서 *subexpression* 은 임의의 정규식 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-471">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="0f7cc-472">대개 정규식에 선택적 또는 대체 일치 패턴이 포함되어 있고 찾기가 실패하는 경우 정규식 엔진이 입력 문자열을 패턴과 일치시키기 위해 여러 방향으로 분기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-472">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="0f7cc-473">첫 번째 분기를 사용하여 일치 항목을 찾을 수 없는 경우 정규식 엔진은 첫 번째 일치 항목을 사용한 지점을 백업하거나 해당 지점으로 역추적한 다음 두 번째 분기를 사용하여 찾기를 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-473">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="0f7cc-474">이 프로세스는 모든 분기가 시도될 때까지 계속될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-474">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="0f7cc-475">이제 `(?>`*subexpression*`)` 언어 구문은 역추적을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-475">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="0f7cc-476">정규식 엔진은 입력 문자열에서 가능한 한 많은 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-476">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="0f7cc-477">일치가 더 이상 불가능한 경우 정규식 엔진은 대체 패턴 일치를 시도하기 위해 역추적하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-477">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="0f7cc-478">(즉, 하위 식은 하위 식 단독으로 일치하는 문자열과만 일치합니다. 정규식 엔진은 하위 식을 기반으로 한 문자열 및 이러한 문자열 뒤에 나오는 하위 식은 찾으려고 시도하지 않습니다.)</span><span class="sxs-lookup"><span data-stu-id="0f7cc-478">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="0f7cc-479">이 옵션은 역추적이 실패할 것임을 아는 경우에 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-479">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="0f7cc-480">정규식 엔진이 불필요한 검색을 수행하지 않도록 하면 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-480">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="0f7cc-481">다음 예제에서는 역추적하지 않는 하위 식이 패턴 일치 결과를 수정하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-481">The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</span></span> <span data-ttu-id="0f7cc-482">역추적 정규식은 단어 경계에서 뒤에 동일한 문자가 하나 더 있는 일련의 반복된 문자를 찾지만 역추적하지 않는 정규식은 그렇지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-482">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="0f7cc-483">역추적하지 않는 정규식 `(?>(\w)\1+).\b` 는 다음 테이블과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-483">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="0f7cc-484">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-484">Pattern</span></span>|<span data-ttu-id="0f7cc-485">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-485">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="0f7cc-486">단일 단어 문자를 찾아 첫 번째 캡처링 그룹에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-486">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="0f7cc-487">캡처된 첫 번째 부분 문자열의 값을 한 번 이상 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-487">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="0f7cc-488">임의의 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-488">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="0f7cc-489">단어 경계에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-489">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="0f7cc-490">하나 이상의 중복된 단어 문자를 찾지만 단어 경계에서 마지막 문자를 일치시키기 위해 역추적하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-490">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>   
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="0f7cc-491">그룹화 구문 및 정규식 개체</span><span class="sxs-lookup"><span data-stu-id="0f7cc-491">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="0f7cc-492">정규식 캡처링 그룹과 일치하는 부분 문자열은 <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> 개체로 표현됩니다. 이 개체는 <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> 속성에서 반환하는 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 개체에서 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-492">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="0f7cc-493"><xref:System.Text.RegularExpressions.GroupCollection> 개체는 다음과 같이 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-493">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
-   <span data-ttu-id="0f7cc-494">컬렉션의 첫 번째 <xref:System.Text.RegularExpressions.Group> 개체(인덱스 0에 있는 개체)는 전체 일치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-494">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
-   <span data-ttu-id="0f7cc-495">다음 <xref:System.Text.RegularExpressions.Group> 개체 집합은 명명되지 않은(번호가 매겨진) 캡처링 그룹을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-495">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="0f7cc-496">이러한 그룹은 정규식에서 정의된 순서로 왼쪽에서 오른쪽으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-496">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="0f7cc-497">이러한 그룹의 인덱스 값 범위는 1에서 컬렉션에 있는 명명되지 않은 캡처링 그룹 수까지입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-497">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="0f7cc-498">(특정 그룹의 인덱스는 번호가 매겨진 해당 역참조와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-498">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="0f7cc-499">역참조에 대한 자세한 내용은 [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md)을 참조하세요.)</span><span class="sxs-lookup"><span data-stu-id="0f7cc-499">For more information about backreferences, see [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span></span>  
  
-   <span data-ttu-id="0f7cc-500">최종 <xref:System.Text.RegularExpressions.Group> 개체 집합은 명명된 캡처링 그룹을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-500">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="0f7cc-501">이러한 그룹은 정규식에서 정의된 순서로 왼쪽에서 오른쪽으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-501">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="0f7cc-502">명명된 첫 번째 캡처링 그룹의 인덱스 값은 명명되지 않은 마지막 캡처링 그룹의 인덱스보다 1 큽니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-502">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="0f7cc-503">정규식에 명명되지 않은 캡처링 그룹이 없는 경우 명명된 첫 번째 캡처링 그룹의 인덱스 값은 1입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-503">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="0f7cc-504">캡처링 그룹에 수량자를 적용하는 경우 해당 <xref:System.Text.RegularExpressions.Group> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> 속성은 캡처링 그룹에 의해 캡처된 마지막 부분 문자열을 반영합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-504">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="0f7cc-505"><xref:System.Text.RegularExpressions.CaptureCollection> 속성에서 반환하는 <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> 개체의 수량자를 포함하는 그룹에 의해 캡처된 부분 문자열의 전체 집합을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-505">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="0f7cc-506">다음 예제에서는 <xref:System.Text.RegularExpressions.Group> 개체와 <xref:System.Text.RegularExpressions.Capture> 개체 간의 관계를 명확하게 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-506">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="0f7cc-507">정규식 패턴 `\b(\w+)\W+)+` 는 문자열에서 개별 단어를 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-507">The regular expression pattern `\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="0f7cc-508">이 패턴은 다음 표에서와 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-508">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="0f7cc-509">무늬</span><span class="sxs-lookup"><span data-stu-id="0f7cc-509">Pattern</span></span>|<span data-ttu-id="0f7cc-510">설명</span><span class="sxs-lookup"><span data-stu-id="0f7cc-510">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="0f7cc-511">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-511">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="0f7cc-512">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-512">Match one or more word characters.</span></span> <span data-ttu-id="0f7cc-513">이러한 문자는 함께 하나의 단어를 형성합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-513">Together, these characters form a word.</span></span> <span data-ttu-id="0f7cc-514">이 그룹은 두 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-514">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="0f7cc-515">하나 이상의 단어가 아닌 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-515">Match one or more non-word characters.</span></span>|  
|`(\w+)\W+)+`|<span data-ttu-id="0f7cc-516">하나 이상의 단어 문자 다음에 하나 이상의 단어가 아닌 문자가 한 번 이상 나타나는 패턴을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-516">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="0f7cc-517">이 그룹은 첫 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-517">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="0f7cc-518">첫 번째 캡처링 그룹은 문장의 각 단어를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-518">The first capturing group matches each word of the sentence.</span></span> <span data-ttu-id="0f7cc-519">두 번째 캡처링 그룹은 각 단어와 이러한 단어 뒤에 나오는 문장 부호 및 공백을 함께 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-519">The second capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="0f7cc-520">인덱스가 2인 <xref:System.Text.RegularExpressions.Group> 개체는 두 번째 캡처링 그룹과 일치하는 텍스트에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-520">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="0f7cc-521">캡처링 그룹에 의해 캡처된 단어의 전체 집합은 <xref:System.Text.RegularExpressions.CaptureCollection> 속성에서 반환하는 <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> 개체에서 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0f7cc-521">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0f7cc-522">참고 항목</span><span class="sxs-lookup"><span data-stu-id="0f7cc-522">See Also</span></span>  
 [<span data-ttu-id="0f7cc-523">정규식 언어 - 빠른 참조</span><span class="sxs-lookup"><span data-stu-id="0f7cc-523">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
 [<span data-ttu-id="0f7cc-524">역추적</span><span class="sxs-lookup"><span data-stu-id="0f7cc-524">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)

---
title: "스레드로부터 안전한 컬렉션"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
caps.latest.revision: "24"
author: mairaw
ms.author: mairaw
manager: wpickett
ms.openlocfilehash: b5394cd2e9c9fa2b0cacb93ddf2cf05b33fabc71
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/18/2017
---
# <a name="thread-safe-collections"></a><span data-ttu-id="16262-102">스레드로부터 안전한 컬렉션</span><span class="sxs-lookup"><span data-stu-id="16262-102">Thread-Safe Collections</span></span>
<span data-ttu-id="16262-103">[!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)]에서는 네임스페이스는 스레드로부터 안전하면서 확장 가능한 몇 가지 컬렉션 클래스를 포함하는 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 네임스페이스를 도입합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-103">The [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="16262-104">여러 스레드는 사용자 코드에서 추가로 동기화할 필요없이 이러한 컬렉션으로부터 안전하고 효율적으로 항목을 추가하거나 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16262-104">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="16262-105">새 코드를 작성하는 경우 컬렉션이 여러 스레드를 동시에 작성할 때마다 동시 컬렉션 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-105">When you write new code, use the concurrent collection classes whenever the collection will be writing to multiple threads concurrently.</span></span> <span data-ttu-id="16262-106">공유 컬렉션에서 읽기만 하는 경우에 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 클래스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16262-106">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="16262-107">.NET Framework 1.1 또는 이전 런타임을 대상으로 해야 하는 경우가 아니면 1.0 컬렉션 클래스를 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="16262-107">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="16262-108">.NET Framework 1.0 및 2.0 컬렉션에서 스레드 동기화</span><span class="sxs-lookup"><span data-stu-id="16262-108">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="16262-109">.NET Framework 1.0에 도입된 컬렉션은 <xref:System.Collections?displayProperty=nameWithType> 네임스페이스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16262-109">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="16262-110">일반적으로 사용되는 <xref:System.Collections.ArrayList> 및 <xref:System.Collections.Hashtable>을 포함하는 이러한 컬렉션은 컬렉션 주변에서 스레드로부터 안전한 래퍼를 반환하는 `Synchronized` 속성을 통해 어느 정도 스레드로부터의 안전성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-110">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="16262-111">래퍼는 모든 추가 또는 제거 작업에서 전체 컬렉션을 잠그는 방식으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-111">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="16262-112">따라서 컬렉션에 액세스하려고 하는 각 스레드는 잠금을 사용하기 위해 차례를 기다려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-112">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="16262-113">이것은 확장할 수 없고 큰 컬렉션에 상당한 성능 저하가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16262-113">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="16262-114">또한 디자인은 경합 조건에서 완전히 보호되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="16262-114">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="16262-115">자세한 내용은 MSDN 웹 사이트의 [제네릭 컬렉션에서의 동기화](http://go.microsoft.com/fwlink/?LinkID=161130)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="16262-115">For more information, see [Synchronization in Generic Collections](http://go.microsoft.com/fwlink/?LinkID=161130) on the MSDN Web site.</span></span>  
  
 <span data-ttu-id="16262-116">.NET Framework 2.0에 도입된 컬렉션 클래스는 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16262-116">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="16262-117">여기에는 <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602> 등이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="16262-117">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="16262-118">이러한 클래스는 .NET Framework 1.0 클래스에 비해 형식 안정성 및 성능을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="16262-118">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="16262-119">그러나 .NET Framework 2.0 컬렉션 클래스는 스레드 동기화를 제공하지 않습니다. 여러 스레드에서 동시에 항목이 추가되거나 제거되는 경우 사용자 코드에서는 모든 동기화를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-119">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="16262-120">[!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)]의 동시 컬렉션 클래스는 .NET Framework 2.0 컬렉션 클래스의 형식 안전성을 제공할 뿐만 아니라 [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)] 컬렉션이 제공하는 스레드로부터의 안전성보다 더 효율적이고 안전하기 때문에 권장됩니다.</span><span class="sxs-lookup"><span data-stu-id="16262-120">We recommend the concurrent collections classes in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)] collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="16262-121">세부적인 잠금 및 잠금 해제 메커니즘</span><span class="sxs-lookup"><span data-stu-id="16262-121">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="16262-122">동시 컬렉션 형식의 일부에서는 [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)]에 새로 도입된 <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim> 및 <xref:System.Threading.CountdownEvent>와 같은 간단한 동기화 메커니즘을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-122">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)].</span></span> <span data-ttu-id="16262-123">실제로 이러한 동기화 형식이 스레드를 Wait 상태로 전환하기 전 짧은 기간 동안에는 일반적으로 *사용 중인 회전*을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-123">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="16262-124">대기 시간이 매우 짧을 경우 회전은 비용이 많이 드는 커널 전환을 포함하는 대기보다 훨씬 계산 비용이 적습니다.</span><span class="sxs-lookup"><span data-stu-id="16262-124">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="16262-125">회전을 사용하는 컬렉션 클래스의 경우 이 효율성 덕분에 여러 스레드가 매우 빠른 속도로 항목을 추가하고 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16262-125">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="16262-126">회전 및 차단에 대한 자세한 내용은 [SpinLock](../../../../docs/standard/threading/spinlock.md) 및 [SpinWait](../../../../docs/standard/threading/spinwait.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="16262-126">For more information about spinning vs. blocking, see [SpinLock](../../../../docs/standard/threading/spinlock.md) and [SpinWait](../../../../docs/standard/threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="16262-127"><xref:System.Collections.Concurrent.ConcurrentQueue%601> 및 <xref:System.Collections.Concurrent.ConcurrentStack%601> 클래스는 잠금을 전혀 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="16262-127">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="16262-128">대신, 스레드로부터의 안전성을 달성하기 위해 <xref:System.Threading.Interlocked> 작업을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-128">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="16262-129">동시 컬렉션 클래스가 <xref:System.Collections.ICollection>을 지원하기 때문에 이러한 속성이 관련되지 않은 경우에도 <xref:System.Collections.ICollection.IsSynchronized%2A> 및 <xref:System.Collections.ICollection.SyncRoot%2A> 속성에 대한 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-129">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="16262-130">`IsSynchronized`는 항상 `false`를 반환하고 `SyncRoot`는 항상 `null`(Visual Basic의 `Nothing`)입니다.</span><span class="sxs-lookup"><span data-stu-id="16262-130">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="16262-131">다음 테이블에서는 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 네임스페이스의 컬렉션 형식을 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-131">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="16262-132">형식</span><span class="sxs-lookup"><span data-stu-id="16262-132">Type</span></span>|<span data-ttu-id="16262-133">설명</span><span class="sxs-lookup"><span data-stu-id="16262-133">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="16262-134"><xref:System.Collections.Concurrent.IProducerConsumerCollection%601>을 구현하는 모든 형식에 대해 경계 및 차단 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-134">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="16262-135">자세한 내용은 [BlockingCollection 개요](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="16262-135">For more information, see [BlockingCollection Overview](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="16262-136">키-값 쌍의 사전을 스레드로부터 안전하게 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-136">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="16262-137">FIFO(선입선출) 큐를 스레드로부터 안전하게 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-137">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="16262-138">LIFO(후입선출) 스택을 스레드로부터 안전하게 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-138">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="16262-139">요소의 순서 없는 컬렉션을 스레드로부터 안전하게 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-139">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="16262-140">형식이 `BlockingCollection`에 사용하도록 구현해야 하는 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="16262-140">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="16262-141">관련 항목</span><span class="sxs-lookup"><span data-stu-id="16262-141">Related Topics</span></span>  
  
|<span data-ttu-id="16262-142">제목</span><span class="sxs-lookup"><span data-stu-id="16262-142">Title</span></span>|<span data-ttu-id="16262-143">설명</span><span class="sxs-lookup"><span data-stu-id="16262-143">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="16262-144">BlockingCollection 개요</span><span class="sxs-lookup"><span data-stu-id="16262-144">BlockingCollection Overview</span></span>](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)|<span data-ttu-id="16262-145"><xref:System.Collections.Concurrent.BlockingCollection%601> 형식에서 제공하는 기능에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-145">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="16262-146">방법: ConcurrentDictionary에서 항목 추가 및 제거</span><span class="sxs-lookup"><span data-stu-id="16262-146">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-remove-items.md)|<span data-ttu-id="16262-147"><xref:System.Collections.Concurrent.ConcurrentDictionary%602>에서 요소를 추가하고 제거하는 방법에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-147">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="16262-148">방법: BlockingCollection에서 개별적으로 항목 추가 및 가져오기</span><span class="sxs-lookup"><span data-stu-id="16262-148">How to: Add and Take Items Individually from a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)|<span data-ttu-id="16262-149">읽기 전용 열거자를 사용하지 않고 차단 컬렉션에서 항목을 추가하고 검색하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-149">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="16262-150">방법: 컬렉션에 경계 및 차단 기능 추가</span><span class="sxs-lookup"><span data-stu-id="16262-150">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)|<span data-ttu-id="16262-151">컬렉션 클래스를 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 컬렉션에 대한 기본 저장소 메커니즘으로 사용하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-151">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="16262-152">방법: ForEach를 사용하여 BlockingCollection의 항목 제거</span><span class="sxs-lookup"><span data-stu-id="16262-152">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)|<span data-ttu-id="16262-153">`foreach`(Visual Basic의 `For Each`)를 사용하여 차단 컬렉션에서 모든 항목을 제거하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-153">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="16262-154">방법: 파이프라인에서 차단 컬렉션 배열 사용</span><span class="sxs-lookup"><span data-stu-id="16262-154">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="16262-155">파이프라인을 구현하는 동시에 여러 차단 컬렉션을 사용하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="16262-155">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="16262-156">방법: ConcurrentBag을 사용하여 개체 풀 만들기</span><span class="sxs-lookup"><span data-stu-id="16262-156">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](../../../../docs/standard/collections/thread-safe/how-to-create-an-object-pool.md)|<span data-ttu-id="16262-157">개체를 끊임없이 새로 만드는 대신 다시 사용할 수 있는 시나리오에서 동시 모음을 사용하고 성능을 향상시키는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="16262-157">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="16262-158">참조</span><span class="sxs-lookup"><span data-stu-id="16262-158">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>

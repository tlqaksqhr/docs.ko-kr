---
title: 연결된 자식 작업 및 분리된 자식 작업
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, child tasks
ms.assetid: c95788bf-90a6-4e96-b7bc-58e36a228cc5
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 53f31402e78a15289bb996c63e1e8e3cd98e6aac
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33590774"
---
# <a name="attached-and-detached-child-tasks"></a><span data-ttu-id="fb46e-102">연결된 자식 작업 및 분리된 자식 작업</span><span class="sxs-lookup"><span data-stu-id="fb46e-102">Attached and Detached Child Tasks</span></span>
<span data-ttu-id="fb46e-103">‘자식 작업’(또는 ‘중첩 작업’)은 ‘부모 작업’이라는 다른 작업의 사용자 대리자에 만들어진 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-103">A *child task* (or *nested task*) is a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> instance that is created in the user delegate of another task, which is known as the *parent task*.</span></span> <span data-ttu-id="fb46e-104">자식 작업을 분리하거나 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-104">A child task can be either detached or attached.</span></span> <span data-ttu-id="fb46e-105">‘분리된 자식 작업’은 부모와 독립적으로 실행되는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-105">A *detached child task* is a task that executes independently of its parent.</span></span> <span data-ttu-id="fb46e-106">‘연결된 자식 작업’은 부모가 명시적으로나 기본적으로 연결을 금지하지 않는 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 옵션으로 만들어진 중첩 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-106">An *attached child task* is a nested task that is created with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option whose parent does not explicitly or by default prohibit it from being attached.</span></span> <span data-ttu-id="fb46e-107">연결된 자식 작업 및 분리된 자식 작업은 작업에서 개수와 관계없이 만들 수 있고 시스템 자원에 의해서만 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-107">A task may create any number of attached and detached child tasks, limited only by system resources.</span></span>  
  
 <span data-ttu-id="fb46e-108">다음 표에는 두 가지 자식 작업의 기본적인 차이점이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-108">The following table lists the basic differences between the two kinds of child tasks.</span></span>  
  
|<span data-ttu-id="fb46e-109">범주</span><span class="sxs-lookup"><span data-stu-id="fb46e-109">Category</span></span>|<span data-ttu-id="fb46e-110">분리된 자식 작업</span><span class="sxs-lookup"><span data-stu-id="fb46e-110">Detached child tasks</span></span>|<span data-ttu-id="fb46e-111">연결된 자식 작업</span><span class="sxs-lookup"><span data-stu-id="fb46e-111">Attached child tasks</span></span>|  
|--------------|--------------------------|--------------------------|  
|<span data-ttu-id="fb46e-112">부모는 자식 작업이 완료될 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-112">Parent waits for child tasks to complete.</span></span>|<span data-ttu-id="fb46e-113">아니요</span><span class="sxs-lookup"><span data-stu-id="fb46e-113">No</span></span>|<span data-ttu-id="fb46e-114">예</span><span class="sxs-lookup"><span data-stu-id="fb46e-114">Yes</span></span>|  
|<span data-ttu-id="fb46e-115">부모는 자식 작업에서 throw된 예외를 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-115">Parent propagates exceptions thrown by child tasks.</span></span>|<span data-ttu-id="fb46e-116">아니요</span><span class="sxs-lookup"><span data-stu-id="fb46e-116">No</span></span>|<span data-ttu-id="fb46e-117">예</span><span class="sxs-lookup"><span data-stu-id="fb46e-117">Yes</span></span>|  
|<span data-ttu-id="fb46e-118">부모 상태는 자식 상태에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-118">Status of parent depends on status of child.</span></span>|<span data-ttu-id="fb46e-119">아니요</span><span class="sxs-lookup"><span data-stu-id="fb46e-119">No</span></span>|<span data-ttu-id="fb46e-120">예</span><span class="sxs-lookup"><span data-stu-id="fb46e-120">Yes</span></span>|  
  
 <span data-ttu-id="fb46e-121">분리된 자식 작업과 다른 작업과의 관계가 덜 복잡하므로 대부분 시나리오에서 해당 자식 작업을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-121">In most scenarios, we recommend that you use detached child tasks, because their relationships with other tasks are less complex.</span></span> <span data-ttu-id="fb46e-122">이는 부모 작업 내부에서 만들어진 작업은 기본적으로 분리되기 때문이고, 연결된 자식 작업을 만들려면 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 옵션을 명시적으로 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-122">That is why tasks created inside parent tasks are detached by default, and you must explicitly specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option to create an attached child task.</span></span>  
  
## <a name="detached-child-tasks"></a><span data-ttu-id="fb46e-123">분리된 자식 작업</span><span class="sxs-lookup"><span data-stu-id="fb46e-123">Detached child tasks</span></span>  
 <span data-ttu-id="fb46e-124">자식 작업이 부모 작업에 의해 만들어지면 기본적으로 부모 작업과 독립적입니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-124">Although a child task is created by a parent task, by default it is independent of the parent task.</span></span> <span data-ttu-id="fb46e-125">다음 예제에서는 부모 작업에서 단순한 자식 작업 하나를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-125">In the following example, a parent task creates one simple child task.</span></span> <span data-ttu-id="fb46e-126">예제 코드를 여러 번 실행하면 예제의 출력이 표시된 내용과 다르고 코드를 실행할 때마다 출력이 변경될 수 있음을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-126">If you run the example code multiple times, you may notice that the output from the example differs from that shown, and also that the output may change each time you run the code.</span></span> <span data-ttu-id="fb46e-127">부모 작업과 자식 작업은 서로 독립적으로 실행되기 때문에 이 문제가 발생합니다. 자식은 분리된 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-127">This occurs because the parent task and child tasks execute independently of each other; the child is a detached task.</span></span> <span data-ttu-id="fb46e-128">예제에서는 부모 작업이 완료될 때까지 대기하고 자식 작업은 콘솔 앱이 종료되기 전에 실행되거나 완료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-128">The example waits only for the parent task to complete, and the child task may not execute or complete before the console app terminates.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/nested1.cs#1)]
 [!code-vb[TPL_ChildTasks#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/nested1.vb#1)]  
  
 <span data-ttu-id="fb46e-129">자식 작업을 <xref:System.Threading.Tasks.Task> 개체가 아닌 <xref:System.Threading.Tasks.Task%601> 개체로 표시하면 부모 작업은 자식이 분리된 자식 작업이더라도 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성에 액세스하여 자식이 완료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-129">If the child task is represented by a <xref:System.Threading.Tasks.Task%601> object rather than a <xref:System.Threading.Tasks.Task> object, you can ensure that the parent task will wait for the child to complete by accessing the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the child even if it is a detached child task.</span></span> <span data-ttu-id="fb46e-130"><xref:System.Threading.Tasks.Task%601.Result%2A> 속성은 다음 예제와 같이 해당 작업이 완료될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-130">The <xref:System.Threading.Tasks.Task%601.Result%2A> property blocks until its task completes, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/childtasks.cs#4)]
 [!code-vb[TPL_ChildTasks#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/tpl_childtasks.vb#4)]  
  
## <a name="attached-child-tasks"></a><span data-ttu-id="fb46e-131">연결된 자식 작업</span><span class="sxs-lookup"><span data-stu-id="fb46e-131">Attached child tasks</span></span>  
 <span data-ttu-id="fb46e-132">분리된 자식 작업과 달리 연결된 자식 작업은 부모와 밀접하게 동기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-132">Unlike detached child tasks, attached child tasks are closely synchronized with the parent.</span></span> <span data-ttu-id="fb46e-133">다음 예제와 같이 작업 만들기 문에서 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 옵션을 사용하여 연결된 자식 작업에 대한 이전 예제에서 분리된 자식 작업을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-133">You can change the detached child task in the previous example to an attached child task by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option in the task creation statement, as shown in the following example.</span></span> <span data-ttu-id="fb46e-134">이 코드에서는 연결된 자식 작업이 부모보다 먼저 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-134">In this code, the attached child task completes before its parent.</span></span> <span data-ttu-id="fb46e-135">따라서 예제의 출력은 코드를 실행할 때마다 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-135">As a result, the output from the example is the same each time you run the code.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/child1.cs#2)]
 [!code-vb[TPL_ChildTasks#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/child1.vb#2)]  
  
 <span data-ttu-id="fb46e-136">연결된 자식 작업을 사용하여 비동기 작업의 밀접하게 동기화된 그래프를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-136">You can use attached child tasks to create tightly synchronized graphs of asynchronous operations.</span></span>  
  
 <span data-ttu-id="fb46e-137">그러나 부모가 연결된 자식 작업을 금지하지 않는 경우에만 자식 작업이 부모에 연결될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-137">However, a child task can attach to its parent only if its parent does not prohibit attached child tasks.</span></span> <span data-ttu-id="fb46e-138">부모 작업은 부모 작업의 클래스 생성자 또는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드에서 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 옵션을 지정하여 명시적으로 자식 작업이 부모 작업에 연결되지 않도록 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-138">Parent tasks can explicitly prevent child tasks from attaching to them by specifying the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option in the parent task's class constructor or the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="fb46e-139"><xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드 호출을 통해 만들어진 부모 작업은 명시적으로 자식 작업이 부모 작업에 연결되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-139">Parent tasks implicitly prevent child tasks from attaching to them if they are created by calling the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="fb46e-140">다음은 이에 대한 예입니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-140">The following example illustrates this.</span></span> <span data-ttu-id="fb46e-141">부모 작업이 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> 메서드가 아닌 <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> 메서드를 호출하여 만들어진다는 점을 제외하고 이전 예제와 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-141">It is identical to the previous example, except that the parent task is created by calling the <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> method rather than the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="fb46e-142">자식 작업이 부모에 연결할 수 없으므로 예제의 출력을 예측할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-142">Because the child task is not able to attach to its parent, the output from the example is unpredictable.</span></span> <span data-ttu-id="fb46e-143"><xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 오버로드에 대한 기본 작업 만들기 옵션에 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>가 포함되므로 이 예제는 “분리된 자식 작업" 섹션의 첫 번째 예제와 기능상으로 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-143">Because the default task creation options for the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> overloads include <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>, this example is functionally equivalent to the first example in the "Detached child tasks" section.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/child1a.cs#3)]
 [!code-vb[TPL_ChildTasks#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/child1a.vb#3)]  
  
## <a name="exceptions-in-child-tasks"></a><span data-ttu-id="fb46e-144">자식 작업의 예외</span><span class="sxs-lookup"><span data-stu-id="fb46e-144">Exceptions in child tasks</span></span>  
 <span data-ttu-id="fb46e-145">분리된 자식 작업에서 예외가 throw되면 중첩되지 않은 작업처럼 부모 작업에서 직접 해당 예외를 관찰하거나 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-145">If a detached child task throws an exception, that exception must be observed or handled directly in the parent task just as with any non-nested task.</span></span> <span data-ttu-id="fb46e-146">연결된 자식 작업에서 예외가 throw되면 해당 예외는 자동으로 부모 작업에 전파되고 다시 작업의 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성을 기다리거나 속성에 액세스하는 스레드에 전파됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-146">If an attached child task throws an exception, the exception is automatically propagated to the parent task and back to the thread that waits or tries to access the task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="fb46e-147">따라서 연결된 자식 작업을 사용하면 호출 스레드에서 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>에 대한 호출의 한 지점에서만 모든 예외를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-147">Therefore, by using attached child tasks, you can handle all exceptions at just one point in the call to <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> on the calling thread.</span></span> <span data-ttu-id="fb46e-148">자세한 내용은 [예외 처리](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fb46e-148">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="cancellation-and-child-tasks"></a><span data-ttu-id="fb46e-149">취소 및 자식 작업</span><span class="sxs-lookup"><span data-stu-id="fb46e-149">Cancellation and child tasks</span></span>  
 <span data-ttu-id="fb46e-150">작업 취소는 협조적입니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-150">Task cancellation is cooperative.</span></span> <span data-ttu-id="fb46e-151">즉, 취소할 수 있으려면 모든 연결된 자식 작업과 분리된 자식 작업이 취소 토큰의 상태를 모니터링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-151">That is, to be cancelable, every attached or detached child task must monitor the status of the cancellation token.</span></span> <span data-ttu-id="fb46e-152">하나의 취소 요청을 사용하여 부모 및 모든 자식을 취소하려면 인수와 같은 토큰을 모든 작업에 전달하고 각 작업에서 논리를 제공하여 각 작업의 요청에 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-152">If you want to cancel a parent and all its children by using one cancellation request, you pass the same token as an argument to all tasks and provide in each task the logic to respond to the request in each task.</span></span> <span data-ttu-id="fb46e-153">자세한 내용은 [작업 취소](../../../docs/standard/parallel-programming/task-cancellation.md) 및 [방법: 작업 및 해당 자식 취소](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fb46e-153">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md) and [How to: Cancel a Task and Its Children](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
### <a name="when-the-parent-cancels"></a><span data-ttu-id="fb46e-154">부모가 취소되는 경우</span><span class="sxs-lookup"><span data-stu-id="fb46e-154">When the parent cancels</span></span>  
 <span data-ttu-id="fb46e-155">자식 작업이 시작되기 전에 부모가 자신을 취소하면 자식이 시작되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-155">If a parent cancels itself before its child task is started, the child never starts.</span></span> <span data-ttu-id="fb46e-156">자식 작업이 시작되고 나서 부모가 자신을 취소하면 자체 취소 논리가 없을 경우 자식이 완료까지 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-156">If a parent cancels itself after its child task has already started, the child runs to completion unless it has its own cancellation logic.</span></span> <span data-ttu-id="fb46e-157">자세한 내용은 [작업 취소](../../../docs/standard/parallel-programming/task-cancellation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fb46e-157">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
### <a name="when-a-detached-child-task-cancels"></a><span data-ttu-id="fb46e-158">분리된 자식 작업이 취소되는 경우</span><span class="sxs-lookup"><span data-stu-id="fb46e-158">When a detached child task cancels</span></span>  
 <span data-ttu-id="fb46e-159">분리된 자식 작업이 부모에 전달된 것과 같은 토큰을 사용하여 자신을 취소하고 부모가 하위 작업을 기다리지 않으면, 예외는 심각하지 않은 협력 취소로 처리되므로 전파되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-159">If a detached child task cancels itself by using the same token that was passed to the parent, and the parent does not wait for the child task, no exception is propagated, because the exception is treated as benign cooperation cancellation.</span></span> <span data-ttu-id="fb46e-160">이 동작은 모든 최상위 작업의 동작과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-160">This behavior is the same as that of any top-level task.</span></span>  
  
### <a name="when-an-attached-child-task-cancels"></a><span data-ttu-id="fb46e-161">연결된 자식 작업이 취소되는 경우</span><span class="sxs-lookup"><span data-stu-id="fb46e-161">When an attached child task cancels</span></span>  
 <span data-ttu-id="fb46e-162">연결된 자식 작업이 부모 작업에 전달된 것과 같은 토큰을 사용하여 자신을 취소하면 <xref:System.Threading.Tasks.TaskCanceledException>은 <xref:System.AggregateException> 내부의 조인 스레드에 전파됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-162">When an attached child task cancels itself by using the same token that was passed to its parent task, a <xref:System.Threading.Tasks.TaskCanceledException> is propagated to the joining thread inside an <xref:System.AggregateException>.</span></span> <span data-ttu-id="fb46e-163">연결된 자식 작업의 그래프를 통해 전파되는 오류가 있는 모든 예외 이외에 심각하지 않은 예외를 모두 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-163">You must wait for the parent task so that you can handle all benign exceptions in addition to all faulting exceptions that are propagated up through a graph of attached child tasks.</span></span>  
  
 <span data-ttu-id="fb46e-164">자세한 내용은 [예외 처리](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fb46e-164">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="preventing-a-child-task-from-attaching-to-its-parent"></a><span data-ttu-id="fb46e-165">자식 작업을 해당 부모에 연결하는 것 방지</span><span class="sxs-lookup"><span data-stu-id="fb46e-165">Preventing a child task from attaching to its parent</span></span>  
 <span data-ttu-id="fb46e-166">자식 작업에서 throw된 처리되지 않은 예외는 부모 작업에 전파됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-166">An unhandled exception that is thrown by a child task is propagated to the parent task.</span></span> <span data-ttu-id="fb46e-167">이 동작을 사용하면 작업 트리에서 이동하는 대신 하나의 루트 작업에서 자식 작업 예외를 모두 관찰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-167">You can use this behavior to observe all child task exceptions from one root task instead of traversing a tree of tasks.</span></span> <span data-ttu-id="fb46e-168">그러나 부모 작업에 다른 코드의 첨부 파일이 필요하지 않으면 예외 전파가 문제가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-168">However, exception propagation can be problematic when a parent task does not expect attachment from other code.</span></span> <span data-ttu-id="fb46e-169">예를 들어 <xref:System.Threading.Tasks.Task> 개체에서 타사 라이브러리 구성 요소를 호출하는 앱을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="fb46e-169">For example, consider an app that calls a third-party library component from a <xref:System.Threading.Tasks.Task> object.</span></span> <span data-ttu-id="fb46e-170">타사 라이브러리 구성 요소가 <xref:System.Threading.Tasks.Task> 개체를 만들고 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType>를 지정하여 부모 작업에 연결하면, 자식 작업에서 발생한 처리되지 않은 예외가 부모에 전파됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-170">If the third-party library component also creates a <xref:System.Threading.Tasks.Task> object and specifies <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> to attach it to the parent task, any unhandled exceptions that occur in the child task propagate to the parent.</span></span> <span data-ttu-id="fb46e-171">이로 인해 기본 앱에서 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-171">This could lead to unexpected behavior in the main app.</span></span>  
  
 <span data-ttu-id="fb46e-172">자식 작업이 부모 작업에 연결되지 않도록 방지하려면 부모 <xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601> 개체를 만들 때 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 옵션을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-172">To prevent a child task from attaching to its parent task, specify the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option when you create the parent <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="fb46e-173">작업이 부모에 연결되려고 하고 부모가 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 옵션을 지정하면 자식 작업이 부모에 연결될 수 있고 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 옵션을 지정하지 않은 것처럼 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-173">When a task tries to attach to its parent and the parent specifies the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option, the child task will not be able to attach to a parent and will execute just as if the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option was not specified.</span></span>  
  
 <span data-ttu-id="fb46e-174">자식 작업이 시기적절하게 완료되지 않으면 자식 작업이 부모에 연결되지 않도록 방지할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-174">You might also want to prevent a child task from attaching to its parent when the child task does not finish in a timely manner.</span></span> <span data-ttu-id="fb46e-175">부모 작업은 자식 작업이 모두 완료될 때까지 완료되지 않기 때문에 오래 실행되는 자식 작업은 전체적인 앱의 성능을 저하할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb46e-175">Because a parent task does not finish until all child tasks finish, a long-running child task can cause the overall app to perform poorly.</span></span> <span data-ttu-id="fb46e-176">작업이 부모 작업에 연결되지 않도록 방지하여 앱 성능을 향상하는 방법을 보여주는 예제는 [방법: 자식 작업이 부모 작업에 연결되지 않도록 방지](../../../docs/standard/parallel-programming/how-to-prevent-a-child-task-from-attaching-to-its-parent.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fb46e-176">For an example that shows how to improve app performance by preventing a task from attaching to its parent task, see [How to: Prevent a Child Task from Attaching to its Parent](../../../docs/standard/parallel-programming/how-to-prevent-a-child-task-from-attaching-to-its-parent.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fb46e-177">참고 항목</span><span class="sxs-lookup"><span data-stu-id="fb46e-177">See Also</span></span>  
 [<span data-ttu-id="fb46e-178">병렬 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="fb46e-178">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="fb46e-179">데이터 병렬 처리</span><span class="sxs-lookup"><span data-stu-id="fb46e-179">Data Parallelism</span></span>](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)

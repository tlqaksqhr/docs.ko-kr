---
title: PLINQ 및 TPL에 대한 사용자 지정 파티셔너
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: ''
ms.suite: ''
ms.technology: dotnet-standard
ms.tgt_pltfrm: ''
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
caps.latest.revision: 19
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: bc409a528dd095d3defb0026a48430b10a3ba6f3
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/23/2017
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="7cf03-102">PLINQ 및 TPL에 대한 사용자 지정 파티셔너</span><span class="sxs-lookup"><span data-stu-id="7cf03-102">Custom Partitioners for PLINQ and TPL</span></span>
<span data-ttu-id="7cf03-103">데이터 소스에 대한 작업을 병렬화하기 위한 필수 단계 중 하나는 다중 스레드에서 동시에 액세스 가능한 여러 섹션으로 소스를 ‘분할’하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="7cf03-104">PLINQ 및 TPL(작업 병렬 라이브러리)은 병렬 쿼리 또는 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 루프를 쓸 때 투명하게 작동하는 기본 파티셔너를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="7cf03-105">더 높은 수준의 시나리오에서는 고유한 파티셔너를 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>  
  
## <a name="kinds-of-partitioning"></a><span data-ttu-id="7cf03-106">분할 유형</span><span class="sxs-lookup"><span data-stu-id="7cf03-106">Kinds of Partitioning</span></span>  
 <span data-ttu-id="7cf03-107">데이터 소스를 분할하는 여러 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="7cf03-108">가장 효율적인 방법에서는 소스를 여러 하위 시퀀스로 물리적으로 나누는 대신 여러 스레드가 공동 작업으로 원래 소스 시퀀스를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="7cf03-109">미리 길이가 알려진 <xref:System.Collections.IList> 컬렉션과 같은 배열 및 기타 인덱싱된 소스의 경우 ‘범위 분할’은 가장 간단한 분할 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="7cf03-110">모든 스레드는 고유한 시작 및 끝 인덱스를 수신하므로 다른 스레드가 덮어쓰거나 다른 스레드를 덮어쓰지 않고 소스의 해당 범위를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="7cf03-111">범위 분할에 관련된 유일한 오버헤드는 범위를 만드는 초기 작업입니다. 그 이후에는 추가적인 동기화가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="7cf03-112">따라서 워크로드가 균등하게 나누어지면 좋은 성능을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="7cf03-113">범위 분할의 단점은 한 스레드가 조기에 완료되는 경우 다른 스레드가 작업을 완료하도록 도울 수 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>  
  
 <span data-ttu-id="7cf03-114">연결된 목록 또는 길이가 알려지지 않은 기타 컬렉션의 경우 ‘청크 분할’을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="7cf03-115">청크 분할에서 병렬 루프 또는 쿼리의 모든 스레드 또는 작업은 소스 요소 중 일부를 하나의 청크로 사용하여 처리한 다음, 돌아와서 추가 요소를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="7cf03-116">파티셔너는 모든 요소가 분배되고 중복이 없는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="7cf03-117">청크는 크기에 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-117">A chunk may be any size.</span></span> <span data-ttu-id="7cf03-118">예를 들어 [방법: 동적 파티션 구현](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)에 설명된 파티셔너는 하나의 요소만 포함된 청크를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="7cf03-119">청크가 너무 크지 않다면 스레드에 대한 요소 할당이 미리 결정되지 않으므로 이 분할 유형은 기본적으로 부하 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="7cf03-120">그러나 파티셔너는 스레드가 다른 청크를 가져와야 할 때마다 동기화 오버헤드를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="7cf03-121">이러한 경우에 발생하는 동기화 양은 청크 크기에 반비례합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>  
  
 <span data-ttu-id="7cf03-122">일반적으로 범위 분할은 대리자의 실행 시간이 짧거나 중간 정도이고 소스에 많은 요소가 포함된 경우에만 더 빠르고 각 파티션의 전체 작업은 거의 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="7cf03-123">따라서 청크 분할은 일반적으로 대부분의 경우 더 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="7cf03-124">대리자에 대한 실행 시간이 더 길거나 요소 수가 적은 소스에서는 청크 및 범위 분할 성능이 거의 같습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>  
  
 <span data-ttu-id="7cf03-125">또한 TPL 파티셔너는 동적 파티션 수를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="7cf03-126">즉, 이 파티셔너는 예를 들어 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 루프가 새 작업을 생성할 경우 파티션을 즉시 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="7cf03-127">이 기능을 사용하면 파티셔너가 루프 자체와 함께 확장될 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="7cf03-128">동적 파티셔너는 기본적으로 부하 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="7cf03-129">사용자 지정 파티셔너를 만드는 경우 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 루프에서 사용할 수 있도록 동적 분할을 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>  
  
### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="7cf03-130">PLINQ에 대한 부하 분산 파티셔너 구성</span><span class="sxs-lookup"><span data-stu-id="7cf03-130">Configuring Load Balancing Partitioners for PLINQ</span></span>  
 <span data-ttu-id="7cf03-131"><xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> 메서드의 일부 오버로드를 사용하면 배열 또는 <xref:System.Collections.IList> 소스에 대한 파티셔너를 만들고 스레드 간에 워크로드를 분산하려고 시도할지 여부를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="7cf03-132">파티셔너가 부하 분산되도록 구성된 경우에는 청크 분할이 사용되고 요소가 요청 시 작은 청크로 각 파티션에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="7cf03-133">이 방법은 전체 루프 또는 쿼리가 완료될 때까지 모든 파티션에 처리할 요소가 있는지 확인하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="7cf03-134">추가 오버로드를 사용하여 <xref:System.Collections.IEnumerable> 소스의 부하 분산 분할을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>  
  
 <span data-ttu-id="7cf03-135">일반적으로 부하 분산을 사용하려면 파티션이 파티셔너의 요소를 비교적 자주 요청해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="7cf03-136">반대로 정적 분할을 수행하는 파티셔너는 범위 또는 청크 분할을 사용하여 각 파티셔너에 요소를 한 번에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="7cf03-137">이 작업에 필요한 오버헤드는 부하 분산보다 적지만 한 스레드가 다른 스레드보다 훨씬 더 많은 작업으로 종료될 경우 실행에 시간이 더 오래 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="7cf03-138">기본적으로 IList 또는 배열을 전달할 때 PLINQ는 항상 부하 분산 없이 범위 분할을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="7cf03-139">PLINQ에 대한 부하 분산을 사용하려면 다음 예제에 표시된 것처럼 `Partitioner.Create` 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
 [!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]  
  
 <span data-ttu-id="7cf03-140">해당 시나리오에서 부하 분산을 사용할지 여부를 결정하려면 대표적인 부하 및 컴퓨터 구성에서 작업 완료에 걸리는 시간을 실제로 실험 및 측정하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="7cf03-141">예를 들어 정적 분할은 몇 개의 코어만 있는 멀티 코어 컴퓨터에서 상당한 속도 향상을 제공할 수 있지만, 비교적 많은 코어가 있는 컴퓨터에서는 속도 저하가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>  
  
 <span data-ttu-id="7cf03-142">다음 표에는 <xref:System.Collections.Concurrent.Partitioner.Create%2A> 메서드의 사용 가능한 오버로드가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="7cf03-143">이 파티셔너는 PLINQ 또는 <xref:System.Threading.Tasks.Task>와 함께 사용하도록 제한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="7cf03-144">사용자 지정 병렬 구문과 함께 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-144">They can also be used with any custom parallel construct.</span></span>  
  
|<span data-ttu-id="7cf03-145">오버로드</span><span class="sxs-lookup"><span data-stu-id="7cf03-145">Overload</span></span>|<span data-ttu-id="7cf03-146">부하 분산 사용</span><span class="sxs-lookup"><span data-stu-id="7cf03-146">Uses load balancing</span></span>|  
|--------------|-------------------------|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="7cf03-147">Always</span><span class="sxs-lookup"><span data-stu-id="7cf03-147">Always</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="7cf03-148">부울 인수가 true로 지정될 경우</span><span class="sxs-lookup"><span data-stu-id="7cf03-148">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="7cf03-149">부울 인수가 true로 지정될 경우</span><span class="sxs-lookup"><span data-stu-id="7cf03-149">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="7cf03-150">Never</span><span class="sxs-lookup"><span data-stu-id="7cf03-150">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="7cf03-151">Never</span><span class="sxs-lookup"><span data-stu-id="7cf03-151">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="7cf03-152">Never</span><span class="sxs-lookup"><span data-stu-id="7cf03-152">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="7cf03-153">Never</span><span class="sxs-lookup"><span data-stu-id="7cf03-153">Never</span></span>|  
  
### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="7cf03-154">Parallel.ForEach에 대한 정적 범위 파티셔너 구성</span><span class="sxs-lookup"><span data-stu-id="7cf03-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>  
 <span data-ttu-id="7cf03-155"><xref:System.Threading.Tasks.Parallel.For%2A> 루프에서 루프 본문은 메서드에 대리자로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="7cf03-156">해당 대리자를 호출하는 비용은 가상 메서드 호출과 거의 같습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="7cf03-157">일부 시나리오에서 병렬 루프의 본문은 각 루프 반복에 대한 대리자 호출 비용이 매우 커질 만큼 충분히 작을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="7cf03-158">이 경우 <xref:System.Collections.Concurrent.Partitioner.Create%2A> 오버로드 중 하나를 사용하여 소스 요소에 대해 범위 분할의 <xref:System.Collections.Generic.IEnumerable%601>을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="7cf03-159">그런 다음, 본문이 일반 `for` 루프로 구성된 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 메서드에 이 범위 컬렉션을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="7cf03-160">이 방법의 장점은 대리자 호출 비용이 요소당 한 번이 아니라 범위당 한 번만 발생한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="7cf03-161">다음 예제에서는 기본 패턴을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-161">The following example demonstrates the basic pattern.</span></span>  
  
 [!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
 [!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]  
  
 <span data-ttu-id="7cf03-162">루프의 모든 스레드는 지정된 하위 범위의 시작 및 끝 인덱스 값을 포함하는 자체 <xref:System.Tuple%602>을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="7cf03-163">내부 `for` 루프는 `fromInclusive` 및 `toExclusive` 값을 사용하여 배열 또는 <xref:System.Collections.IList>를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>  
  
 <span data-ttu-id="7cf03-164"><xref:System.Collections.Concurrent.Partitioner.Create%2A> 오버로드 중 하나를 사용하여 파티션 크기와 파티션 수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="7cf03-165">이 오버로드는 요소당 가상 메서드 호출이 하나라도 성능에 큰 영향을 미치도록 요소당 작업이 느린 시나리오에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>  
  
## <a name="custom-partitioners"></a><span data-ttu-id="7cf03-166">사용자 지정 파티셔너</span><span class="sxs-lookup"><span data-stu-id="7cf03-166">Custom Partitioners</span></span>  
 <span data-ttu-id="7cf03-167">일부 시나리오에서는 이것이 고유한 파티셔너를 구현하는 데 유용하거나 필요할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="7cf03-168">예를 들어 클래스의 내부 구조에 대한 지식을 바탕으로 기본 파티셔너가 분할할 수 있는 것보다 더 효율적으로 분할할 수 있는 사용자 지정 컬렉션 클래스가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="7cf03-169">또는 소스 컬렉션의 여러 위치에서 요소를 처리하는 데 걸리는 시간에 대한 지식을 바탕으로 다양한 크기의 범위 파티션을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>  
  
 <span data-ttu-id="7cf03-170">기본 사용자 지정 파티셔너를 만들려면 <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType>에서 클래스를 파생시키고 다음 표에 설명된 대로 가상 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="7cf03-171">이 메서드는 기본 스레드에 의해 한 번 호출되고 IList(IEnumerator(TSource))를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="7cf03-172">루프 또는 쿼리의 각 작업자 스레드는 목록에서 `GetEnumerator`를 호출하여 별도의 파티션에서 <xref:System.Collections.Generic.IEnumerator%601>를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="7cf03-173"><xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>를 구현하는 경우 `true`를 반환하고, 그렇지 않으면 `false`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="7cf03-174"><xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>가 `true`이면 선택적으로 <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> 대신 이 메서드가 호출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="7cf03-175">결과가 정렬 가능해야 하거나 요소에 대한 인덱싱된 액세스가 필요한 경우 <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType>에서 파생시키고 다음 표에 설명된 대로 해당 가상 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="7cf03-176">이 메서드는 기본 스레드에 의해 한 번 호출되고 `IList(IEnumerator(TSource))`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="7cf03-177">루프 또는 쿼리의 각 작업자 스레드는 목록에서 `GetEnumerator`를 호출하여 별도의 파티션에서 <xref:System.Collections.Generic.IEnumerator%601>를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="7cf03-178"><xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>를 구현하는 경우 `true`를 반환하고, 그렇지 않으면 false를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="7cf03-179">일반적으로 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>만 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="7cf03-180"><xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>가 `true`이면 선택적으로 <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> 대신 이 메서드가 호출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="7cf03-181">다음 표에서는 세 종류의 부하 분산 파티셔너가 <xref:System.Collections.Concurrent.OrderablePartitioner%601> 클래스를 구현하는 방법을 추가로 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>  
  
|<span data-ttu-id="7cf03-182">메서드/속성</span><span class="sxs-lookup"><span data-stu-id="7cf03-182">Method/Property</span></span>|<span data-ttu-id="7cf03-183">부하 분산 없는 IList/배열</span><span class="sxs-lookup"><span data-stu-id="7cf03-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="7cf03-184">부하 분산 있는 IList/배열</span><span class="sxs-lookup"><span data-stu-id="7cf03-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="7cf03-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="7cf03-185">IEnumerable</span></span>|  
|----------------------|-------------------------------------------|----------------------------------------|-----------------|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="7cf03-186">범위 분할을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-186">Uses range partitioning</span></span>|<span data-ttu-id="7cf03-187">지정된 partitionCount에 대해 최적화된 청크 분할을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="7cf03-188">정적 개수의 파티션을 만들어 청크 분할을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="7cf03-189">지원되지 않는 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-189">Throws not-supported exception</span></span>|<span data-ttu-id="7cf03-190">목록 및 동적 파티션에 최적화된 청크 분할을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="7cf03-191">동적 개수의 파티션을 만들어 청크 분할을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="7cf03-192">`true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-192">Returns `true`</span></span>|<span data-ttu-id="7cf03-193">`true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-193">Returns `true`</span></span>|<span data-ttu-id="7cf03-194">`true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-194">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="7cf03-195">`true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-195">Returns `true`</span></span>|<span data-ttu-id="7cf03-196">`false`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-196">Returns `false`</span></span>|<span data-ttu-id="7cf03-197">`false`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-197">Returns `false`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="7cf03-198">`true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-198">Returns `true`</span></span>|<span data-ttu-id="7cf03-199">`true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-199">Returns `true`</span></span>|<span data-ttu-id="7cf03-200">`true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-200">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="7cf03-201">`false`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-201">Returns `false`</span></span>|<span data-ttu-id="7cf03-202">`true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-202">Returns `true`</span></span>|<span data-ttu-id="7cf03-203">`true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-203">Returns `true`</span></span>|  
  
### <a name="dynamic-partitions"></a><span data-ttu-id="7cf03-204">동적 파티션</span><span class="sxs-lookup"><span data-stu-id="7cf03-204">Dynamic Partitions</span></span>  
 <span data-ttu-id="7cf03-205"><xref:System.Threading.Tasks.Parallel.ForEach%2A> 메서드에서 파티셔너를 사용하도록 하려면 동적 개수의 파티션을 반환할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="7cf03-206">즉, 파티셔너는 루프 실행 중에 언제든지 요청 시 새 파티션에 대한 열거자를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="7cf03-207">기본적으로 루프는 새 병렬 작업을 추가할 때마다 해당 작업에 대한 새 파티션을 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="7cf03-208">데이터의 순서가 지정 가능해야 하는 경우 각 파티션의 각 항목에 고유한 인덱스가 할당되도록 <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType>에서 파생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>  
  
 <span data-ttu-id="7cf03-209">자세한 내용은 [방법: 동적 파티션 구현](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="7cf03-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
### <a name="contract-for-partitioners"></a><span data-ttu-id="7cf03-210">파티셔너에 대한 계약</span><span class="sxs-lookup"><span data-stu-id="7cf03-210">Contract for Partitioners</span></span>  
 <span data-ttu-id="7cf03-211">사용자 지정 파티셔너를 구현할 경우 다음 지침에 따르면 TPL에서 PLINQ 및 <xref:System.Threading.Tasks.Parallel.ForEach%2A>를 올바르게 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>  
  
-   <span data-ttu-id="7cf03-212"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>가 `partitionsCount`에 대해 0보다 작거나 같은 인수를 사용하여 호출되면 <xref:System.ArgumentOutOfRangeException>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="7cf03-213">PLINQ 및 TPL이 0과 같은 `partitionCount`로는 전달되지 않더라도 가능성을 방지하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>  
  
-   <span data-ttu-id="7cf03-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> 및 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>는 항상 `partitionsCount`개의 파티션을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="7cf03-215">파티셔너가 데이터를 모두 사용해서 요청한 만큼 파티션을 만들 수 없는 경우 메서드는 나머지 파티션에 대해 각각 빈 열거자를 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="7cf03-216">그렇지 않으면 PLINQ 및 TPL이 둘 다 <xref:System.InvalidOperationException>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="7cf03-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> 및 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>는 `null`(Visual Basic의 `Nothing`)을 반환하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="7cf03-218">반환할 경우 PLINQ/TPL이 <xref:System.InvalidOperationException>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="7cf03-219">파티션을 반환하는 메서드는 항상 데이터 소스를 완전히 고유하게 열거할 수 있는 파티션을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="7cf03-220">파티셔너의 디자인에 특별히 필요한 경우가 아니면 데이터 소스 또는 건너뛴 항목에는 중복이 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="7cf03-221">이 규칙을 따르지 않으면 출력 순서가 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-221">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="7cf03-222">다음 부울 getter는 출력 순서가 변경되지 않도록 항상 다음 값을 정확하게 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>  
  
    -   <span data-ttu-id="7cf03-223">`KeysOrderedInEachPartition`: 각 파티션이 키 인덱스가 증가하는 요소를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>  
  
    -   <span data-ttu-id="7cf03-224">`KeysOrderedAcrossPartitions`: 반환되는 모든 파티션에서 파티션의 키 인덱스 *i*는 파티션의 키 인덱스 *i*-1보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>  
  
    -   <span data-ttu-id="7cf03-225">`KeysNormalized`: 모든 키 인덱스는 0부터 시작하여 공백 없이 순차적으로 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>  
  
-   <span data-ttu-id="7cf03-226">모든 인덱스는 고유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-226">All indices must be unique.</span></span> <span data-ttu-id="7cf03-227">중복 인덱스가 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-227">There may not be duplicate indices.</span></span> <span data-ttu-id="7cf03-228">이 규칙을 따르지 않으면 출력 순서가 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-228">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="7cf03-229">모든 인덱스는 음수가 아니어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-229">All indices must be nonnegative.</span></span> <span data-ttu-id="7cf03-230">이 규칙을 따르지 않으면 PLINQ/TPL이 예외를 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7cf03-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7cf03-231">참고 항목</span><span class="sxs-lookup"><span data-stu-id="7cf03-231">See Also</span></span>  
 [<span data-ttu-id="7cf03-232">병렬 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="7cf03-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="7cf03-233">방법: 동적 파티션 구현</span><span class="sxs-lookup"><span data-stu-id="7cf03-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)  
 [<span data-ttu-id="7cf03-234">방법: 정적 분할을 위한 파티셔너 구현</span><span class="sxs-lookup"><span data-stu-id="7cf03-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)

---
title: 런타임에서 어셈블리를 찾는 방법
ms.date: 03/30/2017
helpviewer_keywords:
- app.config files, assembly locations
- deploying applications [.NET Framework], assembly locations
- application configuration files, locating assemblies
- .NET Framework application deployment, locating assemblies
- locating assemblies
- assemblies [.NET Framework], location
ms.assetid: 772ac6f4-64d2-4cfb-92fd-58096dcd6c34
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 3f8ed5cce3e0c9e22679f54b13c84ea422f2100d
ms.sourcegitcommit: 6c480773ae896f45af4671fb3e26611a50e4dd81
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/09/2018
ms.locfileid: "35251066"
---
# <a name="how-the-runtime-locates-assemblies"></a><span data-ttu-id="08982-102">런타임에서 어셈블리를 찾는 방법</span><span class="sxs-lookup"><span data-stu-id="08982-102">How the Runtime Locates Assemblies</span></span>
<span data-ttu-id="08982-103">.NET Framework 응용 프로그램을 성공적으로 배포하려면 공용 언어 런타임이 응용 프로그램을 구성하는 어셈블리를 찾아서 바인딩하는 방법을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-103">To successfully deploy your .NET Framework application, you must understand how the common language runtime locates and binds to the assemblies that make up your application.</span></span> <span data-ttu-id="08982-104">기본적으로 런타임은 응용 프로그램 빌드 시 사용된 정확한 버전의 어셈블리로 바인딩을 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-104">By default, the runtime attempts to bind with the exact version of an assembly that the application was built with.</span></span> <span data-ttu-id="08982-105">이 기본 동작은 구성 파일 설정으로 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-105">This default behavior can be overridden by configuration file settings.</span></span>  
  
 <span data-ttu-id="08982-106">공용 언어 런타임은 어셈블리를 찾아서 어셈블리 참조를 확인하려고 할 때 다양 한 단계를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-106">The common language runtime performs a number of steps when attempting to locate an assembly and resolve an assembly reference.</span></span> <span data-ttu-id="08982-107">각 단계는 다음 섹션에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-107">Each step is explained in the following sections.</span></span> <span data-ttu-id="08982-108">검색이라는 용어는 대개 런타임에서 어셈블리를 찾는 방법을 설명할 때 사용됩니다. 해당 이름 및 문화권에 따라 어셈블리를 찾는 데 사용되는 추론 집합을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="08982-108">The term probing is often used when describing how the runtime locates assemblies; it refers to the set of heuristics used to locate the assembly based on its name and culture.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08982-109">[에 포함된](../../../docs/framework/tools/fuslogvw-exe-assembly-binding-log-viewer.md)어셈블리 바인딩 로그 뷰어(Fuslogvw.exe) [!INCLUDE[winsdklong](../../../includes/winsdklong-md.md)]를 사용하여 로그 파일의 바인딩 정보를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-109">You can view binding information in the log file using the [Assembly Binding Log Viewer (Fuslogvw.exe)](../../../docs/framework/tools/fuslogvw-exe-assembly-binding-log-viewer.md), which is included in the [!INCLUDE[winsdklong](../../../includes/winsdklong-md.md)].</span></span>  
  
## <a name="initiating-the-bind"></a><span data-ttu-id="08982-110">바인딩 시작</span><span class="sxs-lookup"><span data-stu-id="08982-110">Initiating the Bind</span></span>  
 <span data-ttu-id="08982-111">런타임에서 다른 어셈블리에 대한 참조를 확인하려고 시도하면 어셈블리를 찾아서 바인딩하는 프로세스가 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-111">The process of locating and binding to an assembly begins when the runtime attempts to resolve a reference to another assembly.</span></span> <span data-ttu-id="08982-112">이 참조는 정적이거나 동적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-112">This reference can be either static or dynamic.</span></span> <span data-ttu-id="08982-113">컴파일러는 빌드 타임에 정적 참조를 어셈블리 매니페스트 메타데이터에 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-113">The compiler records static references in the assembly manifest's metadata at build time.</span></span> <span data-ttu-id="08982-114">동적 참조는 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>와 같은 다양한 메서드의 호출 결과로 즉석에서 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-114">Dynamic references are constructed on the fly as a result of calling various methods, such as <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="08982-115">어셈블리를 참조할 때는 어셈블리 이름, 버전, 문화권 및 공개 키 토큰(있는 경우)을 포함하여 전체 참조를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-115">The preferred way to reference an assembly is to use a full reference, including the assembly name, version, culture, and public key token (if one exists).</span></span> <span data-ttu-id="08982-116">런타임은 이 섹션의 뒷부분에 설명된 단계에 따라 이 정보를 사용하여 어셈블리를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-116">The runtime uses this information to locate the assembly, following the steps described later in this section.</span></span> <span data-ttu-id="08982-117">런타임은 정적 또는 동적 어셈블리에 대한 참조인지에 관계없이 동일한 확인 프로세스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-117">The runtime uses the same resolution process regardless of whether the reference is for a static or dynamic assembly.</span></span>  
  
 <span data-ttu-id="08982-118">어셈블리 이름만 지정하는 등 호출 메서드에 어셈블리에 대한 부분 정보만 제공하여 어셈블리에 대한 동적 참조를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-118">You can also make a dynamic reference to an assembly by providing the calling method with only partial information about the assembly, such as specifying only the assembly name.</span></span> <span data-ttu-id="08982-119">이 경우 응용 프로그램 디렉터리에서만 어셈블리가 검색되고 다른 검사는 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-119">In this case, only the application directory is searched for the assembly, and no other checking occurs.</span></span> <span data-ttu-id="08982-120"><xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 또는 <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>와 같은 다양한 어셈블리 로드 메서드 중 하나를 사용하여 부분 참조를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="08982-120">You make a partial reference using any of the various methods for loading assemblies such as <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> or <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="08982-121"><xref:System.Reflection.Assembly.Load*?displayProperty=nameWithType> 등의 메서드를 사용하여 동적 참조를 만들고 부분 정보만 제공할 수 있습니다. 그런 다음 응용 프로그램 구성 파일에서 [\<qualifyAssembly>](../../../docs/framework/configure-apps/file-schema/runtime/qualifyassembly-element.md) 요소를 사용하여 참조를 한정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-121">Finally, you can make a dynamic reference using a method such as <xref:System.Reflection.Assembly.Load*?displayProperty=nameWithType> and provide only partial information; you then qualify the reference using the [\<qualifyAssembly>](../../../docs/framework/configure-apps/file-schema/runtime/qualifyassembly-element.md) element in the application configuration file.</span></span> <span data-ttu-id="08982-122">코드 대신 응용 프로그램 구성 파일에서 이 요소를 통해 전체 참조 정보(이름, 버전, 문화권 및 해당하는 경우 공개 키 토큰)를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-122">This element allows you to provide the full reference information (name, version, culture and, if applicable, the public key token) in your application configuration file instead of in your code.</span></span> <span data-ttu-id="08982-123">응용 프로그램 디렉터리 외부의 어셈블리에 대한 참조를 정규화하려는 경우 또는 전역 어셈블리 캐시에서 어셈블리를 참조하려고 하지만 코드 대신 구성 파일에서 전체 참조를 편리하게 지정하려는 경우 이 기술을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-123">You would use this technique if you wanted to fully qualify a reference to an assembly outside the application directory, or if you wanted to reference an assembly in the global assembly cache but you wanted the convenience of specifying the full reference in the configuration file instead of in your code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08982-124">이 형식의 부분 참조는 여러 응용 프로그램 간에 공유되는 어셈블리와 함께 사용하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-124">This type of partial reference should not be used with assemblies that are shared among several applications.</span></span> <span data-ttu-id="08982-125">어셈블리 단위가 아니라 응용 프로그램 단위로 구성 설정이 적용되기 때문에 이 형식의 부분 참조를 사용하는 공유 어셈블리에서는 공유 어셈블리를 사용하는 각 응용 프로그램의 구성 파일에 적격한 정보가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-125">Because configuration settings are applied per application and not per assembly, a shared assembly using this type of partial reference would require each application using the shared assembly to have the qualifying information in its configuration file.</span></span>  
  
 <span data-ttu-id="08982-126">런타임은 다음 단계를 사용하여 어셈블리 참조를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-126">The runtime uses the following steps to resolve an assembly reference:</span></span>  
  
1.  <span data-ttu-id="08982-127">응용 프로그램 구성 파일, 게시자 정책 파일 및 컴퓨터 구성 파일을 비롯한 해당 구성 파일을 검사하여[올바른 어셈블리 버전을 결정](#step1) 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-127">[Determines the correct assembly version](#step1) by examining applicable configuration files, including the application configuration file, publisher policy file, and machine configuration file.</span></span> <span data-ttu-id="08982-128">구성 파일이 원격 컴퓨터에 있는 경우 런타임에서 먼저 응용 프로그램 구성 파일을 찾아서 다운로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-128">If the configuration file is located on a remote machine, the runtime must locate and download the application configuration file first.</span></span>  
  
2.  <span data-ttu-id="08982-129">[어셈블리 이름이 이전에 바인딩되었는지 여부를 확인](#step2) 하고, 바인딩된 경우 이전에 로드된 어셈블리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-129">[Checks whether the assembly name has been bound to before](#step2) and, if so, uses the previously loaded assembly.</span></span> <span data-ttu-id="08982-130">이전의 어셈블리 로드 요청이 실패한 경우 어셈블리 로드를 시도하지 않고 요청이 즉시 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-130">If a previous request to load the assembly failed, the request is failed immediately without attempting to load the assembly.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="08982-131">어셈블리 바인딩 실패 캐싱은 .NET Framework 버전 2.0의 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="08982-131">The caching of assembly binding failures is new in the .NET Framework version 2.0.</span></span>  
  
3.  <span data-ttu-id="08982-132">[전역 어셈블리 캐시를 확인](#step3)합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-132">[Checks the global assembly cache](#step3).</span></span> <span data-ttu-id="08982-133">어셈블리가 있으면 런타임에서 이 어셈블리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-133">If the assembly is found there, the runtime uses this assembly.</span></span>  
  
4.  <span data-ttu-id="08982-134">다음 단계를 사용하여[어셈블리를 검색](#step4) 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-134">[Probes for the assembly](#step4) using the following steps:</span></span>  
  
    1.  <span data-ttu-id="08982-135">구성 및 게시자 정책이 원래 참조 영향을 주지 않고 바인딩 요청이 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 메서드를 사용하여 만들어진 경우 런타임에서 위치 힌트를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-135">If configuration and publisher policy do not affect the original reference and if the bind request was created using the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method, the runtime checks for location hints.</span></span>  
  
    2.  <span data-ttu-id="08982-136">구성 파일에 코드베이스가 있을 경우 런타임에서 이 위치만 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-136">If a codebase is found in the configuration files, the runtime checks only this location.</span></span> <span data-ttu-id="08982-137">이 검색이 실패하면 런타임에서 바인딩 요청이 실패했다고 결정하며 다른 검색이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-137">If this probe fails, the runtime determines that the binding request failed and no other probing occurs.</span></span>  
  
    3.  <span data-ttu-id="08982-138">[검색 섹션](#step4)에서 설명한 추론을 사용하여 어셈블리를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-138">Probes for the assembly using the heuristics described in the [probing section](#step4).</span></span> <span data-ttu-id="08982-139">검색 후에도 어셈블리가 발견되지 않으면 런타임에서 Windows Installer에 어셈블리를 제공하도록 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-139">If the assembly is not found after probing, the runtime requests the Windows Installer to provide the assembly.</span></span> <span data-ttu-id="08982-140">이는 주문형 설치 기능으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-140">This acts as an install-on-demand feature.</span></span>  
  
        > [!NOTE]
        >  <span data-ttu-id="08982-141">강력한 이름이 없는 어셈블리에 대한 버전 검사는 없으며, 강력한 이름이 없는 어셈블리에 대한 런타임 검사도 전역 어셈블리 캐시에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-141">There is no version checking for assemblies without strong names, nor does the runtime check in the global assembly cache for assemblies without strong names.</span></span>  
  
<a name="step1"></a>   
## <a name="step-1-examining-the-configuration-files"></a><span data-ttu-id="08982-142">단계 1: 구성 파일 검토</span><span class="sxs-lookup"><span data-stu-id="08982-142">Step 1: Examining the Configuration Files</span></span>  
 <span data-ttu-id="08982-143">세 개의 XML 파일을 기준으로 다양한 수준에서 어셈블리 바인딩 동작을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-143">Assembly binding behavior can be configured at different levels based on three XML files:</span></span>  
  
-   <span data-ttu-id="08982-144">응용 프로그램 구성 파일</span><span class="sxs-lookup"><span data-stu-id="08982-144">Application configuration file.</span></span>  
  
-   <span data-ttu-id="08982-145">게시자 정책 파일</span><span class="sxs-lookup"><span data-stu-id="08982-145">Publisher policy file.</span></span>  
  
-   <span data-ttu-id="08982-146">컴퓨터 구성 파일</span><span class="sxs-lookup"><span data-stu-id="08982-146">Machine configuration file.</span></span>  
  
 <span data-ttu-id="08982-147">이러한 파일은 동일한 구문을 따르며 바인딩 리디렉션, 코드 위치 및 특정 어셈블리에 대한 바인딩 모드와 같은 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-147">These files follow the same syntax and provide information such as binding redirects, the location of code, and binding modes for particular assemblies.</span></span> <span data-ttu-id="08982-148">각 구성 파일에는 바인딩 프로세스를 리디렉션하는 [\<assemblyBinding> 요소](../../../docs/framework/configure-apps/file-schema/runtime/assemblybinding-element-for-runtime.md)가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-148">Each configuration file can contain an [\<assemblyBinding> element](../../../docs/framework/configure-apps/file-schema/runtime/assemblybinding-element-for-runtime.md) that redirects the binding process.</span></span> <span data-ttu-id="08982-149">[\<assemblyBinding> 요소](../../../docs/framework/configure-apps/file-schema/runtime/assemblybinding-element-for-runtime.md)의 자식 요소에는 [\<dependentAssembly> 요소](../../../docs/framework/configure-apps/file-schema/runtime/dependentassembly-element.md)가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-149">The child elements of the [\<assemblyBinding> element](../../../docs/framework/configure-apps/file-schema/runtime/assemblybinding-element-for-runtime.md) include the [\<dependentAssembly> element](../../../docs/framework/configure-apps/file-schema/runtime/dependentassembly-element.md).</span></span> <span data-ttu-id="08982-150">[\<dependentAssembly> 요소](../../../docs/framework/configure-apps/file-schema/runtime/dependentassembly-element.md)의 자식 요소에는 [\<assemblyIdentity> 요소](/visualstudio/deployment/assemblyidentity-element-clickonce-deployment), [\<bindingRedirect> 요소](../../../docs/framework/configure-apps/file-schema/runtime/bindingredirect-element.md) 및 [\<codeBase> 요소](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md)가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-150">The children of [\<dependentAssembly> element](../../../docs/framework/configure-apps/file-schema/runtime/dependentassembly-element.md) include the [\<assemblyIdentity> element](/visualstudio/deployment/assemblyidentity-element-clickonce-deployment), the [\<bindingRedirect> element](../../../docs/framework/configure-apps/file-schema/runtime/bindingredirect-element.md), and the [\<codeBase> element](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08982-151">세 개의 구성 파일에서 구성 정보를 확인할 수 있습니다. 모든 요소가 모든 구성 파일에서 유효한 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="08982-151">Configuration information can be found in the three configuration files; not all elements are valid in all configuration files.</span></span> <span data-ttu-id="08982-152">예를 들어 바인딩 모드 및 전용 경로 정보는 응용 프로그램 구성 파일에만 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-152">For example, binding mode and private path information can only be in the application configuration file.</span></span> <span data-ttu-id="08982-153">각 파일에 포함된 정보의 전체 목록은 [구성 파일을 사용하여 앱 구성](../../../docs/framework/configure-apps/index.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08982-153">For a complete list of the information that is contained in each file, see [Configuring Apps by Using Configuration Files](../../../docs/framework/configure-apps/index.md).</span></span>  
  
### <a name="application-configuration-file"></a><span data-ttu-id="08982-154">응용 프로그램 구성 파일</span><span class="sxs-lookup"><span data-stu-id="08982-154">Application Configuration File</span></span>  
 <span data-ttu-id="08982-155">첫째, 공용 언어 런타임은 응용 프로그램 구성 파일에서 호출 어셈블리의 매니페스트에 저장된 버전 정보를 재정의하는 정보를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-155">First, the common language runtime checks the application configuration file for information that overrides the version information stored in the calling assembly's manifest.</span></span> <span data-ttu-id="08982-156">응용 프로그램 구성 파일은 응용 프로그램과 함께 배포될 수 있지만 응용 프로그램 실행에 필요하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-156">The application configuration file can be deployed with an application, but is not required for application execution.</span></span> <span data-ttu-id="08982-157">일반적으로 이 파일은 즉시 검색되지만 Internet Explorer 웹 기반 시나리오와 같이 응용 프로그램 기준 위치가 원격 컴퓨터에 있는 경우 구성 파일을 다운로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-157">Usually the retrieval of this file is almost instantaneous, but in situations where the application base is on a remote computer, such as in an Internet Explorer Web-based scenario, the configuration file must be downloaded.</span></span>  
  
 <span data-ttu-id="08982-158">클라이언트 실행 파일의 경우 응용 프로그램 구성 파일이 응용 프로그램 실행 파일과 동일한 디렉터리에 있으며 .config 확장명을 가진 실행 파일과 동일한 기본 이름을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-158">For client executables, the application configuration file resides in the same directory as the application's executable and has the same base name as the executable with a .config extension.</span></span> <span data-ttu-id="08982-159">예를 들어 C:\Program Files\Myapp\Myapp.exe의 구성 파일은 C:\Program Files\Myapp\Myapp.exe.config입니다. 브라우저 기반 시나리오에서 HTML 파일은 **\<link>** 요소를 사용하여 구성 파일을 명시적으로 가리켜야 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-159">For example, the configuration file for C:\Program Files\Myapp\Myapp.exe is C:\Program Files\Myapp\Myapp.exe.config. In a browser-based scenario, the HTML file must use the **\<link>** element to explicitly point to the configuration file.</span></span>  
  
 <span data-ttu-id="08982-160">다음 코드는 응용 프로그램 구성 파일의 간단한 예를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-160">The following code provides a simple example of an application configuration file.</span></span> <span data-ttu-id="08982-161">이 예제에서는 <xref:System.Diagnostics.TextWriterTraceListener> 컬렉션에 <xref:System.Diagnostics.Debug.Listeners%2A> 를 추가하여 파일에 디버그 정보를 기록할 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-161">This example adds a <xref:System.Diagnostics.TextWriterTraceListener> to the <xref:System.Diagnostics.Debug.Listeners%2A> collection to enable recording debug information to a file.</span></span>  
  
```xml  
<configuration>  
   <system.diagnostics>  
      <trace useGlobalLock="false" autoflush="true" indentsize="0">  
         <listeners>  
            <add name="myListener" type="System.Diagnostics.TextWriterTraceListener, system version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" initializeData="c:\myListener.log" />  
         </listeners>  
      </trace>  
   </system.diagnostics>  
</configuration>  
```  
  
### <a name="publisher-policy-file"></a><span data-ttu-id="08982-162">게시자 정책 파일</span><span class="sxs-lookup"><span data-stu-id="08982-162">Publisher Policy File</span></span>  
 <span data-ttu-id="08982-163">둘째, 런타임은 게시자 정책 파일을 검사합니다(있는 경우).</span><span class="sxs-lookup"><span data-stu-id="08982-163">Second, the runtime examines the publisher policy file, if one exists.</span></span> <span data-ttu-id="08982-164">게시자 정책 파일은 구성 요소 게시자에 의해 공유 구성 요소에 대한 수정 프로그램이나 업데이트로 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-164">Publisher policy files are distributed by a component publisher as a fix or update to a shared component.</span></span> <span data-ttu-id="08982-165">이 파일에는 어셈블리 참조를 새 버전으로 보내는 공유 구성 요소의 게시자에 의해 발급된 호환성 정보가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-165">These files contain compatibility information issued by the publisher of the shared component that directs an assembly reference to a new version.</span></span> <span data-ttu-id="08982-166">응용 프로그램 및 컴퓨터 구성 파일과 달리 게시자 정책 파일은 전역 어셈블리 캐시에 설치되어야 하는 고유한 어셈블리에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-166">Unlike application and machine configuration files, publisher policy files are contained in their own assembly that must be installed in the global assembly cache.</span></span>  
  
 <span data-ttu-id="08982-167">다음은 게시자 정책 구성 파일의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="08982-167">The following is an example of a Publisher Policy configuration file:</span></span>  
  
```xml  
<configuration>  
    <runtime>  
        <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">  
  
            <dependentAssembly>  
                <assemblyIdentity name="asm6" publicKeyToken="c0305c36380ba429" />   
                <bindingRedirect oldVersion="3.0.0.0" newVersion="2.0.0.0"/>    
            </dependentAssembly>  
  
        </assemblyBinding>  
    </runtime>  
</configuration>  
```  
  
 <span data-ttu-id="08982-168">어셈블리를 만들려면 다음과 같은 명령과 함께 [Al.exe(어셈블리 링커)](../../../docs/framework/tools/al-exe-assembly-linker.md) 도구를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-168">To create an assembly, you can use the [Al.exe (Assembly Linker)](../../../docs/framework/tools/al-exe-assembly-linker.md) tool with a command such as the following:</span></span>  
  
```  
Al.exe /link:asm6.exe.config /out:policy.3.0.asm6.dll /keyfile: compatkey.dat /v:3.0.0.0  
```  
  
 <span data-ttu-id="08982-169">`compatkey.dat` 는 강력한 이름의 키 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="08982-169">`compatkey.dat` is a strong-name key file.</span></span> <span data-ttu-id="08982-170">이 명령은 전역 어셈블리 캐시에 배치할 수 있는 강력한 이름의 어셈블리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="08982-170">This command creates a strong-named assembly you can place in the global assembly cache.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08982-171">게시자 정책은 공유 구성 요소를 사용하는 모든 응용 프로그램에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="08982-171">Publisher policy affects all applications that use a shared component.</span></span>  
  
 <span data-ttu-id="08982-172">게시자 정책 구성 파일은 응용 프로그램(즉, 어셈블리 매니페스트 또는 응용 프로그램 구성 파일)에서 제공되는 버전 정보를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-172">The publisher policy configuration file overrides version information that comes from the application (that is, from the assembly manifest or from the application configuration file).</span></span> <span data-ttu-id="08982-173">어셈블리 매니페스트에 지정된 버전을 리디렉션하는 문이 응용 프로그램 구성 파일에 없는 경우 게시자 정책 파일이 어셈블리 매니페스트에 지정된 버전을 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-173">If there is no statement in the application configuration file to redirect the version specified in the assembly manifest, the publisher policy file overrides the version specified in the assembly manifest.</span></span> <span data-ttu-id="08982-174">그러나 응용 프로그램 구성 파일에 리디렉션 문이 있으면 게시자 정책이 매니페스트에 지정된 버전 대신 해당 버전을 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-174">However, if there is a redirecting statement in the application configuration file, publisher policy overrides that version rather than the one specified in the manifest.</span></span>  
  
 <span data-ttu-id="08982-175">게시자 정책 파일은 공유 구성 요소가 업데이트되고 해당 구성 요소를 사용하는 모든 응용 프로그램이 새 버전의 공유 구성 요소를 선택할 때 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-175">A publisher policy file is used when a shared component is updated and the new version of the shared component should be picked up by all applications using that component.</span></span> <span data-ttu-id="08982-176">응용 프로그램 구성 파일이 안전 모드를 적용하지 않는 한 게시자 정책 파일의 설정이 응용 프로그램 구성 파일의 설정을 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-176">The settings in the publisher policy file override settings in the application configuration file, unless the application configuration file enforces safe mode.</span></span>  
  
#### <a name="safe-mode"></a><span data-ttu-id="08982-177">안전 모드</span><span class="sxs-lookup"><span data-stu-id="08982-177">Safe Mode</span></span>  
 <span data-ttu-id="08982-178">게시자 정책 파일은 일반적으로 서비스 팩이나 프로그램 업데이트의 일부로 명시적으로 설치됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-178">Publisher policy files are usually explicitly installed as part of a service pack or program update.</span></span> <span data-ttu-id="08982-179">업그레이드된 공유 구성 요소에 문제가 있는 경우 안전 모드를 사용하여 게시자 정책 파일의 재정의를 무시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-179">If there is any problem with the upgraded shared component, you can ignore the overrides in the publisher policy file using safe mode.</span></span> <span data-ttu-id="08982-180">안전 모드는 **\<publisherPolicy apply="yes**&#124;**no"/>** 요소에 의해 결정되며, 이 요소는 응용 프로그램 구성 파일에만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-180">Safe mode is determined by the **\<publisherPolicy apply="yes**&#124;**no"/>** element, located only in the application configuration file.</span></span> <span data-ttu-id="08982-181">바인딩 프로세스에서 게시자 정책 구성 정보를 제거할지 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-181">It specifies whether the publisher policy configuration information should be removed from the binding process.</span></span>  
  
 <span data-ttu-id="08982-182">전체 응용 프로그램이나 선택한 어셈블리에 대해 안전 모드를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-182">Safe mode can be set for the entire application or for selected assemblies.</span></span> <span data-ttu-id="08982-183">즉, 응용 프로그램을 구성하는 모든 어셈블리에 대해 정책을 해제하거나 다른 어셈블리는 제외하고 일부 어셈블리에 대해서만 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-183">That is, you can turn off the policy for all assemblies that make up the application, or turn it on for some assemblies but not others.</span></span> <span data-ttu-id="08982-184">응용 프로그램을 구성하는 어셈블리에 게시자 정책을 선택적으로 적용하려면, **\<publisherPolicy apply\=no/>** 를 설정한 다음 \<**dependentAssembly**> 요소를 사용하여 정책을 적용하려는 어셈블리를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-184">To selectively apply publisher policy to assemblies that make up an application, set **\<publisherPolicy apply\=no/>** and specify which assemblies you want to be affected using the \<**dependentAssembly**> element.</span></span> <span data-ttu-id="08982-185">응용 프로그램을 구성하는 모든 어셈블리에 게시자 정책을 적용하려면 종속 어셈블리 요소 없이 **\<publisherPolicy apply\=no/>** 를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-185">To apply publisher policy to all assemblies that make up the application, set **\<publisherPolicy apply\=no/>** with no dependent assembly elements.</span></span> <span data-ttu-id="08982-186">구성에 대한 자세한 내용은 [구성 파일을 사용하여 앱 구성](../../../docs/framework/configure-apps/index.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08982-186">For more about configuration, see [Configuring Apps by using Configuration Files](../../../docs/framework/configure-apps/index.md).</span></span>  
  
### <a name="machine-configuration-file"></a><span data-ttu-id="08982-187">컴퓨터 구성 파일</span><span class="sxs-lookup"><span data-stu-id="08982-187">Machine Configuration File</span></span>  
 <span data-ttu-id="08982-188">셋째, 런타임은 컴퓨터 구성 파일을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-188">Third, the runtime examines the machine configuration file.</span></span> <span data-ttu-id="08982-189">Machine.config라는 이 파일은 로컬 컴퓨터에서 런타임이 설치된 루트 디렉터리의 Config 하위 디렉터리에 상주합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-189">This file, called Machine.config, resides on the local computer in the Config subdirectory of the root directory where the runtime is installed.</span></span> <span data-ttu-id="08982-190">관리자는 이 파일을 사용하여 해당 컴퓨터에 로컬로 적용되는 어셈블리 바인딩 제한 사항을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-190">This file can be used by administrators to specify assembly binding restrictions that are local to that computer.</span></span> <span data-ttu-id="08982-191">컴퓨터 구성 파일의 설정은 다른 모든 구성 설정보다 우선합니다. 그러나 모든 구성 설정을 이 파일에 넣어야 한다는 의미는 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="08982-191">The settings in the machine configuration file take precedence over all other configuration settings; however, this does not mean that all configuration settings should be put in this file.</span></span> <span data-ttu-id="08982-192">관리자 정책 파일에서 결정된 버전이 최종 버전이며 재정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-192">The version determined by the administrator policy file is final, and cannot be overridden.</span></span> <span data-ttu-id="08982-193">Machine.config 파일에서 지정된 재정의는 모든 응용 프로그램에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="08982-193">Overrides specified in the Machine.config file affect all applications.</span></span> <span data-ttu-id="08982-194">구성 파일에 대한 자세한 내용은 [구성 파일을 사용하여 앱 구성](../../../docs/framework/configure-apps/index.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08982-194">For more information about configuration files, see [Configuring Apps by using Configuration Files](../../../docs/framework/configure-apps/index.md).</span></span>  
  
<a name="step2"></a>   
## <a name="step-2-checking-for-previously-referenced-assemblies"></a><span data-ttu-id="08982-195">단계 2: 이전에 참조된 어셈블리 확인</span><span class="sxs-lookup"><span data-stu-id="08982-195">Step 2: Checking for Previously Referenced Assemblies</span></span>  
 <span data-ttu-id="08982-196">요청된 어셈블리가 이전 호출에서도 요청된 경우 공용 언어 런타임은 이미 로드된 어셈블리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-196">If the requested assembly has also been requested in previous calls, the common language runtime uses the assembly that is already loaded.</span></span> <span data-ttu-id="08982-197">이 경우 응용 프로그램을 구성하는 어셈블리의 이름을 바꿀 때 영향을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-197">This can have ramifications when naming assemblies that make up an application.</span></span> <span data-ttu-id="08982-198">어셈블리 이름 지정에 대한 자세한 내용은 [어셈블리 이름](../../../docs/framework/app-domains/assembly-names.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08982-198">For more information about naming assemblies, see [Assembly Names](../../../docs/framework/app-domains/assembly-names.md).</span></span>  
  
 <span data-ttu-id="08982-199">이전의 어셈블리 요청이 실패한 경우 어셈블리 로드를 시도하지 않고 어셈블리에 대한 이후 요청이 즉시 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-199">If a previous request for the assembly failed, subsequent requests for the assembly are failed immediately without attempting to load the assembly.</span></span> <span data-ttu-id="08982-200">.NET Framework 버전 2.0부터 어셈블리 바인딩 실패가 캐시되며 캐시된 정보는 어셈블리 로드를 시도할지 여부를 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-200">Starting with the .NET Framework version 2.0, assembly binding failures are cached, and the cached information is used to determine whether to attempt to load the assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08982-201">바인딩 실패를 캐시하지 않은 .NET Framework 버전 1.0 및 1.1의 동작으로 되돌리려면 [\<disableCachingBindingFailures> 요소](../../../docs/framework/configure-apps/file-schema/runtime/disablecachingbindingfailures-element.md)를 구성 파일에 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-201">To revert to the behavior of the .NET Framework versions 1.0 and 1.1, which did not cache binding failures, include the [\<disableCachingBindingFailures> Element](../../../docs/framework/configure-apps/file-schema/runtime/disablecachingbindingfailures-element.md) in your configuration file.</span></span>  
  
<a name="step3"></a>   
## <a name="step-3-checking-the-global-assembly-cache"></a><span data-ttu-id="08982-202">단계 3: 전역 어셈블리 캐시 확인</span><span class="sxs-lookup"><span data-stu-id="08982-202">Step 3: Checking the Global Assembly Cache</span></span>  
 <span data-ttu-id="08982-203">강력한 이름의 어셈블리에 대한 바인딩 프로세스는 계속해서 전역 어셈블리 캐시를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-203">For strong-named assemblies, the binding process continues by looking in the global assembly cache.</span></span> <span data-ttu-id="08982-204">전역 어셈블리 캐시는 컴퓨터의 여러 응용 프로그램에서 사용할 수 있는 어셈블리를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-204">The global assembly cache stores assemblies that can be used by several applications on a computer.</span></span> <span data-ttu-id="08982-205">전역 어셈블리 캐시의 모든 어셈블리에 강력한 이름이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-205">All assemblies in the global assembly cache must have strong names.</span></span>  
  
<a name="step4"></a>   
## <a name="step-4-locating-the-assembly-through-codebases-or-probing"></a><span data-ttu-id="08982-206">단계 4: 코드베이스나 조사를 통해 어셈블리 찾기</span><span class="sxs-lookup"><span data-stu-id="08982-206">Step 4: Locating the Assembly through Codebases or Probing</span></span>  
 <span data-ttu-id="08982-207">호출 어셈블리 참조와 구성 파일의 정보를 사용하여 올바른 어셈블리 버전을 확인하고 전역 어셈블리 캐시를 검사한 후(강력한 이름의 어셈블리에만 해당) 공용 언어 런타임이 어셈블리를 찾으려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-207">After the correct assembly version has been determined by using the information in the calling assembly's reference and in the configuration files, and after it has checked in the global assembly cache (only for strong-named assemblies), the common language runtime attempts to find the assembly.</span></span> <span data-ttu-id="08982-208">어셈블리를 찾는 프로세스는 다음 단계로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-208">The process of locating an assembly involves the following steps:</span></span>  
  
1.  <span data-ttu-id="08982-209">응용 프로그램 구성 파일에 [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소가 있을 경우 런타임은 지정한 위치를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-209">If a [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element is found in the application configuration file, the runtime checks the specified location.</span></span> <span data-ttu-id="08982-210">일치 항목이 있으면 해당 어셈블리가 사용되고 검색이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-210">If a match is found, that assembly is used and no probing occurs.</span></span> <span data-ttu-id="08982-211">어셈블리가 없으면 바인딩 요청이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-211">If the assembly is not found there, the binding request fails.</span></span>  
  
2.  <span data-ttu-id="08982-212">그런 다음 런타임은 이 섹션의 뒷부분에 지정된 규칙을 사용하여 참조된 어셈블리를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-212">The runtime then probes for the referenced assembly using the rules specified later in this section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08982-213">같은 디렉터리에 여러 버전의 어셈블리가 있고 그중에서 특정 버전을 참조하려는 경우 [\<probing>](../../../docs/framework/configure-apps/file-schema/runtime/probing-element.md) 요소의 `privatePath` 특성 대신 [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-213">If you have multiple versions of an assembly in a directory and you want to reference a particular version of that assembly, you must use the [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element instead of the `privatePath` attribute of the [\<probing>](../../../docs/framework/configure-apps/file-schema/runtime/probing-element.md) element.</span></span> <span data-ttu-id="08982-214">[\<probing>](../../../docs/framework/configure-apps/file-schema/runtime/probing-element.md) 요소를 사용할 경우 참조되는 단순 어셈블리 이름에 일치하는 어셈블리를 런타임에서 처음 찾았으면 정확하게 일치하는지 여부에 관계없이 검색이 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-214">If you use the [\<probing>](../../../docs/framework/configure-apps/file-schema/runtime/probing-element.md) element, the runtime stops probing the first time it finds an assembly that matches the simple assembly name referenced, whether it is a correct match or not.</span></span> <span data-ttu-id="08982-215">정확하게 일치하는 항목이면 해당 어셈블리가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-215">If it is a correct match, that assembly is used.</span></span> <span data-ttu-id="08982-216">정확하게 일치하는 항목이 아니면 검색이 중지되고 바인딩이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-216">If it is not a correct match, probing stops and binding fails.</span></span>  
  
### <a name="locating-the-assembly-through-codebases"></a><span data-ttu-id="08982-217">코드베이스를 통해 어셈블리 찾기</span><span class="sxs-lookup"><span data-stu-id="08982-217">Locating the Assembly through Codebases</span></span>  
 <span data-ttu-id="08982-218">구성 파일의 [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소를 사용하여 코드베이스 정보를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-218">Codebase information can be provided by using a [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element in a configuration file.</span></span> <span data-ttu-id="08982-219">이 코드베이스는 항상 런타임이 참조된 어셈블리를 검색하기 전에 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-219">This codebase is always checked before the runtime attempts to probe for the referenced assembly.</span></span> <span data-ttu-id="08982-220">최종 버전 리디렉션이 포함된 게시자 정책 파일에도 [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소가 포함되어 있으면, [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-220">If a publisher policy file containing the final version redirect also contains a [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element, that [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element is the one that is used.</span></span> <span data-ttu-id="08982-221">예를 들어 응용 프로그램 구성 파일에서 [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소가 지정되고 응용 프로그램 정보를 재정의하는 게시자 정책 파일에서도 [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소가 지정되면 게시자 정책 파일의 [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-221">For example, if your application configuration file specifies a [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element, and a publisher policy file that is overriding the application information also specifies a [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element, the [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element in the publisher policy file is used.</span></span>  
  
 <span data-ttu-id="08982-222">[\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소에서 지정한 위치에 일치하는 항목이 없을 경우 바인드 요청은 실패하며 더 이상 다음 단계가 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-222">If no match is found at the location specified by the [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element, the bind request fails and no further steps are taken.</span></span> <span data-ttu-id="08982-223">런타임에서 어셈블리가 호출 어셈블리의 조건과 일치한다고 결정하면 해당 어셈블리가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-223">If the runtime determines that an assembly matches the calling assembly's criteria, it uses that assembly.</span></span> <span data-ttu-id="08982-224">지정한 [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소에서 지정된 파일이 로드되면 런타임은 해당 이름, 버전, 문화권 및 공개 키가 호출하는 어셈블리의 참조와 일치하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-224">When the file specified by the given [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element is loaded, the runtime checks to make sure that the name, version, culture, and public key match the calling assembly's reference.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08982-225">응용 프로그램의 루트 디렉터리 외부에 있는 참조된 어셈블리는 강력한 이름이 있어야 하며 전역 어셈블리 캐시에 설치되거나 [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소를 사용하여 지정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-225">Referenced assemblies outside the application's root directory must have strong names and must either be installed in the global assembly cache or specified using the [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element.</span></span>  
  
### <a name="locating-the-assembly-through-probing"></a><span data-ttu-id="08982-226">검색을 통해 어셈블리 찾기</span><span class="sxs-lookup"><span data-stu-id="08982-226">Locating the Assembly through Probing</span></span>  
 <span data-ttu-id="08982-227">응용 프로그램 구성 파일에 [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) 요소가 없을 경우 런타임에서는 다음 네 가지 기준을 사용하여 어셈블리를 조사합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-227">If there is no [\<codeBase>](../../../docs/framework/configure-apps/file-schema/runtime/codebase-element.md) element in the application configuration file, the runtime probes for the assembly using four criteria:</span></span>  
  
-   <span data-ttu-id="08982-228">응용 프로그램이 실행되는 루트 위치인 응용 프로그램 기준 위치</span><span class="sxs-lookup"><span data-stu-id="08982-228">Application base, which is the root location where the application is being executed.</span></span>  
  
-   <span data-ttu-id="08982-229">참조되는 어셈블리의 문화권 특성인 문화권</span><span class="sxs-lookup"><span data-stu-id="08982-229">Culture, which is the culture attribute of the assembly being referenced.</span></span>  
  
-   <span data-ttu-id="08982-230">참조되는 어셈블리의 이름인 이름</span><span class="sxs-lookup"><span data-stu-id="08982-230">Name, which is the name of the referenced assembly.</span></span>  
  
-   <span data-ttu-id="08982-231">[\<probing>](../../../docs/framework/configure-apps/file-schema/runtime/probing-element.md) 요소의 `privatePath` 특성으로서, 루트 위치 아래의 하위 디렉터리에 대해 사용자가 정의한 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="08982-231">The `privatePath` attribute of the [\<probing>](../../../docs/framework/configure-apps/file-schema/runtime/probing-element.md) element, which is the user-defined list of subdirectories under the root location.</span></span> <span data-ttu-id="08982-232">이 위치는 응용 프로그램 구성 파일과 관리 코드에서 응용 프로그램 도메인에 대한 <xref:System.AppDomainSetup.PrivateBinPath?displayProperty=nameWithType> 속성을 사용하여 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-232">This location can be specified in the application configuration file and in managed code using the <xref:System.AppDomainSetup.PrivateBinPath?displayProperty=nameWithType> property for an application domain.</span></span> <span data-ttu-id="08982-233">관리 코드에서 지정된 경우 관리 코드 `privatePath` 가 먼저 검색된 다음 응용 프로그램 구성 파일에 지정된 경로가 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-233">When specified in managed code, the managed code `privatePath` is probed first, followed by the path specified in the application configuration file.</span></span>  
  
#### <a name="probing-the-application-base-and-culture-directories"></a><span data-ttu-id="08982-234">응용 프로그램 기준 위치 및 문화권 디렉터리 검색</span><span class="sxs-lookup"><span data-stu-id="08982-234">Probing the Application Base and Culture Directories</span></span>  
 <span data-ttu-id="08982-235">런타임은 항상 URL이나 컴퓨터의 응용 프로그램 루트 디렉터리일 수 있는 응용 프로그램 기준 위치에서 검색을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-235">The runtime always begins probing in the application's base, which can be either a URL or the application's root directory on a computer.</span></span> <span data-ttu-id="08982-236">참조된 어셈블리가 응용 프로그램 기준 위치에 없고 문화권 정보가 제공되지 않은 경우 런타임은 어셈블리 이름을 사용하여 하위 디렉터리를 모두 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-236">If the referenced assembly is not found in the application base and no culture information is provided, the runtime searches any subdirectories with the assembly name.</span></span> <span data-ttu-id="08982-237">검색되는 디렉터리는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-237">The directories probed include:</span></span>  
  
 <span data-ttu-id="08982-238">[응용 프로그램 기준 위치] / [어셈블리 이름].dll</span><span class="sxs-lookup"><span data-stu-id="08982-238">[application base] / [assembly name].dll</span></span>  
  
 <span data-ttu-id="08982-239">[응용 프로그램 기준 위치] / [어셈블리 이름] / [어셈블리 이름].dll</span><span class="sxs-lookup"><span data-stu-id="08982-239">[application base] / [assembly name] / [assembly name].dll</span></span>  
  
 <span data-ttu-id="08982-240">참조된 어셈블리에 대한 문화권 정보가 지정된 경우 다음 디렉터리만 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-240">If culture information is specified for the referenced assembly, only the following directories are probed:</span></span>  
  
 <span data-ttu-id="08982-241">[응용 프로그램 기준 위치] / [문화권] / [어셈블리 이름].dll</span><span class="sxs-lookup"><span data-stu-id="08982-241">[application base] / [culture] / [assembly name].dll</span></span>  
  
 <span data-ttu-id="08982-242">[응용 프로그램 기준 위치] / [문화권] / [어셈블리 이름] / [어셈블리 이름].dll</span><span class="sxs-lookup"><span data-stu-id="08982-242">[application base] / [culture] / [assembly name] / [assembly name].dll</span></span>  
  
#### <a name="probing-with-the-privatepath-attribute"></a><span data-ttu-id="08982-243">PrivatePath 특성을 사용하여 검색</span><span class="sxs-lookup"><span data-stu-id="08982-243">Probing with the privatePath Attribute</span></span>  
 <span data-ttu-id="08982-244">문화권 하위 디렉터리와 참조된 어셈블리에 대해 명명된 하위 디렉터리 외에도 런타임은 [\<probing>](../../../docs/framework/configure-apps/file-schema/runtime/probing-element.md) 요소의 `privatePath` 특성을 사용하여 지정한 디렉터리를 조사합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-244">In addition to the culture subdirectories and the subdirectories named for the referenced assembly, the runtime also probes directories specified using the `privatePath` attribute of the [\<probing>](../../../docs/framework/configure-apps/file-schema/runtime/probing-element.md) element.</span></span> <span data-ttu-id="08982-245">`privatePath` 특성을 사용하여 지정된 디렉터리는 응용 프로그램 루트 디렉터리의 하위 디렉터리여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-245">The directories specified using the `privatePath` attribute must be subdirectories of the application's root directory.</span></span> <span data-ttu-id="08982-246">검색되는 디렉터리는 참조된 어셈블리 요청에 문화권 정보가 포함되었는지 여부에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="08982-246">The directories probed vary depending on whether culture information is included in the referenced assembly request.</span></span>  
  
 <span data-ttu-id="08982-247">참조되는 단순 어셈블리 이름에 일치하는 어셈블리를 런타임에서 처음 찾았을 때는 정확하게 일치하는지 여부에 관계없이 검색이 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-247">The runtime stops probing the first time it finds an assembly that matches the simple assembly name referenced, whether it is a correct match or not.</span></span> <span data-ttu-id="08982-248">정확하게 일치하는 항목이면 해당 어셈블리가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-248">If it is a correct match, that assembly is used.</span></span> <span data-ttu-id="08982-249">정확하게 일치하는 항목이 아니면 검색이 중지되고 바인딩이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-249">If it is not a correct match, probing stops and binding fails.</span></span>  
  
 <span data-ttu-id="08982-250">문화권이 포함된 경우 다음 디렉터리가 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-250">If culture is included, the following directories are probed:</span></span>  
  
 <span data-ttu-id="08982-251">[응용 프로그램 기준 위치] / [binpath] / [문화권] / [어셈블리 이름].dll</span><span class="sxs-lookup"><span data-stu-id="08982-251">[application base] / [binpath] / [culture] / [assembly name].dll</span></span>  
  
 <span data-ttu-id="08982-252">[응용 프로그램 기준 위치] / [binpath] / [문화권] / [어셈블리 이름] / [어셈블리 이름].dll</span><span class="sxs-lookup"><span data-stu-id="08982-252">[application base] / [binpath] / [culture] / [assembly name] / [assembly name].dll</span></span>  
  
 <span data-ttu-id="08982-253">문화권 정보가 포함되지 않은 경우 다음 디렉터리가 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-253">If culture information is not included, the following directories are probed:</span></span>  
  
 <span data-ttu-id="08982-254">[응용 프로그램 기준 위치] / [binpath] / [어셈블리 이름].dll</span><span class="sxs-lookup"><span data-stu-id="08982-254">[application base] / [binpath] / [assembly name].dll</span></span>  
  
 <span data-ttu-id="08982-255">[응용 프로그램 기준 위치] / [binpath] / [어셈블리 이름] / [어셈블리 이름].dll</span><span class="sxs-lookup"><span data-stu-id="08982-255">[application base] / [binpath] / [assembly name] / [assembly name].dll</span></span>  
  
#### <a name="probing-examples"></a><span data-ttu-id="08982-256">검색 예제</span><span class="sxs-lookup"><span data-stu-id="08982-256">Probing Examples</span></span>  
 <span data-ttu-id="08982-257">다음과 같은 정보가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-257">Given the following information:</span></span>  
  
-   <span data-ttu-id="08982-258">참조된 어셈블리 이름: myAssembly</span><span class="sxs-lookup"><span data-stu-id="08982-258">Referenced assembly name: myAssembly</span></span>  
  
-   <span data-ttu-id="08982-259">응용 프로그램 루트 디렉터리: http://www.code.microsoft.com</span><span class="sxs-lookup"><span data-stu-id="08982-259">Application root directory: http://www.code.microsoft.com</span></span>  
  
-   <span data-ttu-id="08982-260">구성 파일의 [\<probing>](../../../docs/framework/configure-apps/file-schema/runtime/probing-element.md) 요소가 지정하는 것: bin</span><span class="sxs-lookup"><span data-stu-id="08982-260">[\<probing>](../../../docs/framework/configure-apps/file-schema/runtime/probing-element.md) element in configuration file specifies: bin</span></span>  
  
-   <span data-ttu-id="08982-261">문화권: de</span><span class="sxs-lookup"><span data-stu-id="08982-261">Culture: de</span></span>  
  
 <span data-ttu-id="08982-262">이 경우 런타임은 다음과 같은 URL을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-262">The runtime probes the following URLs:</span></span>  
  
 http://www.code.microsoft.com/de/myAssembly.dll  
  
 http://www.code.microsoft.com/de/myAssembly/myAssembly.dll  
  
 http://www.code.microsoft.com/bin/de/myAssembly.dll  
  
 http://www.code.microsoft.com/bin/de/myAssembly/myAssembly.dll  
  
##### <a name="multiple-assemblies-with-the-same-name"></a><span data-ttu-id="08982-263">동일한 이름을 가진 여러 어셈블리</span><span class="sxs-lookup"><span data-stu-id="08982-263">Multiple Assemblies with the Same Name</span></span>  
 <span data-ttu-id="08982-264">다음 예제에서는 여러 어셈블리를 동일한 이름으로 구성하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="08982-264">The following example shows how to configure multiple assemblies with the same name.</span></span>  
  
```xml  
<dependentAssembly>  
   <assemblyIdentity name="Server" publicKeyToken="c0305c36380ba429" />   
   <codeBase version="1.0.0.0" href="v1/Server.dll" />  
   <codeBase version="2.0.0.0" href="v2/Server.dll" />  
</dependentAssembly>  
```  
  
#### <a name="other-locations-probed"></a><span data-ttu-id="08982-265">검색되는 기타 위치</span><span class="sxs-lookup"><span data-stu-id="08982-265">Other Locations Probed</span></span>  
 <span data-ttu-id="08982-266">현재 바인딩 컨텍스트를 사용하여 어셈블리 위치를 결정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08982-266">Assembly location can also be determined using the current binding context.</span></span> <span data-ttu-id="08982-267">이러한 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 메서드가 사용될 때 및 COM interop 시나리오에서 자주 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-267">This most often occurs when the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method is used and in COM interop scenarios.</span></span> <span data-ttu-id="08982-268">어셈블리가 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드를 사용하여 다른 어셈블리를 참조하는 경우 호출 어셈블리의 위치는 참조된 어셈블리를 찾을 수 있는 위치에 대한 힌트로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-268">If an assembly uses the <xref:System.Reflection.Assembly.LoadFrom%2A> method to reference another assembly, the calling assembly's location is considered to be a hint about where to find the referenced assembly.</span></span> <span data-ttu-id="08982-269">일치 항목이 있으면 해당 어셈블리가 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-269">If a match is found, that assembly is loaded.</span></span> <span data-ttu-id="08982-270">일치 항목이 없으면 런타임이 해당 검색 의미 체계를 계속하고 Windows Installer에 어셈블리를 제공하도록 쿼리합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-270">If no match is found, the runtime continues with its search semantics and then queries the Windows Installer to provide the assembly.</span></span> <span data-ttu-id="08982-271">바인딩 요청과 일치하는 어셈블리가 제공되지 않으면 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-271">If no assembly is provided that matches the binding request, an exception is thrown.</span></span> <span data-ttu-id="08982-272">이 예외는 형식이 참조된 경우 관리 코드의 <xref:System.TypeLoadException> 이거나, 로드되는 어셈블리가 없는 경우 <xref:System.IO.FileNotFoundException> 입니다.</span><span class="sxs-lookup"><span data-stu-id="08982-272">This exception is a <xref:System.TypeLoadException> in managed code if a type was referenced, or a <xref:System.IO.FileNotFoundException> if an assembly being loaded was not found.</span></span>  
  
 <span data-ttu-id="08982-273">예를 들어 Assembly1이 Assembly2를 참조하고 Assembly1이 http://www.code.microsoft.com/utils에서 다운로드된 경우 해당 위치는 Assembly2.dll을 찾을 수 있는 위치에 대한 힌트로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="08982-273">For example, if Assembly1 references Assembly2 and Assembly1 was downloaded from http://www.code.microsoft.com/utils, that location is considered to be a hint about where to find Assembly2.dll.</span></span> <span data-ttu-id="08982-274">런타임은 http://www.code.microsoft.com/utils/Assembly2.dll과 http://www.code.microsoft.com/utils/Assembly2/Assembly2.dll의 어셈블리를 탐지합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-274">The runtime then probes for the assembly in http://www.code.microsoft.com/utils/Assembly2.dll and http://www.code.microsoft.com/utils/Assembly2/Assembly2.dll.</span></span> <span data-ttu-id="08982-275">Assembly2가 이러한 위치 중 하나에  없으면 런타임에서 Windows Installer를 쿼리합니다.</span><span class="sxs-lookup"><span data-stu-id="08982-275">If Assembly2 is not found at either of those locations, the runtime queries the Windows Installer.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="08982-276">참고 항목</span><span class="sxs-lookup"><span data-stu-id="08982-276">See Also</span></span>  
 [<span data-ttu-id="08982-277">최선의 어셈블리 로드 방법</span><span class="sxs-lookup"><span data-stu-id="08982-277">Best Practices for Assembly Loading</span></span>](../../../docs/framework/deployment/best-practices-for-assembly-loading.md)  
 [<span data-ttu-id="08982-278">배포</span><span class="sxs-lookup"><span data-stu-id="08982-278">Deployment</span></span>](../../../docs/framework/deployment/index.md)

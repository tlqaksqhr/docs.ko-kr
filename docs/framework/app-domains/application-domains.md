---
title: 응용 프로그램 도메인
ms.date: 03/30/2017
helpviewer_keywords:
- process boundaries for isolation
- application isolation
- application domains, about
- common language runtime, application domains
- application domains
- runtime, application domains
- isolation between applications
- code, verification process
- verification testing code
ms.assetid: 113a8bbf-6875-4a72-a49d-ca2d92e19cc8
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 811443dbd8e2483f7fc1b0f8c44afb4ebcd9efcf
ms.sourcegitcommit: 22c3c8f74eaa138dbbbb02eb7d720fce87fc30a9
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/18/2018
ms.locfileid: "34233953"
---
# <a name="application-domains"></a><span data-ttu-id="b5a2b-102">응용 프로그램 도메인</span><span class="sxs-lookup"><span data-stu-id="b5a2b-102">Application Domains</span></span>
<span data-ttu-id="b5a2b-103">운영 체제와 런타임 환경은 일반적으로 응용 프로그램 간에 몇 가지 형식의 격리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-103">Operating systems and runtime environments typically provide some form of isolation between applications.</span></span> <span data-ttu-id="b5a2b-104">예를 들어 Windows에서는 프로세스를 사용하여 응용 프로그램을 격리합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-104">For example, Windows uses processes to isolate applications.</span></span> <span data-ttu-id="b5a2b-105">격리는 한 응용 프로그램에서 실행 중인 코드가 서로 관련 없는 다른 응용 프로그램에 나쁜 영향을 주지 않도록 하기 위해 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-105">This isolation is necessary to ensure that code running in one application cannot adversely affect other, unrelated applications.</span></span>  
  
 <span data-ttu-id="b5a2b-106">응용 프로그램 도메인은 보안, 안정성, 버전 관리, 어셈블리 언로드를 위해 격리 경계를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-106">Application domains provide an isolation boundary for security, reliability, and versioning, and for unloading assemblies.</span></span> <span data-ttu-id="b5a2b-107">응용 프로그램 도메인은 일반적으로 응용 프로그램이 실행되기 전에 공용 언어 런타임을 부트스트래핑해야 하는 런타임 호스트에 의해 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-107">Application domains are typically created by runtime hosts, which are responsible for bootstrapping the common language runtime before an application is run.</span></span>  
  
 <span data-ttu-id="b5a2b-108">문서의 이 단원에 있는 항목에서는 응용 프로그램 도메인을 사용하여 어셈블리 간에 격리를 제공하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-108">The topics in this section of the documentation explain how to use application domains to provide isolation between assemblies.</span></span>  
  
 <span data-ttu-id="b5a2b-109">이 개요는 다음과 같은 단원으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="b5a2b-110">응용 프로그램 격리의 장점</span><span class="sxs-lookup"><span data-stu-id="b5a2b-110">The Benefits of Isolating Applications</span></span>](#benefits)  
  
-   [<span data-ttu-id="b5a2b-111">참조</span><span class="sxs-lookup"><span data-stu-id="b5a2b-111">Reference</span></span>](#reference)  
  
<a name="benefits"></a>   
## <a name="the-benefits-of-isolating-applications"></a><span data-ttu-id="b5a2b-112">응용 프로그램 격리의 장점</span><span class="sxs-lookup"><span data-stu-id="b5a2b-112">The Benefits of Isolating Applications</span></span>  
 <span data-ttu-id="b5a2b-113">지금까지는 동일한 컴퓨터에서 실행 중인 여러 응용 프로그램을 격리시키기 위해 프로세스 경계를 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-113">Historically, process boundaries have been used to isolate applications running on the same computer.</span></span> <span data-ttu-id="b5a2b-114">각 응용 프로그램은 독립된 프로세스에 로드되어 동일한 컴퓨터에서 실행 중인 다른 컴퓨터와 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-114">Each application is loaded into a separate process, which isolates the application from other applications running on the same computer.</span></span>  
  
 <span data-ttu-id="b5a2b-115">메모리 주소는 프로세스에 상대적이고 한 프로세스에서 다른 프로세스로 전달된 메모리 포인터는 대상 프로세스에서 의미 있는 방식으로 사용될 수 없으므로 응용 프로그램이 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-115">The applications are isolated because memory addresses are process-relative; a memory pointer passed from one process to another cannot be used in any meaningful way in the target process.</span></span> <span data-ttu-id="b5a2b-116">또한 두 프로세스를 서로 직접 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-116">In addition, you cannot make direct calls between two processes.</span></span> <span data-ttu-id="b5a2b-117">대신 간접 참조 수준을 제공하는 프록시를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-117">Instead, you must use proxies, which provide a level of indirection.</span></span>  
  
 <span data-ttu-id="b5a2b-118">관리 코드는 확인 프로세스를 통과해야 실행할 수 있습니다. 단, 관리자가 이 프로세스를 건너 뛸 수 있는 권한을 부여한 경우는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-118">Managed code must be passed through a verification process before it can be run (unless the administrator has granted permission to skip the verification).</span></span> <span data-ttu-id="b5a2b-119">확인 프로세스는 해당 코드가 잘못된 메모리 주소에 액세스할 수 있는지 또는 실행 중인 프로세스를 정상적으로 작동할 수 없게 하는 일부 다른 작업을 수행할 수 있는지 등을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-119">The verification process determines whether the code can attempt to access invalid memory addresses or perform some other action that could cause the process in which it is running to fail to operate properly.</span></span> <span data-ttu-id="b5a2b-120">확인 테스트를 통과하는 코드를 형식이 안전한 코드라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-120">Code that passes the verification test is said to be type-safe.</span></span> <span data-ttu-id="b5a2b-121">코드를 형식에 안전하다고 확인하는 기능을 통해 공용 언어 런타임에서는 성능상의 손실을 낮추고 프로세스 경계 만큼의 높은 격리 수준을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-121">The ability to verify code as type-safe enables the common language runtime to provide as great a level of isolation as the process boundary, at a much lower performance cost.</span></span>  
  
 <span data-ttu-id="b5a2b-122">응용 프로그램 도메인은 공용 언어 런타임에서 응용 프로그램 간에 격리를 제공하기 위해 사용할 수 있는 더욱 안전한 다용도의 처리 단위를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-122">Application domains provide a more secure and versatile unit of processing that the common language runtime can use to provide isolation between applications.</span></span> <span data-ttu-id="b5a2b-123">사용자는 여러 응용 프로그램 도메인을 하나의 프로세스에서 실행할 때, 별개의 프로세스에 존재하도록 동일한 격리 수준을 유지하면서도 프로세스 간에 크로스 프로세스 호출 또는 전환으로 인한 추가 오버헤드가 발생하지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-123">You can run several application domains in a single process with the same level of isolation that would exist in separate processes, but without incurring the additional overhead of making cross-process calls or switching between processes.</span></span> <span data-ttu-id="b5a2b-124">단일 프로세스에서 여러 응용 프로그램을 실행할 수 있는 기능을 통해 서버 확장성이 상당히 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-124">The ability to run multiple applications within a single process dramatically increases server scalability.</span></span>  
  
 <span data-ttu-id="b5a2b-125">또한 응용 프로그램 격리는 응용 프로그램 보안 측면에서도 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-125">Isolating applications is also important for application security.</span></span> <span data-ttu-id="b5a2b-126">예를 들면 각 컨트롤이 서로의 데이터와 리소스에 액세스할 수 없는 방식으로 여러 웹 응용 프로그램의 컨트롤을 단일 브라우저 프로세스에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-126">For example, you can run controls from several Web applications in a single browser process in such a way that the controls cannot access each other's data and resources.</span></span>  
  
 <span data-ttu-id="b5a2b-127">응용 프로그램 도메인에서 제공하는 격리에는 다음과 같은 몇 가지 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-127">The isolation provided by application domains has the following benefits:</span></span>  
  
-   <span data-ttu-id="b5a2b-128">한 응용 프로그램에서 발생한 오류가 다른 응용 프로그램에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-128">Faults in one application cannot affect other applications.</span></span> <span data-ttu-id="b5a2b-129">형식이 안전한 코드는 메모리 오류를 일으킬 수 없으므로 응용 프로그램 도메인을 사용하면 한 도메인에서 실행 중인 코드가 프로세스의 다른 응용 프로그램에 영향을 줄 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-129">Because type-safe code cannot cause memory faults, using application domains ensures that code running in one domain cannot affect other applications in the process.</span></span>  
  
-   <span data-ttu-id="b5a2b-130">전체 프로세스를 중지하지 않고 개별 응용 프로그램만 중지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-130">Individual applications can be stopped without stopping the entire process.</span></span> <span data-ttu-id="b5a2b-131">응용 프로그램 도메인을 사용하면 단일 응용 프로그램에서 실행 중인 코드를 언로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-131">Using application domains enables you to unload the code running in a single application.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b5a2b-132">개별 어셈블리 또는 형식은 언로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-132">You cannot unload individual assemblies or types.</span></span> <span data-ttu-id="b5a2b-133">전체 도메인만 언로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-133">Only a complete domain can be unloaded.</span></span>  
  
-   <span data-ttu-id="b5a2b-134">한 응용 프로그램에서 실행 중인 코드가 다른 응용 프로그램의 코드 또는 리소스에 직접 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-134">Code running in one application cannot directly access code or resources from another application.</span></span> <span data-ttu-id="b5a2b-135">공용 언어 런타임은 다른 응용 프로그램 도메인의 개체를 서로 직접 호출할 수 없도록 하여 이러한 격리를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-135">The common language runtime enforces this isolation by preventing direct calls between objects in different application domains.</span></span> <span data-ttu-id="b5a2b-136">도메인 사이를 통과하는 개체는 복사되거나 프록시에 의해 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-136">Objects that pass between domains are either copied or accessed by proxy.</span></span> <span data-ttu-id="b5a2b-137">개체가 복사되는 경우 해당 개체에 대한 호출은 로컬입니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-137">If the object is copied, the call to the object is local.</span></span> <span data-ttu-id="b5a2b-138">즉, 참조되는 개체와 호출자 둘 다 같은 응용 프로그램 도메인에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-138">That is, both the caller and the object being referenced are in the same application domain.</span></span> <span data-ttu-id="b5a2b-139">프록시를 통해 개체가 액세스되는 경우 해당 개체에 대한 호출은 원격입니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-139">If the object is accessed through a proxy, the call to the object is remote.</span></span> <span data-ttu-id="b5a2b-140">이 경우 참조되는 개체와 호출자는 서로 다른 응용 프로그램 도메인에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-140">In this case, the caller and the object being referenced are in different application domains.</span></span> <span data-ttu-id="b5a2b-141">크로스 도메인 호출은 두 프로세스 또는 두 컴퓨터 사이의 호출과 동일한 원격 호출 인프라를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-141">Cross-domain calls use the same remote call infrastructure as calls between two processes or between two machines.</span></span> <span data-ttu-id="b5a2b-142">따라서 메서드 호출을 올바르게 JIT로 컴파일할 수 있도록 하기 위해 참조되는 개체의 메타데이터를 두 응용 프로그램 도메인에서 모두 사용할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-142">As such, the metadata for the object being referenced must be available to both application domains to allow the method call to be JIT-compiled properly.</span></span> <span data-ttu-id="b5a2b-143">호출하는 도메인이 호출되는 개체의 메타데이터에 액세스할 수 없는 경우 **System.IO.FileNotFound** 형식의 예외가 발생하여 컴파일할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-143">If the calling domain does not have access to the metadata for the object being called, the compilation might fail with an exception of type **System.IO.FileNotFound**.</span></span> <span data-ttu-id="b5a2b-144">자세한 내용은 [원격 개체](http://msdn.microsoft.com/library/515686e6-0a8d-42f7-8188-73abede57c58)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-144">See [Remote Objects](http://msdn.microsoft.com/library/515686e6-0a8d-42f7-8188-73abede57c58) for more details.</span></span> <span data-ttu-id="b5a2b-145">도메인 사이에서 개체에 액세스할 수 있는 방법을 결정하는 메커니즘은 개체에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-145">The mechanism for determining how objects can be accessed across domains is determined by the object.</span></span> <span data-ttu-id="b5a2b-146">자세한 내용은 <xref:System.MarshalByRefObject?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-146">For more information, see <xref:System.MarshalByRefObject?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b5a2b-147">코드의 동작 범위는 해당 코드가 실행되는 응용 프로그램에 의해 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-147">The behavior of code is scoped by the application in which it runs.</span></span> <span data-ttu-id="b5a2b-148">즉, 응용 프로그램 도메인은 응용 프로그램 버전 정책, 액세스하는 원격 어셈블리의 위치, 도메인으로 로드하는 어셈블리를 찾을 위치 관련 정보 등의 구성 설정을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-148">In other words, the application domain provides configuration settings such as application version policies, the location of any remote assemblies it accesses, and information about where to locate assemblies that are loaded into the domain.</span></span>  
  
-   <span data-ttu-id="b5a2b-149">코드에 부여된 권한은 해당 코드가 실행 중인 응용 프로그램 도메인에서 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-149">Permissions granted to code can be controlled by the application domain in which the code is running.</span></span>  
  
  
## <a name="application-domains-and-assemblies"></a><span data-ttu-id="b5a2b-150">응용 프로그램 도메인 및 어셈블리</span><span class="sxs-lookup"><span data-stu-id="b5a2b-150">Application Domains and Assemblies</span></span>  
 <span data-ttu-id="b5a2b-151">이 항목에서는 응용 프로그램 도메인과 어셈블리 사이의 관계에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-151">This topic describes the relationship between application domains and assemblies.</span></span> <span data-ttu-id="b5a2b-152">어셈블리에 포함되어 있는 코드를 실행하려면 먼저 해당 어셈블리를 응용 프로그램 도메인에 로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-152">You must load an assembly into an application domain before you can execute the code it contains.</span></span> <span data-ttu-id="b5a2b-153">일반적으로 응용 프로그램을 실행하면 여러 어셈블리가 응용 프로그램 도메인에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-153">Running a typical application causes several assemblies to be loaded into an application domain.</span></span>  
  
 <span data-ttu-id="b5a2b-154">어셈블리가 로드되는 방식에 따라 프로세스에서 여러 응용 프로그램 도메인이 해당 어셈블리의 JIT(Just-In-Time) 컴파일된 코드를 공유할 수 있는지 여부와 어셈블리를 프로세스에서 언로드할 수 있는지 여부가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-154">The way an assembly is loaded determines whether its just-in-time (JIT) compiled code can be shared by multiple application domains in the process, and whether the assembly can be unloaded from the process.</span></span>  
  
-   <span data-ttu-id="b5a2b-155">어셈블리가 도메인 중립적으로 로드된 경우 동일한 보안 권한 부여 집합을 공유하는 모든 응용 프로그램 도메인에서 동일한 JIT 컴파일된 코드를 공유할 수 있으므로 응용 프로그램에 필요한 메모리가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-155">If an assembly is loaded domain-neutral, all application domains that share the same security grant set can share the same JIT-compiled code, which reduces the memory required by the application.</span></span> <span data-ttu-id="b5a2b-156">그러나 어셈블리를 프로세스에서 언로드할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-156">However, the assembly can never be unloaded from the process.</span></span>  
  
-   <span data-ttu-id="b5a2b-157">어셈블리가 도메인 중립적으로 로드되지 않은 경우 해당 어셈블리가 로드된 모든 응용 프로그램 도메인에서 어셈블리를 JIT 컴파일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-157">If an assembly is not loaded domain-neutral, it must be JIT-compiled in every application domain in which it is loaded.</span></span> <span data-ttu-id="b5a2b-158">그러나 어셈블리가 로드된 모든 응용 프로그램 도메인을 언로드하여 프로세스에서 어셈블리를 언로드할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-158">However, the assembly can be unloaded from the process by unloading all the application domains in which it is loaded.</span></span>  
  
 <span data-ttu-id="b5a2b-159">런타임 호스트는 런타임을 프로세스로 로드하는 경우 도메인 중립적으로 어셈블리를 로드할지 여부를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-159">The runtime host determines whether to load assemblies as domain-neutral when it loads the runtime into a process.</span></span> <span data-ttu-id="b5a2b-160">관리되는 응용 프로그램의 경우 프로세스의 진입점 메서드에 <xref:System.LoaderOptimizationAttribute> 특성을 적용하고 연관된 <xref:System.LoaderOptimization> 열거형의 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-160">For managed applications, apply the <xref:System.LoaderOptimizationAttribute> attribute to the entry-point method for the process, and specify a value from the associated <xref:System.LoaderOptimization> enumeration.</span></span> <span data-ttu-id="b5a2b-161">공용 언어 런타임을 호스팅하는 관리되지 않는 응용 프로그램의 경우 [CorBindToRuntimeEx 함수](../../../docs/framework/unmanaged-api/hosting/corbindtoruntimeex-function.md) 메서드를 호출할 때 적절한 플래그를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-161">For unmanaged applications that host the common language runtime, specify the appropriate flag when you call the [CorBindToRuntimeEx Function](../../../docs/framework/unmanaged-api/hosting/corbindtoruntimeex-function.md) method.</span></span>  
  
 <span data-ttu-id="b5a2b-162">도메인 중립 어셈블리를 로드할 수 있는 다음과 같은 세 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-162">There are three options for loading domain-neutral assemblies:</span></span>  
  
- <span data-ttu-id="b5a2b-163"><xref:System.LoaderOptimization.SingleDomain?displayProperty=nameWithType>에서는 어셈블리를 도메인 중립적으로 로드하지 않습니다. 단, 항상 도메인 중립적으로 로드되는 Mscorlib는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-163"><xref:System.LoaderOptimization.SingleDomain?displayProperty=nameWithType> loads no assemblies as domain-neutral, except Mscorlib, which is always loaded domain-neutral.</span></span> <span data-ttu-id="b5a2b-164">이 설정은 일반적으로 호스트가 프로세스에서 단일 응용 프로그램을 실행 중인 경우에만 사용되므로 단일 도메인이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-164">This setting is called single domain because it is commonly used when the host is running only a single application in the process.</span></span>

- <span data-ttu-id="b5a2b-165"><xref:System.LoaderOptimization.MultiDomain?displayProperty=nameWithType>에서는 모든 어셈블리를 도메인 중립적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-165"><xref:System.LoaderOptimization.MultiDomain?displayProperty=nameWithType> loads all assemblies as domain-neutral.</span></span> <span data-ttu-id="b5a2b-166">프로세스에 여러 응용 프로그램 도메인이 있고 모두 동일한 코드를 실행하는 경우 이 설정을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-166">Use this setting when there are multiple application domains in the process, all of which run the same code.</span></span>

- <span data-ttu-id="b5a2b-167"><xref:System.LoaderOptimization.MultiDomainHost?displayProperty=nameWithType>에서는 강력한 이름의 어셈블리와 이 어셈블리의 모든 종속 어셈블리가 전역 어셈블리 캐시에 설치되어 있는 경우 강력한 이름의 어셈블리를 도메인 중립적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-167"><xref:System.LoaderOptimization.MultiDomainHost?displayProperty=nameWithType> loads strong-named assemblies as domain-neutral, if they and all their dependencies have been installed in the global assembly cache.</span></span> <span data-ttu-id="b5a2b-168">다른 어셈블리는 해당 어셈블리가 로드되는 각 응용 프로그램 도메인에 대해 개별적으로 로드되고 JIT 컴파일되므로 프로세스에서 언로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-168">Other assemblies are loaded and JIT-compiled separately for each application domain in which they are loaded, and thus can be unloaded from the process.</span></span> <span data-ttu-id="b5a2b-169">동일한 프로세스에서 둘 이상의 응용 프로그램을 실행할 경우나 여러 응용 프로그램 도메인에서 공유되는 어셈블리와 프로세스에서 언로드해야 하는 어셈블리가 혼합된 경우 이 설정을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-169">Use this setting when running more than one application in the same process, or if you have a mixture of assemblies that are shared by many application domains and assemblies that need to be unloaded from the process.</span></span>
  
 <span data-ttu-id="b5a2b-170"><xref:System.Reflection.Assembly.LoadFrom%2A> 클래스의 <xref:System.Reflection.Assembly> 메서드를 사용하여 로드 컨텍스트로 로드한 어셈블리나 바이트 배열을 지정하는 <xref:System.Reflection.Assembly.Load%2A> 메서드의 오버로드를 사용하여 이미지에서 로드한 어셈블리의 경우 JIT 컴파일된 코드를 공유할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-170">JIT-compiled code cannot be shared for assemblies loaded into the load-from context, using the <xref:System.Reflection.Assembly.LoadFrom%2A> method of the <xref:System.Reflection.Assembly> class, or loaded from images using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify byte arrays.</span></span>  
  
 <span data-ttu-id="b5a2b-171">[Ngen.exe(네이티브 이미지 생성기)](../../../docs/framework/tools/ngen-exe-native-image-generator.md)를 사용하여 네이티브 코드로 컴파일된 어셈블리는 프로세스에 처음 로드될 때 도메인 중립적으로 로드되는 경우 응용 프로그램 도메인 간에 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-171">Assemblies that have been compiled to native code by using the [Ngen.exe (Native Image Generator)](../../../docs/framework/tools/ngen-exe-native-image-generator.md) can be shared between application domains, if they are loaded domain-neutral the first time they are loaded into a process.</span></span>  
  
 <span data-ttu-id="b5a2b-172">응용 프로그램 진입점이 포함된 어셈블리의 JIT 컴파일된 코드는 모든 종속 어셈블리를 공유할 수 있는 경우에만 공유됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-172">JIT-compiled code for the assembly that contains the application entry point is shared only if all its dependencies can be shared.</span></span>  
  
 <span data-ttu-id="b5a2b-173">도메인 중립 어셈블리는 두 번 이상 JIT 컴파일할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-173">A domain-neutral assembly can be JIT-compiled more than once.</span></span> <span data-ttu-id="b5a2b-174">예를 들어, 보안 권한 부여 집합이 각기 다른 두 응용 프로그램 도메인에서 동일한 JIT 컴파일된 코드를 공유할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-174">For example, when the security grant sets of two application domains are different, they cannot share the same JIT-compiled code.</span></span> <span data-ttu-id="b5a2b-175">그러나 JIT 컴파일된 어셈블리의 각 복사본은 동일한 권한 부여 집합이 있는 다른 응용 프로그램 도메인과 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-175">However, each copy of the JIT-compiled assembly can be shared with other application domains that have the same grant set.</span></span>  
  
 <span data-ttu-id="b5a2b-176">어셈블리를 도메인 중립적으로 로드할지 여부를 결정할 때는 메모리 사용량 감소와 기타 성능 요인 간의 균형을 조절해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-176">When you decide whether to load assemblies as domain-neutral, you must make a tradeoff between reducing memory use and other performance factors.</span></span>  
  
-   <span data-ttu-id="b5a2b-177">도메인 중립 어셈블리의 경우 어셈블리를 격리시켜야 하므로 정적 데이터 및 메서드에 액세스하는 속도가 느립니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-177">Access to static data and methods is slower for domain-neutral assemblies because of the need to isolate assemblies.</span></span> <span data-ttu-id="b5a2b-178">어셈블리에 액세스하는 각 응용 프로그램 도메인은 정적 필드의 개체에 대한 참조가 도메인 경계를 지나지 않도록 정적 데이터의 개별 복사본을 가지고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-178">Each application domain that accesses the assembly must have a separate copy of the static data, to prevent references to objects in static fields from crossing domain boundaries.</span></span> <span data-ttu-id="b5a2b-179">결과적으로 런타임은 호출자에 추가 논리를 포함시켜서 정적 데이터 또는 메서드의 적절한 복사본으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-179">As a result, the runtime contains additional logic to direct a caller to the appropriate copy of the static data or method.</span></span> <span data-ttu-id="b5a2b-180">이 추가 논리는 호출 속도를 늦춥니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-180">This extra logic slows down the call.</span></span>  
  
-   <span data-ttu-id="b5a2b-181">어셈블리에 도메인 중립적으로 로드할 수 없는 종속 어셈블리가 있으면 해당 어셈블리가 도메인 중립적으로 로드되지 않으므로 어셈블리를 도메인 중립적으로 로드할 때는 해당 어셈블리의 모든 종속 어셈블리를 찾아서 로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-181">All the dependencies of an assembly must be located and loaded when the assembly is loaded domain-neutral, because a dependency that cannot be loaded domain-neutral prevents the assembly from being loaded domain-neutral.</span></span>  
  
## <a name="application-domains-and-threads"></a><span data-ttu-id="b5a2b-182">응용 프로그램 도메인과 스레드</span><span class="sxs-lookup"><span data-stu-id="b5a2b-182">Application Domains and Threads</span></span>  
 <span data-ttu-id="b5a2b-183">응용 프로그램 도메인은 보안, 버전 관리, 안정성 및 관리 코드 언로드를 위해 격리 경계를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-183">An application domain forms an isolation boundary for security, versioning, reliability, and unloading of managed code.</span></span> <span data-ttu-id="b5a2b-184">스레드는 코드를 실행하기 위해 공용 언어 런타임에서 사용하는 운영 체제 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-184">A thread is the operating system construct used by the common language runtime to execute code.</span></span> <span data-ttu-id="b5a2b-185">런타임에서 모든 관리 코드는 응용 프로그램 도메인에 로드되고 하나 이상의 관리되는 스레드에 의해 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-185">At run time, all managed code is loaded into an application domain and is run by one or more managed threads.</span></span>  
  
 <span data-ttu-id="b5a2b-186">응용 프로그램 도메인과 스레드 간에는 일대일 상관 관계가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-186">There is not a one-to-one correlation between application domains and threads.</span></span> <span data-ttu-id="b5a2b-187">일부 스레드는 어느 시점에서든 단일 응용 프로그램 도메인에서 실행될 수 있으며, 특정 스레드는 단일 응용 프로그램 도메인으로 제한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-187">Several threads can execute in a single application domain at any given time, and a particular thread is not confined to a single application domain.</span></span> <span data-ttu-id="b5a2b-188">즉, 스레드는 크로스 응용 프로그램 도메인 경계에 종속되지 않고 각 응용 프로그램 도메인에 대해 새 스레드가 만들어지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-188">That is, threads are free to cross application domain boundaries; a new thread is not created for each application domain.</span></span>  
  
 <span data-ttu-id="b5a2b-189">어느 시점에서든 모든 스레드는 단일 응용 프로그램 도메인에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-189">At any given time, every thread executes in an application domain.</span></span> <span data-ttu-id="b5a2b-190">지정된 응용 프로그램 도메인에서 0개, 한 개 또는 여러 개의 스레드가 실행 중일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-190">Zero, one, or multiple threads might be executing in any given application domain.</span></span> <span data-ttu-id="b5a2b-191">런타임은 응용 프로그램 도메인에서 실행 중인 스레드를 추적하므로</span><span class="sxs-lookup"><span data-stu-id="b5a2b-191">The run time keeps track of which threads are running in which application domains.</span></span> <span data-ttu-id="b5a2b-192">사용자는 언제든지 <xref:System.Threading.Thread.GetDomain%2A?displayProperty=nameWithType> 메서드를 호출하여 스레드가 실행되고 있는 도메인을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-192">You can locate the domain in which a thread is executing at any time by calling the <xref:System.Threading.Thread.GetDomain%2A?displayProperty=nameWithType> method.</span></span>  
  
### <a name="application-domains-and-cultures"></a><span data-ttu-id="b5a2b-193">응용 프로그램 도메인 및 문화권</span><span class="sxs-lookup"><span data-stu-id="b5a2b-193">Application Domains and Cultures</span></span>  
 <span data-ttu-id="b5a2b-194">스레드와 연결된 <xref:System.Globalization.CultureInfo> 개체로 표현되는 문화권입니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-194">Culture, which is represented by a <xref:System.Globalization.CultureInfo> object, is associated with threads.</span></span> <span data-ttu-id="b5a2b-195"><xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성을 사용하여 현재 실행 중인 스레드와 연결된 문화권을 가져오고 <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> 속성을 사용하여 현재 실행 중인 스레드와 연결된 문화권을 가져오거나 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-195">You can get the culture that is associated with the currently executing thread by using the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property, and you can get or set the culture that is associated with the currently executing thread by using the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b5a2b-196">스레드와 연결된 문화권을 <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> 속성을 사용하여 명시적으로 설정한 경우, 스레드가 응용 프로그램 도메인 경계를 넘나들 때 해당 스레드와 계속해서 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-196">If the culture that is associated with a thread has been explicitly set by using the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> property, it continues to be associated with that thread when the thread crosses application domain boundaries.</span></span> <span data-ttu-id="b5a2b-197">어느 시점에서 문화권이 스레드와 연결되어 있는지 여부는 스레드가 실행 중인 응용 프로그램 도메인의 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> 속성 값에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-197">Otherwise, the culture that is associated with the thread at any given time is determined by the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> property in the application domain in which the thread is executing:</span></span>  
  
-   <span data-ttu-id="b5a2b-198">속성 값이 `null`이 아닌 경우, 속성에 의해 반환되는 문화권은 스레드와 연결되어 있습니다. 따라서 <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-198">If the value of the property is not `null`, the culture that is returned by the property is associated with the thread (and therefore returned by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> properties).</span></span>  
  
-   <span data-ttu-id="b5a2b-199">속성 값이 `null`인 경우 현재 시스템 문화권이 스레드와 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-199">If the value of the property is `null`, the current system culture is associated with the thread.</span></span>  
  
## <a name="programming-with-application-domains"></a><span data-ttu-id="b5a2b-200">응용 프로그램 도메인으로 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="b5a2b-200">Programming with Application Domains</span></span>  
 <span data-ttu-id="b5a2b-201">응용 프로그램 도메인은 일반적으로 런타임 호스트가 프로그래밍 방식으로 만들고 조작합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-201">Application domains are usually created and manipulated programmatically by runtime hosts.</span></span> <span data-ttu-id="b5a2b-202">그러나 때때로 응용 프로그램에서 응용 프로그램 도메인을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-202">However, sometimes an application program might also want to work with application domains.</span></span> <span data-ttu-id="b5a2b-203">예를 들어, 전체 응용 프로그램을 중지하지 않고도 도메인과 구성 요소를 언로드할 수 있도록 응용 프로그램에서 응용 프로그램 구성 요소를 도메인에 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-203">For example, an application program could load an application component into a domain to be able to unload the domain (and the component) without having to stop the entire application.</span></span>  
  
 <span data-ttu-id="b5a2b-204"><xref:System.AppDomain>은 응용 프로그램 도메인에 대한 프로그래밍 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-204">The <xref:System.AppDomain> is the programmatic interface to application domains.</span></span> <span data-ttu-id="b5a2b-205">이 클래스는 도메인을 만들고 언로드하며 도메인에서 형식 인스턴스를 만들고 응용 프로그램 도메인 언로드와 같이 다양한 알림을 등록할 수 있는 메서드를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-205">This class includes methods to create and unload domains, to create instances of types in domains, and to register for various notifications such as application domain unloading.</span></span> <span data-ttu-id="b5a2b-206">다음 표에는 자주 사용되는 <xref:System.AppDomain> 메서드가 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-206">The following table lists commonly used <xref:System.AppDomain> methods.</span></span>  
  
|<span data-ttu-id="b5a2b-207">AppDomain 메서드</span><span class="sxs-lookup"><span data-stu-id="b5a2b-207">AppDomain Method</span></span>|<span data-ttu-id="b5a2b-208">설명</span><span class="sxs-lookup"><span data-stu-id="b5a2b-208">Description</span></span>|  
|----------------------|-----------------|  
|<xref:System.AppDomain.CreateDomain%2A>|<span data-ttu-id="b5a2b-209">새 응용 프로그램 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-209">Creates a new application domain.</span></span> <span data-ttu-id="b5a2b-210"><xref:System.AppDomainSetup> 개체를 지정하는 이 메서드의 오버로드를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-210">It is recommended that you use an overload of this method that specifies an <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="b5a2b-211">이 메서드는 응용 프로그램 기본 디렉터리 또는 응용 프로그램의 루트 디렉터리, 도메인의 구성 파일 위치 및 어셈블리를 도메인에 로드하기 위해 공용 언어 런타임에서 사용할 검색 경로 등 새 도메인의 속성을 설정하는 기본적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-211">This is the preferred way to set the properties of a new domain, such as the application base, or root directory for the application; the location of the configuration file for the domain; and the search path that the common language runtime is to use to load assemblies into the domain.</span></span>|  
|<span data-ttu-id="b5a2b-212"><xref:System.AppDomain.ExecuteAssembly%2A> 및 <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="b5a2b-212"><xref:System.AppDomain.ExecuteAssembly%2A> and <xref:System.AppDomain.ExecuteAssemblyByName%2A></span></span>|<span data-ttu-id="b5a2b-213">응용 프로그램 도메인에서 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-213">Executes an assembly in the application domain.</span></span> <span data-ttu-id="b5a2b-214">이 메서드는 인스턴스 메서드이므로 참조할 다른 응용 프로그램 도메인에서 코드를 실행하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-214">This is an instance method, so it can be used to execute code in another application domain to which you have a reference.</span></span>|  
|<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>|<span data-ttu-id="b5a2b-215">응용 프로그램 도메인에서 지정한 형식의 인스턴스를 만들고 프록시를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-215">Creates an instance of a specified type in the application domain, and returns a proxy.</span></span> <span data-ttu-id="b5a2b-216">만들어진 형식을 포함하는 어셈블리가 호출 어셈블리에 로드되지 않도록 하려면 이 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-216">Use this method to avoid loading the assembly containing the created type into the calling assembly.</span></span>|  
|<xref:System.AppDomain.Unload%2A>|<span data-ttu-id="b5a2b-217">도메인을 완전 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-217">Performs a graceful shutdown of the domain.</span></span> <span data-ttu-id="b5a2b-218">응용 프로그램 도메인은 도메인에서 실행 중인 모든 스레드가 중지되거나 더 이상 도메인에 없을 때까지 언로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-218">The application domain is not unloaded until all threads running in the domain have either stopped or are no longer in the domain.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="b5a2b-219">공용 언어 런타임에서는 전역 메서드의 serialization을 지원하지 않으므로 다른 응용 프로그램 도메인에서 대리자를 사용하여 전역 메서드를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-219">The common language runtime does not support serialization of global methods, so delegates cannot be used to execute global methods in other application domains.</span></span>  
  
 <span data-ttu-id="b5a2b-220">또한 공용 언어 런타임 호스팅 인터페이스 사양에 설명되어 있는 관리되지 않는 인터페이스를 사용하여 응용 프로그램 도메인에 액세스할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-220">The unmanaged interfaces described in the common language runtime Hosting Interfaces Specification also provide access to application domains.</span></span> <span data-ttu-id="b5a2b-221">런타임 호스트는 비관리 코드에서 인터페이스를 사용하여 프로세스 내에서 응용 프로그램 도메인을 만들고 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-221">Runtime hosts can use interfaces from unmanaged code to create and gain access to the application domains within a process.</span></span>  
  
## <a name="complusloaderoptimization-environment-variable"></a><span data-ttu-id="b5a2b-222">COMPLUS_LoaderOptimization 환경 변수</span><span class="sxs-lookup"><span data-stu-id="b5a2b-222">COMPLUS_LoaderOptimization Environment Variable</span></span>  
 <span data-ttu-id="b5a2b-223">실행 가능한 응용 프로그램의 기본 로더 최적화 정책을 설정하는 환경 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-223">An environment variable that sets the default loader optimization policy of an executable application.</span></span>  
  
### <a name="syntax"></a><span data-ttu-id="b5a2b-224">구문</span><span class="sxs-lookup"><span data-stu-id="b5a2b-224">Syntax</span></span>  
  
```  
COMPLUS_LoaderOptimization = 1  
```  
  
### <a name="remarks"></a><span data-ttu-id="b5a2b-225">설명</span><span class="sxs-lookup"><span data-stu-id="b5a2b-225">Remarks</span></span>  
 <span data-ttu-id="b5a2b-226">일반적인 응용 프로그램은 포함된 코드를 실행하기 전에 응용 프로그램 도메인에 여러 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-226">A typical application loads several assemblies into an application domain before the code they contain can be executed.</span></span>  
  
 <span data-ttu-id="b5a2b-227">어셈블리가 로드되는 방식에 따라 프로세스에서 여러 응용 프로그램 도메인이 해당 어셈블리의 JIT(Just-In-Time) 컴파일된 코드를 공유할 수 있는지 여부가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-227">The way the assembly is loaded determines whether its just-in-time (JIT) compiled code can be shared by multiple application domains in the process.</span></span>  
  
-   <span data-ttu-id="b5a2b-228">어셈블리가 도메인 중립적으로 로드되는 경우 같은 보안 권한 설정을 공유하는 모든 응용 프로그램 도메인은 동일한 JIT-컴파일된 코드를 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-228">If an assembly is loaded domain-neutral, all application domains that share the same security grant set can share the same JIT-compiled code.</span></span> <span data-ttu-id="b5a2b-229">이렇게 하면 응용 프로그램에 필요한 메모리가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-229">This reduces the memory required by the application.</span></span>  
  
-   <span data-ttu-id="b5a2b-230">어셈블리가 도메인 중립적으로 로드되지 않은 경우 로드되는 모든 응용 프로그램 도메인에서 JIT-컴파일되어야 하며 로더는 응용 프로그램 도메인에서 내부 리소스를 공유해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-230">If an assembly is not loaded domain-neutral, it must be JIT-compiled in every application domain in which it is loaded and the loader must not share internal resources across application domains.</span></span>  
  
 <span data-ttu-id="b5a2b-231">COMPLUS_LoaderOptimization 환경 플래그가 1로 설정되면 런타임 호스트가 모든 어셈블리를 SingleDomain이라는 비 도메인 중립 방식으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-231">When set to 1, the COMPLUS_LoaderOptimization environment flag forces the runtime host to load all assemblies in non-domain-neutral way known as SingleDomain.</span></span> <span data-ttu-id="b5a2b-232">SingleDomain은 어셈블리를 도메인 중립적으로 로드하지 않습니다. 단, 항상 도메인 중립적으로 로드되는 Mscorlib는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-232">SingleDomain loads no assemblies as domain-neutral, except Mscorlib, which is always loaded domain-neutral.</span></span> <span data-ttu-id="b5a2b-233">이 설정은 일반적으로 호스트가 프로세스에서 단일 응용 프로그램을 실행 중인 경우에만 사용되므로 단일 도메인이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-233">This setting is called single domain because it is commonly used when the host is running only a single application in the process.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b5a2b-234">COMPLUS_LoaderOptimization 환경 플래그는 진단 및 테스트 시나리오에 사용할 수 있도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-234">The COMPLUS_LoaderOptimization environment flag was designed to be used in diagnostic and test scenarios.</span></span> <span data-ttu-id="b5a2b-235">플래그가 설정되어 있으면 속도가 심각하게 느려지고 메모리 사용량이 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-235">Having the flag turned on can cause severe slow-down and increase in memory usage.</span></span>  
  
### <a name="code-example"></a><span data-ttu-id="b5a2b-236">코드 예제</span><span class="sxs-lookup"><span data-stu-id="b5a2b-236">Code Example</span></span>  
 <span data-ttu-id="b5a2b-237">모든 어셈블리를 IISADMIN 서비스에 대해 도메인 중립적으로 로드되지 않게 하려면 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN 키에서 Environment의 다중 문자열 값에 `COMPLUS_LoaderOptimization=1`을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b5a2b-237">To force all assemblies not to be loaded as domain-neutral for the IISADMIN service can be achieved by appending `COMPLUS_LoaderOptimization=1` to the Environment’s Multi-String Value in the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN key.</span></span>  
  
```  
Key = HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN  
Name = Environment  
Type = REG_MULTI_SZ  
Value (to append) = COMPLUS_LoaderOptimization=1  
```  
  
<a name="reference"></a>   
## <a name="reference"></a><span data-ttu-id="b5a2b-238">참조</span><span class="sxs-lookup"><span data-stu-id="b5a2b-238">Reference</span></span>  
 <xref:System.MarshalByRefObject?displayProperty=nameWithType>

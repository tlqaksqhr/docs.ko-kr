---
title: "응용 프로그램 추적 및 조율"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tracing [.NET Framework]
- debugging [.NET Framework], instrumentation
- performance monitoring, instrumentation
- instrumentation, about instrumentation
- tracing [.NET Framework], about tracing
- performance monitoring, tracing code
- Trace class, instrumentation for .NET applications
ms.assetid: 773b6fc4-9013-4322-b728-5dec7a72e743
caps.latest.revision: "21"
author: mairaw
ms.author: mairaw
manager: wpickett
ms.openlocfilehash: 932fef22681aeb2a68d7852884127155757e4099
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="tracing-and-instrumenting-applications"></a><span data-ttu-id="f5ac1-102">응용 프로그램 추적 및 조율</span><span class="sxs-lookup"><span data-stu-id="f5ac1-102">Tracing and Instrumenting Applications</span></span>
<span data-ttu-id="f5ac1-103">추적은 실행되는 동안 응용 프로그램의 실행을 모니터링할 수 있는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-103">Tracing is a way for you to monitor the execution of your application while it is running.</span></span> <span data-ttu-id="f5ac1-104">개발할 때 .NET Framework 응용 프로그램에 추적 및 디버깅 계측을 추가할 수 있으며, 응용 프로그램을 개발하는 동안 및 배포한 후에 해당 계측을 모두 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-104">You can add tracing and debugging instrumentation to your .NET Framework application when you develop it, and you can use that instrumentation both while you are developing the application and after you have deployed it.</span></span> <span data-ttu-id="f5ac1-105"><xref:System.Diagnostics.Trace?displayProperty=nameWithType>, <xref:System.Diagnostics.Debug?displayProperty=nameWithType> 및 <xref:System.Diagnostics.TraceSource?displayProperty=nameWithType> 클래스를 사용하여 나중에 분석할 수 있도록 오류 및 응용 프로그램 실행 정보를 로그, 텍스트 파일 또는 다른 장치에 기록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-105">You can use the <xref:System.Diagnostics.Trace?displayProperty=nameWithType>, <xref:System.Diagnostics.Debug?displayProperty=nameWithType>, and <xref:System.Diagnostics.TraceSource?displayProperty=nameWithType> classes to record information about errors and application execution in logs, text files, or other devices for later analysis.</span></span>  
  
 <span data-ttu-id="f5ac1-106">*계측*이란 용어는 제품의 성능 수준을 모니터링하거나 측정하고 오류를 진단하는 기능을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-106">The term *instrumentation* refers to an ability to monitor or measure the level of a product's performance and to diagnose errors.</span></span> <span data-ttu-id="f5ac1-107">프로그래밍에서 이 용어는 다음을 통합하는 응용 프로그램 기능을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-107">In programming, this means the ability of an application to incorporate:</span></span>  
  
-   <span data-ttu-id="f5ac1-108">**코드 추적** - 런타임에 응용 프로그램의 실행에 대한 정보 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-108">**Code tracing** - Receiving informative messages about the execution of an application at run time.</span></span>  
  
-   <span data-ttu-id="f5ac1-109">**디버깅** - 개발 중인 응용 프로그램에서 프로그래밍 오류를 추적하고 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-109">**Debugging** - Tracking down and fixing programming errors in an application under development.</span></span> <span data-ttu-id="f5ac1-110">자세한 내용은 [디버깅](/visualstudio/debugger/debugging-in-visual-studio)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-110">For more information, see [Debugging](/visualstudio/debugger/debugging-in-visual-studio).</span></span>  
  
-   <span data-ttu-id="f5ac1-111">**성능 카운터** - 응용 프로그램의 성능을 추적할 수 있게 해주는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-111">**Performance counters** - Components that allow you to track the performance of your application.</span></span> <span data-ttu-id="f5ac1-112">자세한 내용은 [성능 카운터](../../../docs/framework/debug-trace-profile/performance-counters.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-112">For more information, see [Performance Counters](../../../docs/framework/debug-trace-profile/performance-counters.md).</span></span>  
  
-   <span data-ttu-id="f5ac1-113">**이벤트 로그** - 응용 프로그램의 실행에서 주요 이벤트를 수신하고 추적할 수 있게 해주는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-113">**Event logs** - Components that allow you receive and track major events in the execution of your application.</span></span> <span data-ttu-id="f5ac1-114">자세한 내용은 <xref:System.Diagnostics.EventLog> 클래스를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-114">For more information, see the <xref:System.Diagnostics.EventLog> class.</span></span>  
  
 <span data-ttu-id="f5ac1-115">분산 응용 프로그램에서는 코드의 전략적 위치에 trace 문을 배치하여 응용 프로그램을 계측하는 것이 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-115">Instrumenting your application by placing trace statements at strategic locations in your code is especially useful for distributed applications.</span></span> <span data-ttu-id="f5ac1-116">trace 문을 통해 응용 프로그램을 계측하여 문제가 발생할 때 정보를 표시하는 것은 물론 응용 프로그램의 성능을 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-116">By using trace statements you can instrument an application not only to display information when things go wrong, but also to monitor how well the application is performing.</span></span>  
  
 <span data-ttu-id="f5ac1-117"><xref:System.Diagnostics.TraceSource> 클래스는 향상된 추적 기능을 제공하며, 이전 <xref:System.Diagnostics.Trace> 및 <xref:System.Diagnostics.Debug> 추적 클래스의 정적 메서드 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-117">The <xref:System.Diagnostics.TraceSource> class provides enhanced tracing features and can be used in place of the static methods of the older <xref:System.Diagnostics.Trace> and <xref:System.Diagnostics.Debug> tracing classes.</span></span> <span data-ttu-id="f5ac1-118">익숙한 <xref:System.Diagnostics.Trace> 및 <xref:System.Diagnostics.Debug> 클래스가 여전히 널리 사용되지만 <xref:System.Diagnostics.TraceSource.TraceEvent%2A> 및 <xref:System.Diagnostics.TraceSource.TraceData%2A>와 같은 새 추적 명령에는 <xref:System.Diagnostics.TraceSource> 클래스를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-118">The familiar <xref:System.Diagnostics.Trace> and <xref:System.Diagnostics.Debug> classes are still widely used, but the <xref:System.Diagnostics.TraceSource> class is recommended for new tracing commands, such as <xref:System.Diagnostics.TraceSource.TraceEvent%2A> and <xref:System.Diagnostics.TraceSource.TraceData%2A>.</span></span>  
  
 <span data-ttu-id="f5ac1-119"><xref:System.Diagnostics.Trace> 및 <xref:System.Diagnostics.Debug> 클래스는 <xref:System.Diagnostics.Debug> 클래스와 달리 <xref:System.Diagnostics.Trace> 클래스의 해당 프로시저와 함수가 기본적으로 릴리스 빌드로 컴파일된다는 점을 제외하고 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-119">The <xref:System.Diagnostics.Trace> and <xref:System.Diagnostics.Debug> classes are identical, except that procedures and functions of the <xref:System.Diagnostics.Trace> class are compiled by default into release builds, but those of the <xref:System.Diagnostics.Debug> class are not.</span></span>  
  
 <span data-ttu-id="f5ac1-120"><xref:System.Diagnostics.Trace> 및 <xref:System.Diagnostics.Debug> 클래스는 개발 중이나 배포 후에 응용 프로그램 성능을 모니터링하고 검사할 수 있는 수단을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-120">The <xref:System.Diagnostics.Trace> and <xref:System.Diagnostics.Debug> classes provide the means to monitor and examine application performance either during development or after deployment.</span></span> <span data-ttu-id="f5ac1-121">예를 들어, 배포된 응용 프로그램에서 특정 동작 유형(예: 새 데이터베이스 연결 만들기)이 발생할 때 <xref:System.Diagnostics.Trace> 클래스를 사용하여 해당 동작을 추적할 수 있으므로 응용 프로그램의 효율성을 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-121">For example, you can use the <xref:System.Diagnostics.Trace> class to track particular types of actions in a deployed application as they occur (for example, creation of new database connections), and can therefore monitor the application's efficiency.</span></span>  
  
## <a name="code-tracing-and-debugging"></a><span data-ttu-id="f5ac1-122">코드 추적 및 디버깅</span><span class="sxs-lookup"><span data-stu-id="f5ac1-122">Code Tracing and Debugging</span></span>  
 <span data-ttu-id="f5ac1-123">개발하는 동안 <xref:System.Diagnostics.Debug> 클래스의 출력 메서드를 사용하여 Visual Studio IDE(통합 개발 환경)의 출력 창에 메시지를 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-123">During development, you can use the output methods of the <xref:System.Diagnostics.Debug> class to display messages in the Output window of the Visual Studio integrated development environment (IDE).</span></span> <span data-ttu-id="f5ac1-124">예:</span><span class="sxs-lookup"><span data-stu-id="f5ac1-124">For example:</span></span>  
  
```vb  
Trace.WriteLine("Hello World!")  
Debug.WriteLine("Hello World!")  
```  
  
```csharp  
System.Diagnostics.Trace.WriteLine("Hello World!");  
System.Diagnostics.Debug.WriteLine("Hello World!");  
```  
  
 <span data-ttu-id="f5ac1-125">각 예제에서 응용 프로그램을 디버거에서 실행하는 경우 “Hello World!”가</span><span class="sxs-lookup"><span data-stu-id="f5ac1-125">Each of these examples will display "Hello World!"</span></span> <span data-ttu-id="f5ac1-126">출력 창에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-126">in the Output window when the application is run in the debugger.</span></span>  
  
 <span data-ttu-id="f5ac1-127">이 경우 응용 프로그램을 디버그하고 테스트 환경에서의 해당 동작에 따라 성능을 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-127">This enables you to debug your applications and optimize their performance based on their behavior in your test environment.</span></span> <span data-ttu-id="f5ac1-128">모든 디버깅 출력을 받을 수 있도록 <xref:System.Diagnostics.Debug> 조건부 특성을 설정한 상태로 디버그 빌드에서 응용 프로그램을 디버깅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-128">You can debug your application in your debug build with the <xref:System.Diagnostics.Debug> conditional attribute turned on so that you receive all debugging output.</span></span> <span data-ttu-id="f5ac1-129">응용 프로그램을 릴리스할 준비가 된 경우, <xref:System.Diagnostics.Debug> 조건부 특성을 설정하지 않고 릴리스 빌드를 컴파일하면 컴파일러가 디버깅 코드를 최종 실행 파일에 포함시키지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-129">When your application is ready for release, you can compile your release build without turning on the <xref:System.Diagnostics.Debug> conditional attribute, so that the compiler will not include your debugging code in the final executable.</span></span> <span data-ttu-id="f5ac1-130">자세한 내용은 [방법: 추적 및 디버그를 사용한 조건부 컴파일](../../../docs/framework/debug-trace-profile/how-to-compile-conditionally-with-trace-and-debug.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-130">For more information, see [How to: Compile Conditionally with Trace and Debug](../../../docs/framework/debug-trace-profile/how-to-compile-conditionally-with-trace-and-debug.md).</span></span> <span data-ttu-id="f5ac1-131">응용 프로그램의 다양한 빌드 구성에 대한 자세한 내용은 [컴파일 및 빌드](/visualstudio/ide/compiling-and-building-in-visual-studio)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-131">For more information on different build configurations for your application, see [Compiling and Building](/visualstudio/ide/compiling-and-building-in-visual-studio).</span></span>  
  
 <span data-ttu-id="f5ac1-132">또한 <xref:System.Diagnostics.Trace> 클래스의 메서드를 사용하여 설치된 응용 프로그램에서 코드 실행을 추적할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-132">You can also trace code execution in an installed application, using methods of the <xref:System.Diagnostics.Trace> class.</span></span> <span data-ttu-id="f5ac1-133">코드에 [추적 스위치](../../../docs/framework/debug-trace-profile/trace-switches.md)를 배치하면 추적 발생 여부와 추적 범위를 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-133">By placing [Trace Switches](../../../docs/framework/debug-trace-profile/trace-switches.md) in your code, you can control whether tracing occurs and how extensive it is.</span></span> <span data-ttu-id="f5ac1-134">이 경우 프로덕션 환경에서 응용 프로그램의 상태를 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-134">This lets you monitor the status of your application in a production environment.</span></span> <span data-ttu-id="f5ac1-135">이 기능은 여러 컴퓨터에서 실행되는 여러 구성 요소를 사용하는 비즈니스 응용 프로그램에서 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-135">This is especially important in a business application that uses multiple components running on multiple computers.</span></span> <span data-ttu-id="f5ac1-136">배포 후 구성 파일을 통해 스위치를 사용하는 방법을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-136">You can control how the switches are used after deployment through the configuration file.</span></span> <span data-ttu-id="f5ac1-137">자세한 내용은 [방법: 추적 스위치 만들기, 초기화 및 구성](../../../docs/framework/debug-trace-profile/how-to-create-initialize-and-configure-trace-switches.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-137">For more information, see [How to: Create, Initialize and Configure Trace Switches](../../../docs/framework/debug-trace-profile/how-to-create-initialize-and-configure-trace-switches.md).</span></span>  
  
 <span data-ttu-id="f5ac1-138">추적을 사용하려는 응용 프로그램을 개발하는 경우 일반적으로 추적 및 디버깅 메시지 둘 다를 응용 프로그램 코드에 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-138">When you are developing an application for which you intend to use tracing, you usually include both tracing and debugging messages in the application code.</span></span> <span data-ttu-id="f5ac1-139">응용 프로그램을 배포할 준비가 되면 **디버그** 조건부 특성을 설정하지 않고 릴리스 빌드를 컴파일할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-139">When you are ready to deploy the application, you can compile your release build without turning on the **Debug** conditional attribute.</span></span> <span data-ttu-id="f5ac1-140">그러나 컴파일러가 실행 파일에 추적 코드를 포함하도록 **추적** 조건부 특성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-140">However, you can turn on the **Trace** conditional attribute so that the compiler includes your trace code in the executable.</span></span> <span data-ttu-id="f5ac1-141">자세한 내용은 [방법: 추적 및 디버그를 사용한 조건부 컴파일](../../../docs/framework/debug-trace-profile/how-to-compile-conditionally-with-trace-and-debug.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-141">For more information, see [How to: Compile Conditionally with Trace and Debug](../../../docs/framework/debug-trace-profile/how-to-compile-conditionally-with-trace-and-debug.md).</span></span>  
  
### <a name="phases-of-code-tracing"></a><span data-ttu-id="f5ac1-142">코드 추적 단계</span><span class="sxs-lookup"><span data-stu-id="f5ac1-142">Phases of Code Tracing</span></span>  
 <span data-ttu-id="f5ac1-143">코드 추적에는 다음 세 단계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-143">There are three phases of code tracing:</span></span>  
  
1.  <span data-ttu-id="f5ac1-144">**계측** - 응용 프로그램에 추적 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-144">**Instrumentation** — you add trace code to your application.</span></span>  
  
2.  <span data-ttu-id="f5ac1-145">**추적** - 추적 코드가 지정된 대상에 정보를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-145">**Tracing** — the tracing code writes information to the specified target.</span></span>  
  
3.  <span data-ttu-id="f5ac1-146">**분석** - 추적 정보를 평가하여 응용 프로그램의 문제를 식별하고 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-146">**Analysis** — you evaluate the tracing information to identify and understand problems in the application.</span></span>  
  
 <span data-ttu-id="f5ac1-147">개발 중에 모든 디버그 및 추적 출력 메서드는 기본적으로 Visual Studio의 출력 창에 정보를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-147">During development, all debug and trace output methods write information to the Output window in Visual Studio by default.</span></span> <span data-ttu-id="f5ac1-148">배포된 응용 프로그램에서 메서드는 지정된 대상에 추적 정보를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-148">In a deployed application, the methods write tracing information to the targets you specify.</span></span> <span data-ttu-id="f5ac1-149">추적 또는 디버깅의 출력 대상을 지정하는 방법에 대한 자세한 내용은 [추적 수신기](../../../docs/framework/debug-trace-profile/trace-listeners.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-149">For more information on specifying an output target for tracing or debugging, see [Trace Listeners](../../../docs/framework/debug-trace-profile/trace-listeners.md).</span></span>  
  
 <span data-ttu-id="f5ac1-150">다음은 추적을 사용하여 배포 된 응용 프로그램의 잠재적 문제를 분석 및 해결하는 작업과 일반적으로 관련된 주요 단계를 전체적으로 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-150">The following is an overall view of the major steps typically involved in using tracing to analyze and correct potential problems in deployed applications.</span></span> <span data-ttu-id="f5ac1-151">이러한 단계를 수행하는 방법에 대한 자세한 내용은 해당 링크를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-151">For more information on how to perform these steps, see the appropriate link.</span></span>  
  
##### <a name="to-use-tracing-in-an-application"></a><span data-ttu-id="f5ac1-152">응용 프로그램에서 추적을 사용하려면</span><span class="sxs-lookup"><span data-stu-id="f5ac1-152">To use tracing in an application</span></span>  
  
1.  <span data-ttu-id="f5ac1-153">응용 프로그램을 배포한 후 온사이트에서 수신할 추적 출력을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-153">Consider which tracing output you will want to receive onsite after you have deployed the application.</span></span>  
  
2.  <span data-ttu-id="f5ac1-154">스위치 집합을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-154">Create a set of switches.</span></span> <span data-ttu-id="f5ac1-155">자세한 내용은 [방법: 추적 스위치 구성](../../../docs/framework/debug-trace-profile/how-to-create-initialize-and-configure-trace-switches.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-155">For more information, see [How to: Configure Trace Switches](../../../docs/framework/debug-trace-profile/how-to-create-initialize-and-configure-trace-switches.md).</span></span>  
  
3.  <span data-ttu-id="f5ac1-156">응용 프로그램 코드에 trace 문을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-156">Add the trace statements to the application code.</span></span>  
  
4.  <span data-ttu-id="f5ac1-157">추적 출력을 표시할 위치를 결정하고 적절한 수신기를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-157">Determine where you want the tracing output to appear and add the appropriate listeners.</span></span> <span data-ttu-id="f5ac1-158">자세한 내용은 [추적 수신기 만들기 및 초기화](../../../docs/framework/debug-trace-profile/how-to-create-and-initialize-trace-listeners.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-158">For more information, see [Creating and Initializing Trace Listeners](../../../docs/framework/debug-trace-profile/how-to-create-and-initialize-trace-listeners.md).</span></span>  
  
5.  <span data-ttu-id="f5ac1-159">응용 프로그램 및 응용 프로그램에 포함된 추적 코드를 테스트 및 디버그합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-159">Test and debug your application and the tracing code it contains.</span></span>  
  
6.  <span data-ttu-id="f5ac1-160">다음 절차 중 하나를 사용하여 응용 프로그램을 실행 코드로 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-160">Compile the application into executable code using one of the following procedures:</span></span>  
  
    -   <span data-ttu-id="f5ac1-161">**솔루션 탐색기**에서 **속성 페이지** 대화 상자의 **디버그** 페이지와 함께 **빌드** 메뉴를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-161">Use the **Build** menu along with the **Debug** page of the **Property Pages** dialog box in **Solution Explorer**.</span></span> <span data-ttu-id="f5ac1-162">이 절차는 Visual Studio에서 컴파일할 때 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-162">Use this when compiling in Visual Studio.</span></span>  
  
         <span data-ttu-id="f5ac1-163">\- 또는 -</span><span class="sxs-lookup"><span data-stu-id="f5ac1-163">\- or -</span></span>  
  
    -   <span data-ttu-id="f5ac1-164">컴파일의 명령줄 메서드에 대한 **추적** 및 **디버그** 컴파일러 지시문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-164">Use the **Trace** and **Debug** compiler directives for the command-line method of compiling.</span></span> <span data-ttu-id="f5ac1-165">자세한 내용은 [추적 및 디버그를 사용한 조건부 컴파일](../../../docs/framework/debug-trace-profile/how-to-compile-conditionally-with-trace-and-debug.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-165">For more information, see [Compiling Conditionally with Trace and Debug](../../../docs/framework/debug-trace-profile/how-to-compile-conditionally-with-trace-and-debug.md).</span></span> <span data-ttu-id="f5ac1-166">이 절차는 명령줄에서 컴파일할 때 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-166">Use this when compiling from the command line.</span></span>  
  
7.  <span data-ttu-id="f5ac1-167">런타임 중에 문제가 발생하는 경우 적절한 추적 스위치를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-167">If a problem occurs during run time, turn on the appropriate trace switch.</span></span> <span data-ttu-id="f5ac1-168">자세한 내용은 [추적 스위치 구성](../../../docs/framework/debug-trace-profile/how-to-create-initialize-and-configure-trace-switches.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-168">For more information, see [Configuring Trace Switches](../../../docs/framework/debug-trace-profile/how-to-create-initialize-and-configure-trace-switches.md).</span></span>  
  
     <span data-ttu-id="f5ac1-169">추적 코드는 지정된 대상(예: 화면, 텍스트 파일 또는 이벤트 로그)에 추적 메시지를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-169">The tracing code writes tracing messages to a specified target, for example, a screen, a text file, or an event log.</span></span> <span data-ttu-id="f5ac1-170">**Trace.Listeners** 컬렉션에 포함된 수신기의 형식에 따라 대상이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-170">The type of listener you included in the **Trace.Listeners** collection determines the target.</span></span>  
  
8.  <span data-ttu-id="f5ac1-171">추적 메시지를 분석하여 응용 프로그램의 문제를 식별하고 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-171">Analyze the tracing messages to identify and understand the problem in the application.</span></span>  
  
## <a name="trace-instrumentation-and-distributed-applications"></a><span data-ttu-id="f5ac1-172">추적 계측 및 분산 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="f5ac1-172">Trace Instrumentation and Distributed Applications</span></span>  
 <span data-ttu-id="f5ac1-173">분산 응용 프로그램을 만드는 경우 사용되는 방식으로 응용 프로그램을 테스트하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-173">When you create a distributed application, you might find it difficult to test the application in the manner in which it will be used.</span></span> <span data-ttu-id="f5ac1-174">운영 체제나 웹 브라우저의 가능한 모든 조합(모든 지역화된 언어 옵션 포함)을 테스트하거나 동시에 응용 프로그램에 액세스하는 다수의 사용자를 시뮬레이션할 수 있는 개발 팀은 거의 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-174">Few development teams have the capability to test all possible combinations of operating systems or Web browsers (including all the localized language options), or to simulate the high number of users that will access the application at the same time.</span></span> <span data-ttu-id="f5ac1-175">이러한 상황에서는 분산 응용 프로그램이 높은 볼륨, 다양한 설정 및 고유한 최종 사용자 동작에 응답하는 방식을 테스트할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-175">Under these circumstances, you cannot test how a distributed application will respond to high volumes, different setups, and unique end-user behaviors.</span></span> <span data-ttu-id="f5ac1-176">또한 분산 응용 프로그램의 많은 부분에는 이러한 부분과 직접 상호 작용하거나 해당 활동을 볼 수 있는 사용자 인터페이스가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-176">Also, many parts of a distributed application have no user interface with which you can interact directly or view the activity of those parts.</span></span>  
  
 <span data-ttu-id="f5ac1-177">그러나 응용 프로그램을 *계측*(즉, 코드의 전략적 위치에 trace 문 배치)하여 분산 응용 프로그램이 특히 발생한 문제와 같은 특정 이벤트를 시스템 관리자에게 설명할 수 있게 하면 이 기능을 보완할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-177">However, you can compensate for this by enabling distributed applications to describe certain events of interest to system administrators, especially things that go wrong, by *instrumenting* the application — that is, by placing trace statements at strategic locations in your code.</span></span> <span data-ttu-id="f5ac1-178">그러면 런타임에 예기치 않은 문제가 발생할 경우(예: 과도하게 느린 응답 시간) 가능성이 높은 원인을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-178">Then if something unexpected occurs at run time (for example, excessively slow response time), you can determine the likely cause.</span></span>  
  
 <span data-ttu-id="f5ac1-179">trace 문을 통해 원래 소스 코드를 검사, 수정 및 다시 컴파일하고 디버깅 환경 내에서 런타임 오류 생성을 시도하는 어려운 작업을 피할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-179">With trace statements you can avoid the difficult task of examining the original source code, modifying it, recompiling, and attempting to produce the run-time error within the debugging environment.</span></span> <span data-ttu-id="f5ac1-180">응용 프로그램을 계측하여 오류를 표시하는 것은 물론 성능을 모니터링할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-180">Remember that you can instrument an application not only to display errors, but also to monitor performance.</span></span>  
  
## <a name="strategic-placement-of-trace-statements"></a><span data-ttu-id="f5ac1-181">Trace 문의 전략적 배치</span><span class="sxs-lookup"><span data-stu-id="f5ac1-181">Strategic Placement of Trace Statements</span></span>  
 <span data-ttu-id="f5ac1-182">런타임 중에 사용하기 위해 trace 문을 배치할 때는 특별히 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-182">You must exercise special care when placing your trace statements for use during run time.</span></span> <span data-ttu-id="f5ac1-183">가능한 모든 추적 시나리오가 적절하게 처리되도록 배포된 응용 프로그램에서 필요할 가능성이 큰 추적 정보를 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-183">You must consider what tracing information is likely to be needed in a deployed application, so that all likely tracing scenarios are adequately covered.</span></span> <span data-ttu-id="f5ac1-184">그러나 추적을 사용하는 응용 프로그램은 매우 광범위하기 대문에 추적의 전략적 배치에 대한 일반적인 지침은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-184">Because applications that use tracing vary widely, however, there are no general guidelines for strategic placement of tracing.</span></span> <span data-ttu-id="f5ac1-185">trace 문 배치에 대한 자세한 내용은 [방법: 응용 프로그램 코드에 Trace 문 추가](../../../docs/framework/debug-trace-profile/how-to-add-trace-statements-to-application-code.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-185">For more information on placing trace statements, see [How to: Add Trace Statements to Application Code](../../../docs/framework/debug-trace-profile/how-to-add-trace-statements-to-application-code.md).</span></span>  
  
## <a name="output-from-tracing"></a><span data-ttu-id="f5ac1-186">추적 출력</span><span class="sxs-lookup"><span data-stu-id="f5ac1-186">Output from Tracing</span></span>  
 <span data-ttu-id="f5ac1-187">추적 출력은 *수신기*라는 개체에 의해 수집됩니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-187">Trace output is collected by objects called *listeners*.</span></span> <span data-ttu-id="f5ac1-188">수신기는 추적 출력을 받아 출력 장치(일반적으로 창, 로그 또는 텍스트 파일)에 쓰는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-188">A listener is an object that receives trace output and writes it to an output device (usually a window, log, or text file).</span></span> <span data-ttu-id="f5ac1-189">새로 만든 추적 수신기는 일반적으로 <xref:System.Diagnostics.Trace.Listeners%2A?displayProperty=nameWithType> 컬렉션에 추가되므로 수신기가 모든 추적 출력을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-189">When a trace listener is created, it is typically added to the <xref:System.Diagnostics.Trace.Listeners%2A?displayProperty=nameWithType> collection, allowing the listener to receive all trace output.</span></span>  
  
 <span data-ttu-id="f5ac1-190">추적 정보는 최소한 기본 <xref:System.Diagnostics.Trace> 출력 대상인 <xref:System.Diagnostics.DefaultTraceListener>에는 항상 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-190">Tracing information is always written at least to the default <xref:System.Diagnostics.Trace> output target, the <xref:System.Diagnostics.DefaultTraceListener>.</span></span> <span data-ttu-id="f5ac1-191">어떤 이유로든 다른 수신기를 <xref:System.Diagnostics.DefaultTraceListener> 컬렉션에 추가하지 않고 <xref:System.Diagnostics.Trace.Listeners%2A>를 삭제한 경우에는 추적 메시지를 받지 못하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-191">If for some reason you have deleted the <xref:System.Diagnostics.DefaultTraceListener> without adding any other listeners to the <xref:System.Diagnostics.Trace.Listeners%2A> collection, you will not receive any tracing messages.</span></span> <span data-ttu-id="f5ac1-192">자세한 내용은 [추적 수신기](../../../docs/framework/debug-trace-profile/trace-listeners.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-192">For more information, see [Trace Listeners](../../../docs/framework/debug-trace-profile/trace-listeners.md).</span></span>  
  
 <span data-ttu-id="f5ac1-193">추적 정보를 기록하는 여섯 가지 <xref:System.Diagnostics.Debug> 멤버 및 <xref:System.Diagnostics.Trace> 메서드는 다음 표에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-193">The six <xref:System.Diagnostics.Debug> members and <xref:System.Diagnostics.Trace> methods that write tracing information are listed in the following table.</span></span>  
  
|<span data-ttu-id="f5ac1-194">메서드</span><span class="sxs-lookup"><span data-stu-id="f5ac1-194">Method</span></span>|<span data-ttu-id="f5ac1-195">출력</span><span class="sxs-lookup"><span data-stu-id="f5ac1-195">Output</span></span>|  
|------------|------------|  
|<span data-ttu-id="f5ac1-196">**Assert**</span><span class="sxs-lookup"><span data-stu-id="f5ac1-196">**Assert**</span></span>|<span data-ttu-id="f5ac1-197">지정된 텍스트 또는 지정되지 않은 경우 호출 스택입니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-197">The specified text; or, if none is specified, the Call Stack.</span></span> <span data-ttu-id="f5ac1-198">**Assert** 문에서 인수로 지정된 조건이 **false**인 경우에만 출력이 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-198">The output is written only if the condition specified as an argument in the **Assert** statement is **false**.</span></span>|  
|<span data-ttu-id="f5ac1-199">**Fail**</span><span class="sxs-lookup"><span data-stu-id="f5ac1-199">**Fail**</span></span>|<span data-ttu-id="f5ac1-200">지정된 텍스트 또는 지정되지 않은 경우 호출 스택입니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-200">The specified text; or, if none is specified, the Call Stack.</span></span>|  
|<span data-ttu-id="f5ac1-201">**Write**</span><span class="sxs-lookup"><span data-stu-id="f5ac1-201">**Write**</span></span>|<span data-ttu-id="f5ac1-202">지정된 텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-202">The specified text.</span></span>|  
|<span data-ttu-id="f5ac1-203">**WriteIf**</span><span class="sxs-lookup"><span data-stu-id="f5ac1-203">**WriteIf**</span></span>|<span data-ttu-id="f5ac1-204">**WriteIf** 문에서 인수로 지정된 조건이 충족되는 경우 지정된 텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-204">The specified text, if the condition specified as an argument in the **WriteIf** statement is satisfied.</span></span>|  
|<span data-ttu-id="f5ac1-205">**WriteLine**</span><span class="sxs-lookup"><span data-stu-id="f5ac1-205">**WriteLine**</span></span>|<span data-ttu-id="f5ac1-206">지정된 텍스트와 캐리지 리턴입니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-206">The specified text and a carriage return.</span></span>|  
|<span data-ttu-id="f5ac1-207">**WriteLineIf**</span><span class="sxs-lookup"><span data-stu-id="f5ac1-207">**WriteLineIf**</span></span>|<span data-ttu-id="f5ac1-208">**WriteLineIf** 문에서 인수로 지정된 조건이 충족되는 경우 지정된 텍스트와 캐리지 리턴입니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-208">The specified text and a carriage return, if the condition specified as an argument in the **WriteLineIf** statement is satisfied.</span></span>|  
  
 <span data-ttu-id="f5ac1-209"><xref:System.Diagnostics.Trace.Listeners%2A> 컬렉션의 모든 수신기는 위 표에 설명된 메시지를 받지만 메시지를 받는 수신기의 종류에 따라 다른 동작이 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-209">All listeners in the <xref:System.Diagnostics.Trace.Listeners%2A> collection receive the messages described in the above table, but the actions taken may vary depending on what kind of listener receives the message.</span></span> <span data-ttu-id="f5ac1-210">예를 들어 <xref:System.Diagnostics.DefaultTraceListener>는 **Fail** 또는 **Assert** 오류 알림을 받을 경우 어설션 대화 상자를 표시하지만 <xref:System.Diagnostics.TextWriterTraceListener>는 출력을 해당 스트림에 쓰기만 합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-210">For example, the <xref:System.Diagnostics.DefaultTraceListener> displays an assertion dialog box when it receives a **Fail** or failed **Assert** notification, but a <xref:System.Diagnostics.TextWriterTraceListener> simply writes the output to its stream.</span></span>  
  
 <span data-ttu-id="f5ac1-211">고유한 수신기를 구현하여 사용자 지정 결과를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-211">You can produce custom results by implementing your own listener.</span></span> <span data-ttu-id="f5ac1-212">예를 들어 사용자 지정 추적 수신기는 메시지 상자에 메시지를 표시하거나 데이터베이스에 연결하여 테이블에 메시지를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-212">A custom trace listener might, for example, display the messages to a message box, or connect to a database to add messages to a table.</span></span> <span data-ttu-id="f5ac1-213">모든 사용자 지정 수신기는 위에서 언급한 6가지 메서드를 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-213">All custom listeners should support the six methods mentioned above.</span></span> <span data-ttu-id="f5ac1-214">개발자 정의 수신기를 만드는 방법에 대한 자세한 내용은 .NET Framework 참조에서 <xref:System.Diagnostics.TraceListener>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-214">For more information on creating developer-defined listeners, see <xref:System.Diagnostics.TraceListener> in the .NET Framework reference.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f5ac1-215">[!INCLUDE[vbprvblong](../../../includes/vbprvblong-md.md)]에서는 **Debug.Write**, **Debug.WriteIf**, **Debug.WriteLine** 및 **Debug.WriteLineIf** 메서드가 이전 버전의 Visual Basic에서 사용할 수 있었던 **Debug.Print** 메서드를 대체했습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-215">In [!INCLUDE[vbprvblong](../../../includes/vbprvblong-md.md)], the **Debug.Write**, **Debug.WriteIf**, **Debug.WriteLine**, and **Debug.WriteLineIf** methods have replaced the **Debug.Print** method that was available in earlier versions of Visual Basic.</span></span>  
  
 <span data-ttu-id="f5ac1-216">**Write** 및 **WriteLine** 메서드는 항상 지정된 텍스트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-216">The **Write** and **WriteLine** methods always write the text that you specify.</span></span> <span data-ttu-id="f5ac1-217">**Assert**, **WriteIf** 및 **WriteLineIf**에는 지정된 텍스트를 쓸지 여부를 제어하는 부울 인수를 사용해야 합니다. 이들 메서드는 식이 **true**(**WriteIf** 및 **WriteLineIf**) 또는 **false**(**Assert**)인 경우에만 지정된 텍스트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-217">**Assert**, **WriteIf**, and **WriteLineIf** require a Boolean argument that controls whether or not they write the specified text; they write the specified text only if the expression is **true** (for **WriteIf** and **WriteLineIf**), or **false** (for **Assert**).</span></span> <span data-ttu-id="f5ac1-218">**Fail** 메서드는 항상 지정된 텍스트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-218">The **Fail** method always writes the specified text.</span></span> <span data-ttu-id="f5ac1-219">자세한 내용은 [방법: 응용 프로그램 코드에 Trace 문 추가](../../../docs/framework/debug-trace-profile/how-to-add-trace-statements-to-application-code.md) 및 .NET Framework 참조를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-219">For more information, see [How to: Add Trace Statements to Application Code](../../../docs/framework/debug-trace-profile/how-to-add-trace-statements-to-application-code.md) and the .NET Framework reference.</span></span>  
  
## <a name="security-concerns"></a><span data-ttu-id="f5ac1-220">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="f5ac1-220">Security Concerns</span></span>  
 <span data-ttu-id="f5ac1-221">ASP.NET 응용 프로그램을 배포하기 전에 추적 및 디버깅을 사용하지 않도록 설정하지 않으면 응용 프로그램이 해당 정보를 노출하여 악성 프로그램에서 악용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-221">If you do not disable tracing and debugging before deploying an ASP.NET application, your application may reveal information about itself that could be exploited by a malicious program.</span></span> <span data-ttu-id="f5ac1-222">자세한 내용은 [방법: 추적 및 디버그를 사용한 조건부 컴파일](../../../docs/framework/debug-trace-profile/how-to-compile-conditionally-with-trace-and-debug.md), [컴파일 및 빌드](/visualstudio/ide/compiling-and-building-in-visual-studio) 및 [방법: 추적 스위치 만들기, 초기화 및 구성](../../../docs/framework/debug-trace-profile/how-to-create-initialize-and-configure-trace-switches.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-222">For more information, see [How to: Compile Conditionally with Trace and Debug](../../../docs/framework/debug-trace-profile/how-to-compile-conditionally-with-trace-and-debug.md), [Compiling and Building](/visualstudio/ide/compiling-and-building-in-visual-studio), and [How to: Create, Initialize and Configure Trace Switches](../../../docs/framework/debug-trace-profile/how-to-create-initialize-and-configure-trace-switches.md).</span></span> <span data-ttu-id="f5ac1-223">IIS(인터넷 정보 서비스)를 통해 디버깅을 구성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f5ac1-223">Debugging is also configurable through Internet Information Services (IIS).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f5ac1-224">참고 항목</span><span class="sxs-lookup"><span data-stu-id="f5ac1-224">See Also</span></span>  
 <xref:System.Diagnostics.Trace>  
 <xref:System.Diagnostics.TraceSource>  
 [<span data-ttu-id="f5ac1-225">코드 계약</span><span class="sxs-lookup"><span data-stu-id="f5ac1-225">Code Contracts</span></span>](../../../docs/framework/debug-trace-profile/code-contracts.md)  
 <span data-ttu-id="f5ac1-226">[C#, F#, and Visual Basic Project Types](/visualstudio/debugger/debugging-preparation-csharp-f-hash-and-visual-basic-project-types)(C#, F# 및 Visual Basic 프로젝트 형식)</span><span class="sxs-lookup"><span data-stu-id="f5ac1-226">[C#, F#, and Visual Basic Project Types](/visualstudio/debugger/debugging-preparation-csharp-f-hash-and-visual-basic-project-types)</span></span>  
 [<span data-ttu-id="f5ac1-227">방법: 응용 프로그램 코드에 Trace 문 추가</span><span class="sxs-lookup"><span data-stu-id="f5ac1-227">How to: Add Trace Statements to Application Code</span></span>](../../../docs/framework/debug-trace-profile/how-to-add-trace-statements-to-application-code.md)  
 [<span data-ttu-id="f5ac1-228">방법: 추적 및 디버그를 사용한 조건부 컴파일</span><span class="sxs-lookup"><span data-stu-id="f5ac1-228">How to: Compile Conditionally with Trace and Debug</span></span>](../../../docs/framework/debug-trace-profile/how-to-compile-conditionally-with-trace-and-debug.md)  
 [<span data-ttu-id="f5ac1-229">방법: 만들기, 초기화 및 추적 스위치 구성</span><span class="sxs-lookup"><span data-stu-id="f5ac1-229">How to: Create, Initialize and Configure Trace Switches</span></span>](../../../docs/framework/debug-trace-profile/how-to-create-initialize-and-configure-trace-switches.md)  
 [<span data-ttu-id="f5ac1-230">방법: 추적 소스 생성 및 초기화</span><span class="sxs-lookup"><span data-stu-id="f5ac1-230">How to: Create and Initialize Trace Sources</span></span>](../../../docs/framework/debug-trace-profile/how-to-create-and-initialize-trace-sources.md)  
 [<span data-ttu-id="f5ac1-231">방법: 추적 수신기와 함께 TraceSource 및 필터 사용</span><span class="sxs-lookup"><span data-stu-id="f5ac1-231">How to: Use TraceSource and Filters with Trace Listeners</span></span>](../../../docs/framework/debug-trace-profile/how-to-use-tracesource-and-filters-with-trace-listeners.md)  
 [<span data-ttu-id="f5ac1-232">추적 수신기</span><span class="sxs-lookup"><span data-stu-id="f5ac1-232">Trace Listeners</span></span>](../../../docs/framework/debug-trace-profile/trace-listeners.md)  
 [<span data-ttu-id="f5ac1-233">추적 스위치</span><span class="sxs-lookup"><span data-stu-id="f5ac1-233">Trace Switches</span></span>](../../../docs/framework/debug-trace-profile/trace-switches.md)

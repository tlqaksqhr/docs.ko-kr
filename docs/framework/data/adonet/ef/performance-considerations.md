---
title: "성능 고려 사항(Entity Framework)"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-ado
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
caps.latest.revision: "6"
author: douglaslMS
ms.author: douglasl
manager: craigg
ms.workload: dotnet
ms.openlocfilehash: 0f03a82c2164eac489a568ff4c0f3f9c55cf4326
ms.sourcegitcommit: ed26cfef4e18f6d93ab822d8c29f902cff3519d1
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/17/2018
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="d3912-102">성능 고려 사항(Entity Framework)</span><span class="sxs-lookup"><span data-stu-id="d3912-102">Performance Considerations (Entity Framework)</span></span>
<span data-ttu-id="d3912-103">이 항목에서는 ADO.NET Entity Framework의 성능 특징에 대해 설명하고, Entity Framework 응용 프로그램의 성능 개선을 위해 고려해야 할 몇 가지 사항을 알려 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-103">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="d3912-104">쿼리 실행 단계</span><span class="sxs-lookup"><span data-stu-id="d3912-104">Stages of Query Execution</span></span>  
 <span data-ttu-id="d3912-105">Entity Framework의 쿼리 성능을 보다 잘 이해하기 위해서는 쿼리가 개념적 모델에 대해 실행하고 데이터를 개체로 반환할 때 수행되는 작업을 알고 있는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-105">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="d3912-106">다음 표에서는 이러한 일련의 작업에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-106">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="d3912-107">작업</span><span class="sxs-lookup"><span data-stu-id="d3912-107">Operation</span></span>|<span data-ttu-id="d3912-108">상대 비용</span><span class="sxs-lookup"><span data-stu-id="d3912-108">Relative Cost</span></span>|<span data-ttu-id="d3912-109">빈도</span><span class="sxs-lookup"><span data-stu-id="d3912-109">Frequency</span></span>|<span data-ttu-id="d3912-110">설명</span><span class="sxs-lookup"><span data-stu-id="d3912-110">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="d3912-111">메타데이터 로드</span><span class="sxs-lookup"><span data-stu-id="d3912-111">Loading metadata</span></span>|<span data-ttu-id="d3912-112">보통</span><span class="sxs-lookup"><span data-stu-id="d3912-112">Moderate</span></span>|<span data-ttu-id="d3912-113">응용 프로그램 도메인당 한 번</span><span class="sxs-lookup"><span data-stu-id="d3912-113">Once in each application domain.</span></span>|<span data-ttu-id="d3912-114">Entity Framework에서 사용되는 모델 및 매핑 메타데이터가 <xref:System.Data.Metadata.Edm.MetadataWorkspace>로 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-114">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="d3912-115">이 메타데이터는 전역으로 캐시되고 동일한 응용 프로그램 도메인의 다른 <xref:System.Data.Objects.ObjectContext> 인스턴스에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-115">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="d3912-116">데이터베이스 연결 열기</span><span class="sxs-lookup"><span data-stu-id="d3912-116">Opening the database connection</span></span>|<span data-ttu-id="d3912-117">Moderate<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="d3912-117">Moderate<sup>1</sup></span></span>|<span data-ttu-id="d3912-118">필요한 만큼</span><span class="sxs-lookup"><span data-stu-id="d3912-118">As needed.</span></span>|<span data-ttu-id="d3912-119">데이터베이스에 대해 열린 연결에 중요 한 리소스를 사용 하기 때문에 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 열고 필요할 때만 데이터베이스 연결을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-119">Because an open connection to the database consumes a valuable resource, the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] opens and closes the database connection only as needed.</span></span> <span data-ttu-id="d3912-120">또한 연결을 명시적으로 열 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-120">You can also explicitly open the connection.</span></span> <span data-ttu-id="d3912-121">자세한 내용은 참조 [관리 연결 및 트랜잭션](http://msdn.microsoft.com/en-us/b6659d2a-9a45-4e98-acaa-d7a8029e5b99)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-121">For more information, see [Managing Connections and Transactions](http://msdn.microsoft.com/en-us/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).</span></span>|  
|<span data-ttu-id="d3912-122">뷰 생성</span><span class="sxs-lookup"><span data-stu-id="d3912-122">Generating views</span></span>|<span data-ttu-id="d3912-123">높음</span><span class="sxs-lookup"><span data-stu-id="d3912-123">High</span></span>|<span data-ttu-id="d3912-124">응용 프로그램 도메인당 한 번</span><span class="sxs-lookup"><span data-stu-id="d3912-124">Once in each application domain.</span></span> <span data-ttu-id="d3912-125">미리 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-125">(Can be pre-generated.)</span></span>|<span data-ttu-id="d3912-126">Entity Framework에서 개념적 모델에 대해 쿼리를 실행하거나 데이터 소스에 변경 내용을 저장하려면 먼저 로컬 쿼리 뷰 집합을 생성하여 데이터베이스에 액세스해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-126">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="d3912-127">이러한 뷰를 생성하는 데 비용이 많이 들기 때문에 디자인 타임에 뷰를 미리 생성한 후 프로젝트에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-127">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="d3912-128">자세한 내용은 참조 [하는 방법: 쿼리 성능이 향상 Pre-Generate 뷰](http://msdn.microsoft.com/en-us/b18a9d16-e10b-4043-ba91-b632f85a2579)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-128">For more information, see [How to: Pre-Generate Views to Improve Query Performance](http://msdn.microsoft.com/en-us/b18a9d16-e10b-4043-ba91-b632f85a2579).</span></span>|  
|<span data-ttu-id="d3912-129">쿼리 준비</span><span class="sxs-lookup"><span data-stu-id="d3912-129">Preparing the query</span></span>|<span data-ttu-id="d3912-130">Moderate<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="d3912-130">Moderate<sup>2</sup></span></span>|<span data-ttu-id="d3912-131">고유 쿼리당 한 번</span><span class="sxs-lookup"><span data-stu-id="d3912-131">Once for each unique query.</span></span>|<span data-ttu-id="d3912-132">쿼리 명령을 작성하고, 모델 및 매핑 메타데이터를 기반으로 명령 트리를 생성하고, 반환된 데이터의 셰이프를 정의하는 비용을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-132">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="d3912-133">Entity SQL 쿼리 명령과 LINQ 쿼리가 모두 캐시되므로 동일한 쿼리를 나중에 실행하는 경우 시간이 더 적게 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-133">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="d3912-134">그러나, 여전히 컴파일된 LINQ 쿼리를 사용하여 나중에 실행할 때 이러한 비용을 줄일 수 있으며 컴파일된 쿼리는 자동으로 캐시되는 LINQ 쿼리에서보다 효율적으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-134">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="d3912-135">자세한 내용은 참조 [컴파일된 쿼리 (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/compiled-queries-linq-to-entities.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-135">For more information, see [Compiled Queries  (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="d3912-136">LINQ 쿼리 실행에 대 한 일반 정보를 참조 하십시오. [LINQ to Entities](../../../../../docs/framework/data/adonet/ef/language-reference/linq-to-entities.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-136">For general information about LINQ query execution, see [LINQ to Entities](../../../../../docs/framework/data/adonet/ef/language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="d3912-137">**참고:** LINQ to Entities 쿼리가 적용 되는 `Enumerable.Contains` 연산자를 메모리 내 컬렉션은 자동으로 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-137">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="d3912-138">또한 메모리 내 컬렉션은 컴파일된 LINQ 쿼리에서 매개 변수화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-138">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="d3912-139">쿼리 실행</span><span class="sxs-lookup"><span data-stu-id="d3912-139">Executing the query</span></span>|<span data-ttu-id="d3912-140">Low<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="d3912-140">Low<sup>2</sup></span></span>|<span data-ttu-id="d3912-141">쿼리당 한 번</span><span class="sxs-lookup"><span data-stu-id="d3912-141">Once for each query.</span></span>|<span data-ttu-id="d3912-142">ADO.NET 데이터 공급자를 사용하여 데이터 소스에 대해 명령을 실행하는 비용입니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-142">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="d3912-143">대부분의 데이터 소스에서 쿼리 계획을 캐시하므로 동일한 쿼리를 나중에 실행하는 경우 시간이 더 적게 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-143">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="d3912-144">형식 로드 및 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="d3912-144">Loading and validating types</span></span>|<span data-ttu-id="d3912-145">낮은<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="d3912-145">Low<sup>3</sup></span></span>|<span data-ttu-id="d3912-146"><xref:System.Data.Objects.ObjectContext> 인스턴스당 한 번</span><span class="sxs-lookup"><span data-stu-id="d3912-146">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="d3912-147">형식은 개념적 모델에서 정의하는 형식에 대해 로드되고 유효성이 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-147">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="d3912-148">추적</span><span class="sxs-lookup"><span data-stu-id="d3912-148">Tracking</span></span>|<span data-ttu-id="d3912-149">낮은<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="d3912-149">Low<sup>3</sup></span></span>|<span data-ttu-id="d3912-150">쿼리에서 반환하는 개체당 한 번</span><span class="sxs-lookup"><span data-stu-id="d3912-150">Once for each object that a query returns.</span></span> <span data-ttu-id="d3912-151"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="d3912-151"><sup>4</sup></span></span>|<span data-ttu-id="d3912-152">쿼리에서 <xref:System.Data.Objects.MergeOption.NoTracking> 병합 옵션을 사용하는 경우 이 단계는 성능에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-152">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="d3912-153">쿼리에서 <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges> 또는 <xref:System.Data.Objects.MergeOption.OverwriteChanges> 병합 옵션을 사용하는 경우 <xref:System.Data.Objects.ObjectStateManager>에서 쿼리 결과를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-153">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="d3912-154">쿼리가 반환한 각 추적된 개체에 대해 <xref:System.Data.EntityKey>가 생성되고 이는 <xref:System.Data.Objects.ObjectStateEntry>에서 <xref:System.Data.Objects.ObjectStateManager>를 만드는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-154">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="d3912-155"><xref:System.Data.Objects.ObjectStateEntry>에 대한 기존 <xref:System.Data.EntityKey>를 찾을 수 있는 경우 기존 개체가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-155">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="d3912-156"><xref:System.Data.Objects.MergeOption.PreserveChanges> 또는 <xref:System.Data.Objects.MergeOption.OverwriteChanges> 옵션이 사용되는 경우 개체를 반환하기 전에 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-156">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="d3912-157">자세한 내용은 참조 [Id 확인, 상태 관리 및 변경 내용 추적](http://msdn.microsoft.com/en-us/3bd49311-0e72-4ea4-8355-38fe57036ba0)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-157">For more information, see [Identity Resolution, State Management, and Change Tracking](http://msdn.microsoft.com/en-us/3bd49311-0e72-4ea4-8355-38fe57036ba0).</span></span>|  
|<span data-ttu-id="d3912-158">개체 구체화</span><span class="sxs-lookup"><span data-stu-id="d3912-158">Materializing the objects</span></span>|<span data-ttu-id="d3912-159">보통<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="d3912-159">Moderate<sup>3</sup></span></span>|<span data-ttu-id="d3912-160">쿼리에서 반환하는 개체당 한 번</span><span class="sxs-lookup"><span data-stu-id="d3912-160">Once for each object that a query returns.</span></span> <span data-ttu-id="d3912-161"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="d3912-161"><sup>4</sup></span></span>|<span data-ttu-id="d3912-162">반환된 <xref:System.Data.Common.DbDataReader> 개체를 읽고, <xref:System.Data.Common.DbDataRecord> 클래스의 각 인스턴스에 있는 값을 기준으로 개체를 만들고 속성 값을 설정하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-162">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="d3912-163"><xref:System.Data.Objects.ObjectContext>에 이미 개체가 있고 쿼리에서 <xref:System.Data.Objects.MergeOption.AppendOnly> 또는 <xref:System.Data.Objects.MergeOption.PreserveChanges> 병합 옵션을 사용하는 경우 이 단계는 성능에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-163">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="d3912-164">자세한 내용은 참조 [Id 확인, 상태 관리 및 변경 내용 추적](http://msdn.microsoft.com/en-us/3bd49311-0e72-4ea4-8355-38fe57036ba0)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-164">For more information, see [Identity Resolution, State Management, and Change Tracking](http://msdn.microsoft.com/en-us/3bd49311-0e72-4ea4-8355-38fe57036ba0).</span></span>|  
  
 <span data-ttu-id="d3912-165"><sup>1</sup> 을 대 한 연결을 여는 비용은 풀 전체로 분산 하는 경우 데이터 원본 공급자가 연결 풀링을 구현, 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-165"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="d3912-166">.NET Provider for SQL Server에서는 연결 풀링을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-166">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="d3912-167"><sup>2</sup> 쿼리가 더 복잡해져 비용이 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-167"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="d3912-168"><sup>3</sup> 쿼리에 의해 반환 된 개체 수에 비례하여 총 비용이 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-168"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="d3912-169"><sup>4</sup> EntityClient 쿼리 반환 하므로이 오버 헤드가 필요 하지 않습니다는 <xref:System.Data.EntityClient.EntityDataReader> 개체 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-169"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="d3912-170">자세한 내용은 참조 [Entity Framework 용 EntityClient 공급자](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-170">For more information, see [EntityClient Provider for the Entity Framework](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="d3912-171">추가 고려 사항</span><span class="sxs-lookup"><span data-stu-id="d3912-171">Additional Considerations</span></span>  
 <span data-ttu-id="d3912-172">다음은 Entity Framework 응용 프로그램의 성능에 영향을 줄 수 있는 기타 고려 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-172">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="d3912-173">쿼리 실행</span><span class="sxs-lookup"><span data-stu-id="d3912-173">Query Execution</span></span>  
 <span data-ttu-id="d3912-174">쿼리는 리소스를 많이 사용할 수 있으므로 코드의 어느 시점에, 어느 컴퓨터에서 쿼리를 실행하는지 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="d3912-174">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="d3912-175">지연된 실행과 즉시 실행 비교</span><span class="sxs-lookup"><span data-stu-id="d3912-175">Deferred versus immediate execution</span></span>  
 <span data-ttu-id="d3912-176"><xref:System.Data.Objects.ObjectQuery%601> 또는 LINQ 쿼리를 만들 때 쿼리가 즉시 실행되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-176">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="d3912-177">쿼리 실행은 `foreach`(C#)나 `For Each`(Visual Basic) 열거 시 또는 <xref:System.Collections.Generic.List%601> 컬렉션을 채우도록 지정된 경우와 같이 결과가 필요할 때까지 지연됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-177">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="d3912-178">쿼리 실행은 사용자가 <xref:System.Data.Objects.ObjectQuery%601.Execute%2A>에서 <xref:System.Data.Objects.ObjectQuery%601> 메서드를 호출하거나 <xref:System.Linq.Enumerable.First%2A> 또는 <xref:System.Linq.Enumerable.Any%2A>와 같은 단일 쿼리를 반환하는 LINQ 메서드를 호출할 때 즉시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-178">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="d3912-179">자세한 내용은 참조 [개체 쿼리](http://msdn.microsoft.com/en-us/0768033c-876f-471d-85d5-264884349276) 및 [쿼리 실행 (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-179">For more information, see [Object Queries](http://msdn.microsoft.com/en-us/0768033c-876f-471d-85d5-264884349276) and [Query Execution (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="d3912-180">LINQ 쿼리의 클라이언트 쪽 실행</span><span class="sxs-lookup"><span data-stu-id="d3912-180">Client-side execution of LINQ queries</span></span>  
 <span data-ttu-id="d3912-181">LINQ 쿼리 실행은 데이터 소스를 호스트하는 컴퓨터에서 이루어지지만 일부 LINQ 쿼리는 클라이언트 컴퓨터에서 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-181">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="d3912-182">자세한 내용은 참조의 저장소 실행 단원을 [쿼리 실행 (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-182">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="d3912-183">쿼리 및 매핑 복잡성</span><span class="sxs-lookup"><span data-stu-id="d3912-183">Query and Mapping Complexity</span></span>  
 <span data-ttu-id="d3912-184">엔터티 모델의 매핑 및 개별 쿼리의 복잡성은 쿼리 성능에 상당한 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-184">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="d3912-185">매핑 복잡성</span><span class="sxs-lookup"><span data-stu-id="d3912-185">Mapping complexity</span></span>  
 <span data-ttu-id="d3912-186">개념적 모델의 엔터티와 저장소 모델의 테이블 간 단순 일대일 매핑보다 다소 복잡한 모델은 일대일 매핑의 모델보다 복잡한 명령을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-186">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="d3912-187">쿼리 복잡성</span><span class="sxs-lookup"><span data-stu-id="d3912-187">Query complexity</span></span>  
 <span data-ttu-id="d3912-188">데이터 소스에 대해 실행되는 명령에 많은 수의 조인이 필요하거나 많은 양의 데이터를 반환하는 쿼리는 다음 방식으로 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-188">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
-   <span data-ttu-id="d3912-189">간단해 보이는 개념적 모델의 쿼리로 인해 데이터 소스에 대해 보다 복잡한 쿼리가 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-189">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="d3912-190">이는 Entity Framework에서 개념적 모델에 대한 쿼리를 데이터 소스에 대한 동등한 쿼리로 변환하기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-190">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="d3912-191">개념적 모델의 단일 엔터티 집합이 데이터 소스에 있는 둘 이상의 테이블에 매핑되거나 엔터티 간 관계가 조인 테이블에 매핑되면 데이터 소스 쿼리에 대해 실행되는 쿼리 명령에서 하나 이상의 조인을 필요로 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-191">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d3912-192"><xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> 또는 <xref:System.Data.Objects.ObjectQuery%601> 클래스의 <xref:System.Data.EntityClient.EntityCommand> 메서드를 사용하여 제공된 쿼리의 데이터 소스에 대해 실행된 명령을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-192">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="d3912-193">자세한 내용은 참조 [하는 방법: 저장소 명령 보기](http://msdn.microsoft.com/en-us/f9771c6e-3b62-4b24-a5d4-55d68e14fa79)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-193">For more information, see [How to: View the Store Commands](http://msdn.microsoft.com/en-us/f9771c6e-3b62-4b24-a5d4-55d68e14fa79).</span></span>  
  
-   <span data-ttu-id="d3912-194">중첩 Entity SQL 쿼리는 서버에서 조인을 만들고 많은 수의 행을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-194">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="d3912-195">다음은 프로젝션 절의 중첩 쿼리 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-195">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2   
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1   
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="d3912-196">또한 이러한 쿼리로 인해 쿼리 파이프라인이 중첩 쿼리에 대해 개체가 중복된 단일 쿼리를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-196">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="d3912-197">이에 따라 단일 열이 여러 번 중복될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-197">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="d3912-198">SLQ Server를 비롯한 일부 데이터베이스에서는 이로 인해 TempDB 테이블 크기가 과도하게 커질 수 있으므로 서버 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-198">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="d3912-199">중첩 쿼리를 실행할 때는 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-199">Care should be taken when you execute nested queries.</span></span>  
  
-   <span data-ttu-id="d3912-200">많은 양의 데이터를 반환하는 쿼리는 클라이언트가 결과 집합의 크기에 비례하여 리소스를 사용하는 작업을 수행할 경우 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-200">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="d3912-201">그러므로 쿼리에서 반환되는 데이터 양을 제한하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-201">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="d3912-202">자세한 내용은 참조 [하는 방법: 쿼리 결과 통해 페이지](http://msdn.microsoft.com/en-us/ffc0f920-e7de-42e0-9b12-ef356421d030)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-202">For more information, see [How to: Page Through Query Results](http://msdn.microsoft.com/en-us/ffc0f920-e7de-42e0-9b12-ef356421d030).</span></span>  
  
 <span data-ttu-id="d3912-203">Entity Framework에 의해 자동으로 생성된 명령은 데이터베이스 개발자가 명시적으로 작성한 유사 명령보다 복잡할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-203">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="d3912-204">데이터 소스에 대해 실행된 명령에 명시적 제어가 필요한 경우 테이블 반환 함수 또는 저장 프로시저에 대한 매핑을 정의하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-204">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="d3912-205">Relationships</span><span class="sxs-lookup"><span data-stu-id="d3912-205">Relationships</span></span>  
 <span data-ttu-id="d3912-206">최적의 쿼리 성능을 위해 엔터티 간 관계를 엔터티 모델의 연결과 데이터 소스의 논리적 관계로 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-206">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="d3912-207">쿼리 경로</span><span class="sxs-lookup"><span data-stu-id="d3912-207">Query Paths</span></span>  
 <span data-ttu-id="d3912-208">기본적으로 <xref:System.Data.Objects.ObjectQuery%601>를 실행할 때 자체적으로 관계를 나타내는 개체는 반환되지만 관련 개체는 반환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-208">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="d3912-209">관련 개체는 다음 세 가지 방법 중 하나로 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-209">You can load related objects in one of three ways:</span></span>  
  
1.  <span data-ttu-id="d3912-210"><xref:System.Data.Objects.ObjectQuery%601>가 실행되기 전에 쿼리 경로를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-210">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2.  <span data-ttu-id="d3912-211">개체가 노출하는 탐색 속성에서 `Load` 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-211">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3.  <span data-ttu-id="d3912-212"><xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A>에서 <xref:System.Data.Objects.ObjectContext> 옵션을 `true`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-212">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="d3912-213">이 초과 프로비저닝이 수행 자동으로 사용 하 여 개체 계층 코드를 생성할 때는 [엔터티 데이터 모델 디자이너](http://msdn.microsoft.com/en-us/4ccd7ad6-b934-4f7c-82a0-cfd2d4a95faf)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-213">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](http://msdn.microsoft.com/en-us/4ccd7ad6-b934-4f7c-82a0-cfd2d4a95faf).</span></span> <span data-ttu-id="d3912-214">자세한 내용은 참조 [생성 된 코드 개요](http://msdn.microsoft.com/en-us/6a88ea38-6a90-4107-bc33-531b79ce5b6a)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-214">For more information see [Generated Code Overview](http://msdn.microsoft.com/en-us/6a88ea38-6a90-4107-bc33-531b79ce5b6a).</span></span>  
  
 <span data-ttu-id="d3912-215">사용할 옵션을 고려할 때는 데이터베이스에 대한 요청의 수와 단일 쿼리에 반환되는 데이터의 양이 서로 상쇄되는 관계임을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-215">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="d3912-216">자세한 내용은 참조 [관련 개체 로드](http://msdn.microsoft.com/en-us/452347d2-7b3b-44cd-9001-231299a28cb1)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-216">For more information, see [Loading Related Objects](http://msdn.microsoft.com/en-us/452347d2-7b3b-44cd-9001-231299a28cb1).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="d3912-217">쿼리 경로 사용</span><span class="sxs-lookup"><span data-stu-id="d3912-217">Using query paths</span></span>  
 <span data-ttu-id="d3912-218">쿼리 경로는 쿼리가 반환하는 개체의 그래프를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-218">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="d3912-219">쿼리 경로를 정의하면 데이터베이스에 대한 단일 요청만이 경로에 정의된 모든 개체를 반환하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-219">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="d3912-220">쿼리 경로를 사용하면 단순 개체 쿼리의 데이터 소스에 대해 복잡한 명령이 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-220">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="d3912-221">이는 관련 개체를 단일 쿼리에서 반환하려면 조인이 하나 이상 필요하기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-221">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="d3912-222">이러한 복잡성은 다대다 관계가 포함된 상속이나 경로를 가진 엔터티와 같은 복합 엔터티 모델에 대한 쿼리에서 더 커집니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-222">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d3912-223"><xref:System.Data.Objects.ObjectQuery.ToTraceString%2A>에서 생성되는 명령을 보려면 <xref:System.Data.Objects.ObjectQuery%601> 메서드를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="d3912-223">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="d3912-224">자세한 내용은 참조 [하는 방법: 저장소 명령 보기](http://msdn.microsoft.com/en-us/f9771c6e-3b62-4b24-a5d4-55d68e14fa79)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-224">For more information, see [How to: View the Store Commands](http://msdn.microsoft.com/en-us/f9771c6e-3b62-4b24-a5d4-55d68e14fa79).</span></span>  
  
 <span data-ttu-id="d3912-225">쿼리 경로에 관련 개체가 너무 많거나 개체에 행 데이터가 너무 많은 경우 데이터 소스에서 쿼리를 완료하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-225">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="d3912-226">쿼리에 필요한 중간 임시 저장소가 데이터 소스의 용량을 초과하는 경우 이런 현상이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-226">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="d3912-227">이 경우, 관련 개체를 명시적으로 로드하는 방법으로 데이터 원본 쿼리의 복잡성을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-227">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="d3912-228">명시적으로 관련 개체 로드</span><span class="sxs-lookup"><span data-stu-id="d3912-228">Explicitly loading related objects</span></span>  
 <span data-ttu-id="d3912-229">`Load` 또는 <xref:System.Data.Objects.DataClasses.EntityCollection%601>를 반환하는 탐색 속성에서 <xref:System.Data.Objects.DataClasses.EntityReference%601> 메서드를 호출하여 관련 개체를 명시적으로 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-229">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="d3912-230">명시적으로 개체를 로드하는 경우 `Load`가 호출될 때마다 데이터베이스에 대한 라운드트립이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-230">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d3912-231">`Load` 문(Visual Basic에서는 `foreach`)을 사용하는 경우와 같이 반환된 개체 컬렉션을 반복하면서 `For Each`를 호출하는 경우 데이터 소스 관련 공급자는 단일 연결에서 여러 활성 결과 집합을 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-231">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="d3912-232">SQL Server 데이터베이스의 경우 공급자 연결 문자열에서 `MultipleActiveResultSets = true` 값을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-232">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="d3912-233">엔터티에 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> 또는 <xref:System.Data.Objects.DataClasses.EntityCollection%601> 속성이 없는 경우에는 <xref:System.Data.Objects.DataClasses.EntityReference%601> 메서드를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-233">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="d3912-234">이 메서드는 POCO 엔터티를 사용하는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-234">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="d3912-235">관련 개체를 명시적으로 로드할 때 조인 수 및 중복 데이터 양이 줄어들지만 `Load`에서 데이터베이스에 대한 연결을 반복해야 합니다. 이러한 반복 작업은 많은 수의 개체를 명시적으로 로드하는 경우 비용이 많이 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-235">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="d3912-236">변경 내용 저장</span><span class="sxs-lookup"><span data-stu-id="d3912-236">Saving Changes</span></span>  
 <span data-ttu-id="d3912-237"><xref:System.Data.Objects.ObjectContext.SaveChanges%2A>에서 <xref:System.Data.Objects.ObjectContext> 메서드를 호출할 때 컨텍스트에서 추가되거나, 업데이트되거나, 삭제된 각각의 개체에 대해 별도의 만들기, 업데이트 또는 삭제 명령이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-237">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="d3912-238">이러한 명령은 데이터 소스에서 단일 트랜잭션으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-238">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="d3912-239">쿼리와 마찬가지로 만들기, 업데이트 및 삭제 작업의 성능은 개념적 모델에서의 매핑 복잡성에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-239">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="d3912-240">분산 트랜잭션</span><span class="sxs-lookup"><span data-stu-id="d3912-240">Distributed Transactions</span></span>  
 <span data-ttu-id="d3912-241">DTC(Distributed Transaction Coordinator)에 의해 관리되는 리소스가 필요한 명시적 트랜잭션에서의 작업은 DTC가 필요하지 않은 유사한 작업보다 비용이 훨씬 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-241">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="d3912-242">DTC로의 승격은 다음 상황에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-242">Promotion to the DTC will occur in the following situations:</span></span>  
  
-   <span data-ttu-id="d3912-243">항상 명시적 트랜잭션을 DTC로 승격하는 SQL Server 2000 데이터베이스 또는 기타 데이터 소스에 대한 작업을 포함하는 명시적 트랜잭션</span><span class="sxs-lookup"><span data-stu-id="d3912-243">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
-   <span data-ttu-id="d3912-244">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]에서 연결을 관리하는 경우 SQL Server 2005에 대한 작업을 포함하는 명시적 트랜잭션.</span><span class="sxs-lookup"><span data-stu-id="d3912-244">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)].</span></span> <span data-ttu-id="d3912-245">이 트랜잭션은 단일 트랜잭션 내에서 연결이 닫히고 다시 열리는 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]의 기본 동작이 수행될 때마다 SQL Server 2005가 DTC로 승격되기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-245">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)].</span></span> <span data-ttu-id="d3912-246">이 DTC 승격은 SQL Server 2008 사용 시 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-246">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="d3912-247">SQL Server 2005를 사용할 때 이러한 승격이 발생하지 않도록 하려면 트랜잭션 내에서 연결을 명시적으로 열고 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-247">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="d3912-248">자세한 내용은 참조 [관리 연결 및 트랜잭션](http://msdn.microsoft.com/en-us/b6659d2a-9a45-4e98-acaa-d7a8029e5b99)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-248">For more information, see [Managing Connections and Transactions](http://msdn.microsoft.com/en-us/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).</span></span>  
  
 <span data-ttu-id="d3912-249"><xref:System.Transactions> 트랜잭션 내에서 하나 이상의 작업이 실행될 때 명시적 트랜잭션이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-249">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="d3912-250">자세한 내용은 참조 [관리 연결 및 트랜잭션](http://msdn.microsoft.com/en-us/b6659d2a-9a45-4e98-acaa-d7a8029e5b99)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-250">For more information, see [Managing Connections and Transactions](http://msdn.microsoft.com/en-us/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="d3912-251">성능 향상 전략</span><span class="sxs-lookup"><span data-stu-id="d3912-251">Strategies for Improving Performance</span></span>  
 <span data-ttu-id="d3912-252">다음 전략을 사용하면 Entity Framework에서 쿼리의 전체 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-252">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="d3912-253">뷰 미리 생성</span><span class="sxs-lookup"><span data-stu-id="d3912-253">Pre-generate views</span></span>  
 <span data-ttu-id="d3912-254">엔터티 모델을 기반으로 하는 뷰 생성 작업은 처음 응용 프로그램에서 쿼리를 실행할 때 상당한 비용이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-254">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="d3912-255">EdmGen.exe 유틸리티를 사용하면 디자인 시 프로젝트에 추가할 수 있는 Visual Basic 또는 C# 코드 파일로 뷰를 미리 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-255">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="d3912-256">T4(Text Template Transformation Toolkit)를 사용하여 미리 컴파일된 뷰를 생성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-256">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="d3912-257">또한 런타임에 미리 생성된 뷰의 유효성을 검사하여 지정된 엔터티 모델의 현재 버전과 일치하는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-257">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="d3912-258">자세한 내용은 참조 [하는 방법: Pre-Generate 뷰를 쿼리 성능을 높이](http://msdn.microsoft.com/en-us/b18a9d16-e10b-4043-ba91-b632f85a2579) 및 [뷰가 포함 된 미리 컴파일된/사전 generated Entity Framework 4의 성능 격리](http://go.microsoft.com/fwlink/?LinkID=201337&clcid=0x409)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-258">For more information, see [How to: Pre-Generate Views to Improve Query Performance](http://msdn.microsoft.com/en-us/b18a9d16-e10b-4043-ba91-b632f85a2579) and [Isolating Performance with Precompiled/Pre-generated Views in the Entity Framework 4](http://go.microsoft.com/fwlink/?LinkID=201337&clcid=0x409).</span></span>  
  
 <span data-ttu-id="d3912-259">매우 큰 모델로 작업하는 경우 고려할 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-259">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="d3912-260">.NET 메타데이터 형식은 지정된 이진 파일의 사용자 문자열 문자 수를 16,777,215(0xFFFFFF)로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-260">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="d3912-261">매우 큰 모델에 대 한 보기를 생성 하는 파일 보기에이 크기 제한에 도달 하는 경우 얻게 됩니다는 "논리 남아 있는 공간이 없습니다 더 많은 사용자 문자열을 만들 수 있습니다."</span><span class="sxs-lookup"><span data-stu-id="d3912-261">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="d3912-262">컴파일 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-262">compile error.</span></span> <span data-ttu-id="d3912-263">이 크기 제한은 관리되는 모든 이진 파일에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-263">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="d3912-264">자세한 내용은 참조는 [블로그](http://go.microsoft.com/fwlink/?LinkId=201476) 크고 복잡 한 모델을 사용할 때 오류를 방지 하는 방법을 보여 주는 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-264">For more information see the [blog](http://go.microsoft.com/fwlink/?LinkId=201476) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="d3912-265">쿼리에 대한 NoTracking 병합 옵션 사용</span><span class="sxs-lookup"><span data-stu-id="d3912-265">Consider using the NoTracking merge option for queries</span></span>  
 <span data-ttu-id="d3912-266">개체 컨텍스트에서 반환된 개체를 추적하려면 비용이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-266">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="d3912-267">개체에 대한 변경 내용을 감지하고 동일한 논리 엔터티에 대한 여러 요청에서 동일한 개체 인스턴스를 반환하도록 할 경우 개체가 <xref:System.Data.Objects.ObjectContext> 인스턴스에 연결되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-267">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="d3912-268">개체를 업데이트하거나 삭제할 계획이 없으며 ID 관리가 필요하지 않는 경우에는 쿼리를 실행할 때 <xref:System.Data.Objects.MergeOption.NoTracking> 병합 옵션을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="d3912-268">If you do not plan to make updates or deletes to objects and do not require identity management , consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="d3912-269">적절한 양의 데이터 반환</span><span class="sxs-lookup"><span data-stu-id="d3912-269">Return the correct amount of data</span></span>  
 <span data-ttu-id="d3912-270">일부 시나리오에서는 <xref:System.Data.Objects.ObjectQuery%601.Include%2A> 메서드를 사용하여 쿼리 경로를 지정하는 작업을 수행하면 데이터베이스에 대한 라운드트립 수가 줄어들어 훨씬 속도가 빨라집니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-270">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="d3912-271">그러나 또 다른 시나리오에서는 조인 수가 더 적은 아주 간단한 쿼리로 인해 데이터가 덜 중복되어 관련 개체를 로드하는 데이터베이스에 대한 추가 라운드트립의 속도가 보다 더 빠를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-271">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="d3912-272">이 때문에 관련 개체를 검색하는 여러 방법의 성능을 테스트하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-272">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="d3912-273">자세한 내용은 참조 [관련 개체 로드](http://msdn.microsoft.com/en-us/452347d2-7b3b-44cd-9001-231299a28cb1)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-273">For more information, see [Loading Related Objects](http://msdn.microsoft.com/en-us/452347d2-7b3b-44cd-9001-231299a28cb1).</span></span>  
  
 <span data-ttu-id="d3912-274">단일 쿼리에서 너무 많은 데이터가 반환되지 않도록 하려면 쿼리 결과를 보다 관리하기 쉬운 그룹으로 페이징하세요.</span><span class="sxs-lookup"><span data-stu-id="d3912-274">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="d3912-275">자세한 내용은 참조 [하는 방법: 쿼리 결과 통해 페이지](http://msdn.microsoft.com/en-us/ffc0f920-e7de-42e0-9b12-ef356421d030)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-275">For more information, see [How to: Page Through Query Results](http://msdn.microsoft.com/en-us/ffc0f920-e7de-42e0-9b12-ef356421d030).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="d3912-276">ObjectContext의 범위 제한</span><span class="sxs-lookup"><span data-stu-id="d3912-276">Limit the scope of the ObjectContext</span></span>  
 <span data-ttu-id="d3912-277">대부분의 경우 <xref:System.Data.Objects.ObjectContext> 문(Visual Basic에서는 `using`) 내에서 `Using…End Using` 인스턴스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-277">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="d3912-278">이렇게 하면 코드가 문 블록을 종료할 때 개체 컨텍스트와 연결된 리소스가 자동으로 삭제되도록 하여 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-278">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="d3912-279">그러나 컨트롤이 개체 컨텍스트에서 관리하는 개체로 바인딩된 경우 바인딩이 필요할 때까지 <xref:System.Data.Objects.ObjectContext> 인스턴스가 유지 관리되어야 하고, 그렇지 않은 경우 해당 인스턴스가 수동으로 삭제되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-279">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="d3912-280">자세한 내용은 참조 [관리 연결 및 트랜잭션](http://msdn.microsoft.com/en-us/b6659d2a-9a45-4e98-acaa-d7a8029e5b99)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-280">For more information, see [Managing Connections and Transactions](http://msdn.microsoft.com/en-us/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="d3912-281">수동으로 데이터베이스 연결 열기</span><span class="sxs-lookup"><span data-stu-id="d3912-281">Consider opening the database connection manually</span></span>  
 <span data-ttu-id="d3912-282">응용 프로그램에서 일련의 개체 쿼리를 실행 하거나 자주 호출 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> 지 속하는 만들기, 업데이트 및 삭제 작업을 데이터 소스는 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 지속적으로 열고 데이터 원본에 연결을 종료 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-282">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="d3912-283">이러한 경우 해당 작업 시작 시 연결을 수동으로 열고, 작업 완료 시 연결을 수동으로 닫거나 삭제하세요.</span><span class="sxs-lookup"><span data-stu-id="d3912-283">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="d3912-284">자세한 내용은 참조 [관리 연결 및 트랜잭션](http://msdn.microsoft.com/en-us/b6659d2a-9a45-4e98-acaa-d7a8029e5b99)합니다.</span><span class="sxs-lookup"><span data-stu-id="d3912-284">For more information, see [Managing Connections and Transactions](http://msdn.microsoft.com/en-us/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="d3912-285">성능 데이터</span><span class="sxs-lookup"><span data-stu-id="d3912-285">Performance Data</span></span>  
 <span data-ttu-id="d3912-286">Entity Framework에 대 한 일부 성능 데이터를 다음 게시물에서에 게시는 [ADO.NET 팀 블로그](http://go.microsoft.com/fwlink/?LinkId=91905):</span><span class="sxs-lookup"><span data-stu-id="d3912-286">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](http://go.microsoft.com/fwlink/?LinkId=91905):</span></span>  
  
-   [<span data-ttu-id="d3912-287">ADO.NET Entity Framework-1 부의 성능 알아보기</span><span class="sxs-lookup"><span data-stu-id="d3912-287">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](http://go.microsoft.com/fwlink/?LinkId=123907)  
  
-   [<span data-ttu-id="d3912-288">ADO.NET Entity Framework-2 부의 성능 알아보기</span><span class="sxs-lookup"><span data-stu-id="d3912-288">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](http://go.microsoft.com/fwlink/?LinkId=123909)  
  
-   [<span data-ttu-id="d3912-289">ADO.NET Entity Framework 성능 비교</span><span class="sxs-lookup"><span data-stu-id="d3912-289">ADO.NET Entity Framework Performance Comparison</span></span>](http://go.microsoft.com/fwlink/?LinkID=123913)  
  
## <a name="see-also"></a><span data-ttu-id="d3912-290">참고 항목</span><span class="sxs-lookup"><span data-stu-id="d3912-290">See Also</span></span>  
 [<span data-ttu-id="d3912-291">개발 및 배포 고려 사항</span><span class="sxs-lookup"><span data-stu-id="d3912-291">Development and Deployment Considerations</span></span>](../../../../../docs/framework/data/adonet/ef/development-and-deployment-considerations.md)

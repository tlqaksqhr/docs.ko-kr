---
title: "웹 서비스를 사용하는 LINQ to SQL N 계층"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-ado
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 9cb10eb8-957f-4beb-a271-5f682016fed2
caps.latest.revision: "3"
author: JennieHubbard
ms.author: jhubbard
manager: jhubbard
ms.workload: dotnet
ms.openlocfilehash: 37dfeec82339ed4381d158b1bd5ac442223bfe50
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/22/2017
---
# <a name="linq-to-sql-n-tier-with-web-services"></a><span data-ttu-id="5856f-102">웹 서비스를 사용하는 LINQ to SQL N 계층</span><span class="sxs-lookup"><span data-stu-id="5856f-102">LINQ to SQL N-Tier with Web Services</span></span>
[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="5856f-103">웹 서비스와 같이 느슨하게 결합 된 데이터 액세스 계층 (DAL)에서 중간 계층에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-103"> is designed especially for use on the middle tier in a loosely-coupled data access layer (DAL) such as a Web service.</span></span> <span data-ttu-id="5856f-104">프레젠테이션 계층이 ASP.NET 웹 페이지인 경우에는 <xref:System.Web.UI.WebControls.LinqDataSource> 웹 서버 컨트롤을 사용하여 사용자 인터페이스와 중간 계층의 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 사이에 데이터 전송을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-104">If the presentation tier is an ASP.NET Web page, then you use the <xref:System.Web.UI.WebControls.LinqDataSource> Web server control to manage the data transfer between the user interface and [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] on the middle-tier.</span></span> <span data-ttu-id="5856f-105">그러나 프레젠테이션 계층이 ASP.NET 페이지가 아닌 경우에는 중간 계층과 프레젠테이션 계층 모두에서 데이터 serialization 및 deserialization을 관리하기 위해 추가적인 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-105">If the presentation tier is not an ASP.NET page, then both the middle-tier and the presentation tier must do some additional work to manage the serialization and deserialization of data.</span></span>  
  
## <a name="setting-up-linq-to-sql-on-the-middle-tier"></a><span data-ttu-id="5856f-106">중간 계층에서 LINQ to SQL 설정</span><span class="sxs-lookup"><span data-stu-id="5856f-106">Setting up LINQ to SQL on the Middle Tier</span></span>  
 <span data-ttu-id="5856f-107">웹 서비스 또는 n 계층 응용 프로그램의 중간 계층에는 데이터 컨텍스트와 엔터티 클래스가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-107">In a Web service or n-tier application, the middle tier contains the data context and the entity classes.</span></span> <span data-ttu-id="5856f-108">이러한 클래스는 수동으로 만들거나, 이 설명서의 다른 곳에 나와 있는 설명대로 SQLMetal.exe 또는 [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)]를 사용하여 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-108">You can create these classes manually, or by using either SQLMetal.exe or the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] as described elsewhere in the documentation.</span></span> <span data-ttu-id="5856f-109">디자인 타임에 엔터티 클래스를 serialize할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-109">At design time, you have the option to make the entity classes serializable.</span></span> <span data-ttu-id="5856f-110">자세한 내용은 참조 [하는 방법: 엔터티를 직렬화 가능 하 게](../../../../../../docs/framework/data/adonet/sql/linq/how-to-make-entities-serializable.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-110">For more information, see [How to: Make Entities Serializable](../../../../../../docs/framework/data/adonet/sql/linq/how-to-make-entities-serializable.md).</span></span> <span data-ttu-id="5856f-111">또는 serialize할 데이터를 캡슐화하는 별도의 클래스 집합을 만든 다음 [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] 쿼리에 데이터를 반환할 때 serialize 가능한 이러한 형식을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-111">Another option is to create a separate set of classes that encapsulate the data to be serialized, and then project into those serializable types when you return data in your [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] queries.</span></span>  
  
 <span data-ttu-id="5856f-112">그런 다음 클라이언트에서 데이터를 검색, 삽입 및 업데이트할 때 호출할 메서드를 사용하여 인터페이스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-112">You then define the interface with the methods that the clients will call to retrieve, insert and update data.</span></span> <span data-ttu-id="5856f-113">이 인터페이스 메서드는 [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] 쿼리를 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-113">The interface methods wrap your [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] queries.</span></span> <span data-ttu-id="5856f-114">원격 메서드 호출 및 데이터 serialization은 모든 종류의 serialization 메커니즘을 사용하여 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-114">You can use any kind of serialization mechanism to handle the remote method calls and the serialization of data.</span></span> <span data-ttu-id="5856f-115">단, 표준 Northwind 개체 모델의 Customers와 Orders의 관계와 같이 개체 모델에 순환 또는 양방향 관계가 있는 경우에는 이를 지원하는 serializer를 반드시 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-115">The only requirement is that if you have cyclic or bi-directional relationships in your object model, such as that between Customers and Orders in the standard Northwind object model, then you must use a serializer that supports it.</span></span> <span data-ttu-id="5856f-116">WCF(Windows Communication Foundation) <xref:System.Runtime.Serialization.DataContractSerializer>는 양방향 관계를 지원하지만 WCF가 아닌 웹 서비스에 사용되는 XmlSerializer는 양방향 관계를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-116">The Windows Communication Foundation (WCF) <xref:System.Runtime.Serialization.DataContractSerializer> supports bi-directional relationships but the XmlSerializer that is used with non-WCF Web services does not.</span></span> <span data-ttu-id="5856f-117">따라서 XmlSerializer를 사용하도록 선택한 경우에는 개체 모델에 순환 관계가 없는지 반드시 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-117">If you select to use the XmlSerializer, then you must make sure that your object model has no cyclic relationships.</span></span>  
  
 <span data-ttu-id="5856f-118">Windows Communication Foundation에 대 한 자세한 내용은 참조 [Windows Communication Foundation 서비스 및 Visual Studio에서 WCF Data Services](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio)합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-118">For more information about Windows Communication Foundation, see [Windows Communication Foundation Services and WCF Data Services in Visual Studio](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio).</span></span>  
  
 <span data-ttu-id="5856f-119"><xref:System.Data.Linq.DataContext> 및 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 런타임 이벤트에 후크할 엔터티 클래스에 부분 클래스 및 메서드를 사용하여 비즈니스 규칙 또는 다른 도메인별 논리를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-119">Implement your business rules or other domain-specific logic by using the partial classes and methods on the <xref:System.Data.Linq.DataContext> and entity classes to hook into [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] runtime events.</span></span> <span data-ttu-id="5856f-120">자세한 내용은 참조 [N 계층 비즈니스 논리 구현](../../../../../../docs/framework/data/adonet/sql/linq/implementing-business-logic-linq-to-sql.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-120">For more information, see [Implementing N-Tier Business Logic](../../../../../../docs/framework/data/adonet/sql/linq/implementing-business-logic-linq-to-sql.md).</span></span>  
  
## <a name="defining-the-serializable-types"></a><span data-ttu-id="5856f-121">Serializable 형식 정의</span><span class="sxs-lookup"><span data-stu-id="5856f-121">Defining the Serializable Types</span></span>  
 <span data-ttu-id="5856f-122">클라이언트나 프레젠테이션 계층에는 중간 계층으로부터 수신할 클래스의 형식 정의가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-122">The client or presentation tier must have type definitions for the classes that it will be receiving from the middle tier.</span></span> <span data-ttu-id="5856f-123">이러한 형식은 엔터티 클래스 자체이거나 원격 작업을 위해 엔터티 클래스의 특정 필드만 래핑하는 특수 클래스일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-123">Those types may be the entity classes themselves, or special classes that wrap only certain fields from the entity classes for remoting.</span></span> <span data-ttu-id="5856f-124">어떤 경우든 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]은 프레젠테이션 계층이 이러한 형식 정의를 어떤 방법으로 가져오는지 전혀 고려하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-124">In any case, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is completely unconcerned about how the presentation tier acquires those type definitions.</span></span> <span data-ttu-id="5856f-125">예를 들어 프레젠테이션 계층에서는 WCF를 사용하여 형식을 자동으로 생성하거나, 이러한 형식이 정의되어 있는 DLL의 복사본을 가지고 있거나, 형식에 대한 고유한 버전을 직접 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-125">For example, the presentation tier could use WCF to generate the types automatically, or it could have a copy of a DLL in which those types are defined, or it could just define its own versions of the types.</span></span>  
  
## <a name="retrieving-and-inserting-data"></a><span data-ttu-id="5856f-126">데이터 검색 및 삽입</span><span class="sxs-lookup"><span data-stu-id="5856f-126">Retrieving and Inserting Data</span></span>  
 <span data-ttu-id="5856f-127">중간 계층에서는 프레젠테이션 계층에서 데이터에 액세스하는 방법을 지정하는 인터페이스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-127">The middle tier defines an interface that specifies how the presentation tier accesses the data.</span></span> <span data-ttu-id="5856f-128">예를 들면 `GetProductByID(int productID)` 또는 `GetCustomers()`와 같은 인터페이스를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-128">For example `GetProductByID(int productID)`, or `GetCustomers()`.</span></span> <span data-ttu-id="5856f-129">중간 계층에서 메서드 본문은 일반적으로 <xref:System.Data.Linq.DataContext>의 새 인스턴스를 만들고 하나 이상의 테이블에 대해 쿼리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-129">On the middle tier, the method body typically creates a new instance of the <xref:System.Data.Linq.DataContext>, executes a query against one or more of its table.</span></span> <span data-ttu-id="5856f-130">그런 다음 중간 계층에서는 결과를 <xref:System.Collections.Generic.IEnumerable%601>로 반환합니다. 여기에서 `T`는 엔터티 클래스이거나 serialization에 사용되는 다른 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-130">The middle tier then returns the result as an <xref:System.Collections.Generic.IEnumerable%601>, where `T` is either an entity class or another type that is used for serialization.</span></span> <span data-ttu-id="5856f-131">프레젠테이션 계층에서는 중간 계층을 대상으로 쿼리 변수를 직접 보내거나 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-131">The presentation tier never sends or receives query variables directly to or from the middle tier.</span></span> <span data-ttu-id="5856f-132">이 두 계층은 구체적인 데이터의 값, 개체 및 컬렉션을 교환합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-132">The two tiers exchange values, objects, and collections of concrete data.</span></span> <span data-ttu-id="5856f-133">프레젠테이션 계층에서는 컬렉션을 수신한 후 필요한 경우 [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] to Objects를 사용하여 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-133">After it has received a collection, the presentation tier can use [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] to Objects to query it if necessary.</span></span>  
  
 <span data-ttu-id="5856f-134">데이터를 삽입할 경우 프레젠테이션 계층에서는 새 개체를 만든 후 중간 계층에 보내거나, 중간 계층에서 개체를 만드는 데 사용할 기준 값을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-134">When inserting data, the presentation tier can construct a new object and send it to the middle tier, or it can have the middle tier construct the object based on values that it provides.</span></span> <span data-ttu-id="5856f-135">일반적으로 n 계층 응용 프로그램에서의 데이터 검색 및 삽입은 2계층 응용 프로그램에서의 해당 프로세스와 크게 다르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-135">In general, retrieving and inserting data in n-tier applications does not differ much from the process in 2-tier applications.</span></span> <span data-ttu-id="5856f-136">자세한 내용은 참조 [데이터베이스 쿼리](../../../../../../docs/framework/data/adonet/sql/linq/querying-the-database.md) 및 [및 데이터 변경 내용을 제출](../../../../../../docs/framework/data/adonet/sql/linq/making-and-submitting-data-changes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-136">For more information, see [Querying the Database](../../../../../../docs/framework/data/adonet/sql/linq/querying-the-database.md) and [Making and Submitting Data Changes](../../../../../../docs/framework/data/adonet/sql/linq/making-and-submitting-data-changes.md).</span></span>  
  
## <a name="tracking-changes-for-updates-and-deletes"></a><span data-ttu-id="5856f-137">업데이트 및 삭제 변경 사항 추적</span><span class="sxs-lookup"><span data-stu-id="5856f-137">Tracking Changes for Updates and Deletes</span></span>  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="5856f-138">은 RowVersions라고도 하는 타임스탬프 및 원래 값을 기반으로 하는 낙관적 동시성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-138"> supports optimistic concurrency based on timestamps (also named RowVersions) and on original values.</span></span> <span data-ttu-id="5856f-139">데이터베이스 테이블에 타임스탬프가 있는 경우에는 업데이트 및 삭제 시 중간 계층 또는 프레젠테이션 계층에서 약간의 추가 작업이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-139">If the database tables have timestamps, then updates and deletions require little extra work on either the middle-tier or presentation tier.</span></span> <span data-ttu-id="5856f-140">그러나 낙관적 동시성 검사에 원래 값을 사용해야 하는 경우에는 업데이트 시 이러한 값을 추적하고 다시 보내는 작업을 프레젠테이션 계층에서 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-140">However, if you must use original values for optimistic concurrency checks, then the presentation tier is responsible for tracking those values and sending them back when it makes updates.</span></span> <span data-ttu-id="5856f-141">그 이유는 프레젠테이션 계층에서 발생한 엔터티 변경 사항을 중간 계층에서 추적하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-141">This is because changes that were made to entities on the presentation tier are not tracked on the middle tier.</span></span> <span data-ttu-id="5856f-142">실제로 엔터티에 대한 최초 검색과 엔터티에 대한 이후 업데이트는 일반적으로 <xref:System.Data.Linq.DataContext>의 완전하게 다른 두 개별 인스턴스를 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-142">In fact, the original retrieval of an entity, and the eventual update made to it are typically performed by two completely separate instances of the <xref:System.Data.Linq.DataContext>.</span></span>  
  
 <span data-ttu-id="5856f-143">프레젠테이션 계층에서 변경하는 내용이 많을수록 변경 사항을 추적하고 패키지화하여 중간 계층에 다시 보내기가 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-143">The greater the number of changes that the presentation tier makes, the more complex it becomes to track those changes and package them back to the middle tier.</span></span> <span data-ttu-id="5856f-144">변경 사항 통신 메커니즘은 응용 프로그램에 따라 다르게 구현되지만</span><span class="sxs-lookup"><span data-stu-id="5856f-144">The implementation of a mechanism for communicating changes is completely up to the application.</span></span> <span data-ttu-id="5856f-145">낙관적 동시성 검사에 필요한 원래 값을 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]에 반드시 제공해야 한다는 점은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-145">The only requirement is that [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] must be given those original values that are required for optimistic concurrency checks.</span></span>  
  
 <span data-ttu-id="5856f-146">자세한 내용은 참조 [데이터 검색 및 CUD 작업 N 계층 응용 프로그램 (LINQ to SQL)에서](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="5856f-146">For more information, see [Data Retrieval and CUD Operations in N-Tier Applications (LINQ to SQL)](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5856f-147">참고 항목</span><span class="sxs-lookup"><span data-stu-id="5856f-147">See Also</span></span>  
 [<span data-ttu-id="5856f-148">LINQ to SQL을 사용한 N 계층 및 원격 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="5856f-148">N-Tier and Remote Applications with LINQ to SQL</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/n-tier-and-remote-applications-with-linq-to-sql.md)  
 [<span data-ttu-id="5856f-149">NIB: LinqDataSource 웹 서버 컨트롤 개요</span><span class="sxs-lookup"><span data-stu-id="5856f-149">NIB: LinqDataSource Web Server Control Overview</span></span>](http://msdn.microsoft.com/en-us/104cfc3f-7385-47d3-8a51-830dfa791136)

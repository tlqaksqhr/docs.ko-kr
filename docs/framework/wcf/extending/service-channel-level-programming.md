---
title: "서비스 채널 수준 프로그래밍"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
ms.assetid: 8d8dcd85-0a05-4c44-8861-4a0b3b90cca9
caps.latest.revision: "9"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: e296cc2d8960280c6af278a79eaeaa3984f07eff
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/18/2017
---
# <a name="service-channel-level-programming"></a><span data-ttu-id="c7798-102">서비스 채널 수준 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c7798-102">Service Channel-Level Programming</span></span>
<span data-ttu-id="c7798-103">이 항목에서는 [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] 및 관련 개체 모델을 사용하지 않고 <xref:System.ServiceModel.ServiceHost?displayProperty=nameWithType> 서비스 응용 프로그램을 작성하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-103">This topic describes how to write a [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] service application without using the <xref:System.ServiceModel.ServiceHost?displayProperty=nameWithType> and its associated object model.</span></span>  
  
## <a name="receiving-messages"></a><span data-ttu-id="c7798-104">메시지 받기</span><span class="sxs-lookup"><span data-stu-id="c7798-104">Receiving Messages</span></span>  
 <span data-ttu-id="c7798-105">메시지를 받은 다음 처리할 준비를 하려면 다음 단계가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-105">To be ready to receive and process messages, the following steps are required:</span></span>  
  
1.  <span data-ttu-id="c7798-106">바인딩을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-106">Create a binding.</span></span>  
  
2.  <span data-ttu-id="c7798-107">채널 수신기를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-107">Build a channel listener.</span></span>  
  
3.  <span data-ttu-id="c7798-108">채널 수신기를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-108">Open the channel listener.</span></span>  
  
4.  <span data-ttu-id="c7798-109">요청을 읽고 회신을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-109">Read the request and send a reply.</span></span>  
  
5.  <span data-ttu-id="c7798-110">모든 채널 개체를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-110">Close all channel objects.</span></span>  
  
#### <a name="creating-a-binding"></a><span data-ttu-id="c7798-111">바인딩 만들기</span><span class="sxs-lookup"><span data-stu-id="c7798-111">Creating a Binding</span></span>  
 <span data-ttu-id="c7798-112">메시지를 수신 대기하고 받는 첫 번째 단계는 바인딩을 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-112">The first step in listening for and receiving messages is creating a binding.</span></span> [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="c7798-113">에는 내장된 또는 시스템에서 제공한 여러 바인딩이 있으며, 이 중 하나를 인스턴스화하여 즉시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-113"> ships with several built-in or system-provided bindings that can be used directly by instantiating one of them.</span></span> <span data-ttu-id="c7798-114">또한 목록 1의 코드가 수행하는 작업인 CustomBinding 클래스를 인스턴스화하여 사용자 지정 바인딩을 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-114">In addition, you can also create your own custom binding by instantiating a CustomBinding class which is what the code in listing 1 does.</span></span>  
  
 <span data-ttu-id="c7798-115">아래의 코드 예제에서는 <xref:System.ServiceModel.Channels.CustomBinding?displayProperty=nameWithType>의 인스턴스를 만들고 <xref:System.ServiceModel.Channels.HttpTransportBindingElement?displayProperty=nameWithType>를 채널 스택을 빌드하는 데 사용되는 바인딩 요소의 컬렉션인 해당 요소 컬렉션에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-115">The code example below creates an instance of <xref:System.ServiceModel.Channels.CustomBinding?displayProperty=nameWithType> and adds an <xref:System.ServiceModel.Channels.HttpTransportBindingElement?displayProperty=nameWithType> to its Elements collection which is a collection of binding elements that are used to build the channel stack.</span></span> <span data-ttu-id="c7798-116">이 예제에서는 요소 컬렉션에 <xref:System.ServiceModel.Channels.HttpTransportBindingElement>만 있으므로 결과 채널 스택에는 HTTP 전송 채널만 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-116">In this example, because the elements collection has only the <xref:System.ServiceModel.Channels.HttpTransportBindingElement>, the resulting channel stack has only the HTTP transport channel.</span></span>  
  
#### <a name="building-a-channellistener"></a><span data-ttu-id="c7798-117">ChannelListener 빌드</span><span class="sxs-lookup"><span data-stu-id="c7798-117">Building a ChannelListener</span></span>  
 <span data-ttu-id="c7798-118">바인딩을 만든 후 이라고 <!--zz<xref:System.ServiceModel.Channels.Binding.BuildChannelListener%601%2A?displayProperty=nameWithType>--> `System.ServiceModel.Channels.Binding.BuildChannelListener` 형식 매개 변수가 만들 채널 셰이프 인 채널 수신기를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-118">After creating a binding, we call <!--zz<xref:System.ServiceModel.Channels.Binding.BuildChannelListener%601%2A?displayProperty=nameWithType>--> `System.ServiceModel.Channels.Binding.BuildChannelListener` to build the channel listener where the type parameter is the channel shape to create.</span></span> <span data-ttu-id="c7798-119">이 예제에서는 요청/회신 메시지 교환 패턴으로 들어오는 메시지를 수신 대기하려고 하므로 <xref:System.ServiceModel.Channels.IReplyChannel?displayProperty=nameWithType>을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-119">In this example we are using <xref:System.ServiceModel.Channels.IReplyChannel?displayProperty=nameWithType> because we want to listen for incoming messages in a request/reply message exchange pattern.</span></span>  
  
 <span data-ttu-id="c7798-120"><xref:System.ServiceModel.Channels.IReplyChannel>은 요청 메시지를 받고 회신 메시지를 다시 보내는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-120"><xref:System.ServiceModel.Channels.IReplyChannel> is used for receiving request messages and sending back reply messages.</span></span> <span data-ttu-id="c7798-121"><xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A?displayProperty=nameWithType>를 호출하면 요청 메시지를 받고 회신 메시지를 다시 보내는 데 사용할 수 있는 <xref:System.ServiceModel.Channels.IRequestChannel?displayProperty=nameWithType>을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-121">Calling <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A?displayProperty=nameWithType> returns an <xref:System.ServiceModel.Channels.IRequestChannel?displayProperty=nameWithType>, which can be used to receive the request message and to send back a reply message.</span></span>  
  
 <span data-ttu-id="c7798-122">수신기를 만들 때 수신하는 네트워크 주소를 전달합니다. 이 경우는 `http://localhost:8080/channelapp`입니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-122">When creating the listener, we pass the network address on which it listens, in this case `http://localhost:8080/channelapp`.</span></span> <span data-ttu-id="c7798-123">일반적으로 각 전송 채널은 하나 또는 여러 개의 주소 스키마를 지원합니다. 예를 들면 HTTP 전송은 http와 https 스키마를 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-123">In general, each transport channel supports one or possibly several address schemes, for example, the HTTP transport supports both http and https schemes.</span></span>  
  
 <span data-ttu-id="c7798-124">또한 수신기를 만들 때 빈 <xref:System.ServiceModel.Channels.BindingParameterCollection?displayProperty=nameWithType>을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-124">We also pass an empty <xref:System.ServiceModel.Channels.BindingParameterCollection?displayProperty=nameWithType> when creating the listener.</span></span> <span data-ttu-id="c7798-125">바인딩 매개 변수는 수신기가 빌드되는 방식을 제어하는 매개 변수를 전달하는 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-125">A binding parameter is a mechanism to pass parameters that control how the listener should be built.</span></span> <span data-ttu-id="c7798-126">예제에서는 그러한 매개 변수를 사용하지 않으므로 빈 컬렉션을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-126">In our example, we are not using any such parameters so we pass an empty collection.</span></span>  
  
#### <a name="listening-for-incoming-messages"></a><span data-ttu-id="c7798-127">들어오는 메시지 수신 대기</span><span class="sxs-lookup"><span data-stu-id="c7798-127">Listening for Incoming Messages</span></span>  
 <span data-ttu-id="c7798-128">수신기에서 <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType>을 호출하고 채널을 수락합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-128">We then call <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> on the listener and start accepting channels.</span></span> <span data-ttu-id="c7798-129"><xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>의 동작은 전송이 연결 지향인지, 연결 지양인지에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-129">The behavior of <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType> depends on whether the transport is connection-oriented or connection-less.</span></span> <span data-ttu-id="c7798-130">연결 지향 전송에서 <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A>은 새 연결 요청이 들어올 때까지 차단됩니다. 이 시점에서 새 연결을 나타내는 새 채널을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-130">For connection-oriented transports, <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A> blocks until a new connection request comes in at which point it returns a new channel that represents that new connection.</span></span> <span data-ttu-id="c7798-131">HTTP와 같은 연결 지양 전송에서 <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A>은 전송 수신기가 만드는 유일한 채널과 함께 즉시 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-131">For connection-less transports, such as HTTP, <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A> returns immediately with the one and only channel that the transport listener creates.</span></span>  
  
 <span data-ttu-id="c7798-132">이 예제에서 수신기는 <xref:System.ServiceModel.Channels.IReplyChannel>을 구현하는 채널을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-132">In this example, the listener returns a channel that implements <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span> <span data-ttu-id="c7798-133">이 채널에서 메시지를 받기 위해 먼저 <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType>을 호출하여 통신 준비 상태로 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-133">To receive messages on this channel we first call <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> on it to place it in a state ready for communication.</span></span> <span data-ttu-id="c7798-134">그런 다음 메시지가 도착할 때까지 차단되는 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-134">We then call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> which blocks until a message arrives.</span></span>  
  
#### <a name="reading-the-request-and-sending-a-reply"></a><span data-ttu-id="c7798-135">요청 읽기 및 회신 보내기</span><span class="sxs-lookup"><span data-stu-id="c7798-135">Reading the Request and Sending a Reply</span></span>  
 <span data-ttu-id="c7798-136"><xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>가 <xref:System.ServiceModel.Channels.RequestContext>를 반환하면 <xref:System.ServiceModel.Channels.RequestContext.RequestMessage%2A> 속성을 사용하여 받은 메시지를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-136">When <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> returns a <xref:System.ServiceModel.Channels.RequestContext>, we get the received message using its <xref:System.ServiceModel.Channels.RequestContext.RequestMessage%2A> property.</span></span> <span data-ttu-id="c7798-137">메시지 동작 및 본문 내용(문자열)을 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-137">We write out the message’s action and body content, (which we assume is a string).</span></span>  
  
 <span data-ttu-id="c7798-138">회신을 보내려면 이 경우 요청에서 받은 문자열 데이터를 다시 전달하는 새 회신 메시지를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-138">To send a reply, we create a new reply message in this case passing back the string data we received in the request.</span></span> <span data-ttu-id="c7798-139">그런 다음 <xref:System.ServiceModel.Channels.RequestContext.Reply%2A>를 호출하여 회신 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-139">We then call <xref:System.ServiceModel.Channels.RequestContext.Reply%2A> to send the reply message.</span></span>  
  
#### <a name="closing-objects"></a><span data-ttu-id="c7798-140">개체 닫기</span><span class="sxs-lookup"><span data-stu-id="c7798-140">Closing Objects</span></span>  
 <span data-ttu-id="c7798-141">리소스 누수를 방지하려면 통신에 사용된 개체가 더 이상 필요하지 않은 경우 그 개체를 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-141">To avoid leaking resources, it is very important to close objects used in communications when they are no longer required.</span></span> <span data-ttu-id="c7798-142">이 예제에서는 요청 메시지, 요청 컨텍스트, 채널 및 수신기를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-142">In this example we close the request message, the request context, the channel and the listener.</span></span>  
  
 <span data-ttu-id="c7798-143">다음 코드 예제에서는 채널 수신기가 한 메시지만 받는 기본 서비스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-143">The following code example shows a basic service in which a channel listener receives only one message.</span></span> <span data-ttu-id="c7798-144">실제 서비스는 서비스가 종료될 때까지 채널을 계속 수락하고 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="c7798-144">A real service keeps accepting channels and receiving messages until the service exits.</span></span>  
  
 [!code-csharp[ChannelProgrammingBasic#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/channelprogrammingbasic/cs/serviceprogram.cs#1)]
 [!code-vb[ChannelProgrammingBasic#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/channelprogrammingbasic/vb/serviceprogram.vb#1)]

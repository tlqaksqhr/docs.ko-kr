---
title: "대기 중인 통신을 위한 최선의 방법"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- queues [WCF], best practices
- best practices [WCF], queued communication
ms.assetid: 446a6383-cae3-4338-b193-a33c14a49948
caps.latest.revision: "14"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: db0506f6fbbda7758d4cbfc3624d68277a301268
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="best-practices-for-queued-communication"></a><span data-ttu-id="a7e61-102">대기 중인 통신을 위한 최선의 방법</span><span class="sxs-lookup"><span data-stu-id="a7e61-102">Best Practices for Queued Communication</span></span>
<span data-ttu-id="a7e61-103">이 항목에서는 [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]에서 대기 중인 통신에 대해 권장되는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-103">This topic provides recommended practices for queued communication in [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].</span></span> <span data-ttu-id="a7e61-104">다음 단원에서는 시나리오 측면에서 권장되는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-104">The following sections discuss recommended practices from a scenario perspective.</span></span>  
  
## <a name="fast-best-effort-queued-messaging"></a><span data-ttu-id="a7e61-105">신속하고 가장 효율적인 대기 중인 메시징</span><span class="sxs-lookup"><span data-stu-id="a7e61-105">Fast, Best-Effort Queued Messaging</span></span>  
 <span data-ttu-id="a7e61-106">대기 중인 메시징이 제공하는 분리와 가장 효율적인 보증 작업을 통해 신속하고도 고성능인 메시징이 필요한 시나리오의 경우, 비트랜잭션 큐를 사용하여 <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> 속성을 `false`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-106">For scenarios that require separation that queued messaging provides and fast, high-performance messaging with best-effort assurances, use a non-transactional queue and set the <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> property to `false`.</span></span>  
  
 <span data-ttu-id="a7e61-107">또한 <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> 속성을 `false`로 설정하여 디스크 쓰기 비용이 발생하지 않도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-107">In addition, you can choose not to incur the cost of disk writes by setting the <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property to `false`.</span></span>  
  
 <span data-ttu-id="a7e61-108">보안 작업은 성능에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-108">Security has implications on performance.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="a7e61-109">[성능 고려 사항](../../../../docs/framework/wcf/feature-details/performance-considerations.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-109"> [Performance Considerations](../../../../docs/framework/wcf/feature-details/performance-considerations.md).</span></span>  
  
## <a name="reliable-end-to-end-queued-messaging"></a><span data-ttu-id="a7e61-110">신뢰할 수 있는 종단 간 대기 중인 메시징</span><span class="sxs-lookup"><span data-stu-id="a7e61-110">Reliable End-to-End Queued Messaging</span></span>  
 <span data-ttu-id="a7e61-111">다음 단원에서는 종단 간 신뢰할 수 있는 메시징이 필요한 시나리오에 대해 권장되는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-111">The following sections describe recommended practices for scenarios that require end-to-end reliable messaging.</span></span>  
  
### <a name="basic-reliable-transfer"></a><span data-ttu-id="a7e61-112">기본적으로 신뢰할 수 있는 전송</span><span class="sxs-lookup"><span data-stu-id="a7e61-112">Basic Reliable Transfer</span></span>  
 <span data-ttu-id="a7e61-113">종단 간 안정성을 위해 <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> 속성을 `true`로 설정하여 전송을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-113">For end-to-end reliability, set the <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> property to `true` to ensure transfer.</span></span> <span data-ttu-id="a7e61-114">요구 사항에 따라 <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> 속성을 `true` 또는 `false`로 설정할 수 있습니다. 기본값은 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-114">The <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property can be set to `true` or `false` depending on your requirements (the default is `true`).</span></span> <span data-ttu-id="a7e61-115">종단 간 안정성을 위한 작업 중 하나로, 보통 <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> 속성은 `true`로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-115">Generally, the <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property is set to `true` as part of end-to-end reliability.</span></span> <span data-ttu-id="a7e61-116">성능을 유지하는 데 많은 노력이 필요하더라도 해당 메시지를 지속적으로 만들어 큐 관리자가 손상된 경우에도 메시지가 손실되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-116">The compromise is a performance cost, but makes the message durable so that the message is not lost if a queue manager crashes.</span></span>  
  
### <a name="use-of-transactions"></a><span data-ttu-id="a7e61-117">트랜잭션 사용</span><span class="sxs-lookup"><span data-stu-id="a7e61-117">Use of Transactions</span></span>  
 <span data-ttu-id="a7e61-118">트랜잭션을 사용하여 종단 간 신뢰성을 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-118">You must use transactions to ensure end-to-end reliability.</span></span> <span data-ttu-id="a7e61-119">`ExactlyOnce` 보증은 메시지가 대상 큐에 배달되었는지만 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-119">`ExactlyOnce` assurances only ensure that messages are delivered to the target queue.</span></span> <span data-ttu-id="a7e61-120">메시지가 수신되는 것을 보장하려면 트랜잭션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-120">To ensure that the message is received, use transactions.</span></span> <span data-ttu-id="a7e61-121">트랜잭션을 사용하지 않고 서비스가 손상될 경우, 배달되는 메시지가 손실되지만 실제 응용 프로그램에 배달됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-121">Without transactions, if the service crashes, you lose the message that is being delivered but is actually delivered to the application.</span></span>  
  
### <a name="use-of-dead-letter-queues"></a><span data-ttu-id="a7e61-122">배달 못 한 편지 큐 사용</span><span class="sxs-lookup"><span data-stu-id="a7e61-122">Use of Dead-letter Queues</span></span>  
 <span data-ttu-id="a7e61-123">배달 못 한 편지 큐는 메시지가 대상 큐에 배달되지 못하는 경우 사용자에게 이를 알리는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-123">Dead-letter queues ensure that you are notified if a message fails to be delivered to the target queue.</span></span> <span data-ttu-id="a7e61-124">시스템 제공 배달 못 한 편지 큐 또는 사용자 지정 배달 못 한 편지 큐를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-124">You can use the system-provided dead-letter queue or a custom dead-letter queue.</span></span> <span data-ttu-id="a7e61-125">일반적으로 사용자 지정 배달 못 한 편지 큐를 사용하는 것이 가장 좋은 방법입니다. 이 큐를 사용하면 응용 프로그램에서 단일 배달 못 한 편지 큐로 배달 못 한 메시지를 보낼 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-125">In general, using a custom dead-letter queue is best because it enables you to send dead-letter messages from one application into a single dead-letter queue.</span></span> <span data-ttu-id="a7e61-126">그렇지 않을 경우 시스템에서 실행 중인 모든 응용 프로그램에 대해 발생하는 모든 배달 못 한 메시지가 단일 큐에 배달됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-126">Otherwise, all dead-letter messages that occur for all applications running on the system are delivered to a single queue.</span></span> <span data-ttu-id="a7e61-127">그러면 각 응용 프로그램은 배달 못 한 편지 큐를 검색하여 해당 응용 프로그램과 관련된 배달 못 한 메시지를 찾아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-127">Each application must then search though the dead-letter queue to find the dead-letter messages that are relevant to that application.</span></span> <span data-ttu-id="a7e61-128">가끔 MSMQ 3.0을 사용하는 경우처럼 사용자 지정 배달 못 한 편지 큐를 사용할 수 없는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-128">Sometimes, using a custom dead-letter queue is not feasible, such as when using MSMQ 3.0.</span></span>  
  
 <span data-ttu-id="a7e61-129">종단 간 신뢰할 수 있는 통신에 대해 배달 못 한 편지 큐 기능을 끄지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-129">Turning off dead-letter queues for end-to-end reliable communication is not recommended.</span></span>  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="a7e61-130">[메시지를 처리 하려면 배달 못 한 편지 큐를 사용 하 여 전송 오류](../../../../docs/framework/wcf/feature-details/using-dead-letter-queues-to-handle-message-transfer-failures.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-130"> [Using Dead-Letter Queues to Handle Message Transfer Failures](../../../../docs/framework/wcf/feature-details/using-dead-letter-queues-to-handle-message-transfer-failures.md).</span></span>  
  
### <a name="use-of-poison-message-handling"></a><span data-ttu-id="a7e61-131">포이즌 메시지 처리 사용</span><span class="sxs-lookup"><span data-stu-id="a7e61-131">Use of Poison-Message Handling</span></span>  
 <span data-ttu-id="a7e61-132">포이즌 메시지 처리는 오류를 복구하여 메시지를 처리하는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-132">Poison-message handling provides the ability to recover from the failure to process messages.</span></span>  
  
 <span data-ttu-id="a7e61-133">포이즌 메시지 처리 기능을 사용하는 경우 <xref:System.ServiceModel.MsmqBindingBase.ReceiveErrorHandling%2A> 속성이 적절한 값으로 설정되어 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-133">When using the poison-message handling feature, ensure that the <xref:System.ServiceModel.MsmqBindingBase.ReceiveErrorHandling%2A> property is set to the appropriate value.</span></span> <span data-ttu-id="a7e61-134"><xref:System.ServiceModel.ReceiveErrorHandling.Drop>으로 설정할 경우 데이터가 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-134">Setting it to <xref:System.ServiceModel.ReceiveErrorHandling.Drop> means the data is lost.</span></span> <span data-ttu-id="a7e61-135">반면에 <xref:System.ServiceModel.ReceiveErrorHandling.Fault>로 설정하면 포이즌 메시지를 감지할 때 서비스 호스트에 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-135">On the other hand, setting it to <xref:System.ServiceModel.ReceiveErrorHandling.Fault> faults the service host when it detects a poison message.</span></span> <span data-ttu-id="a7e61-136">MSMQ 3.0을 사용하는 경우 <xref:System.ServiceModel.ReceiveErrorHandling.Fault>가 데이터 손실을 방지하고 포이즌 메시지를 제거하기 위한 최상의 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-136">Using MSMQ 3.0, <xref:System.ServiceModel.ReceiveErrorHandling.Fault> is the best option to avoid data loss and move the poison message out of the way.</span></span> <span data-ttu-id="a7e61-137">MSMQ 4.0을 사용하는 경우 <xref:System.ServiceModel.ReceiveErrorHandling.Move> 방식을 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-137">Using MSMQ 4.0, <xref:System.ServiceModel.ReceiveErrorHandling.Move> is the recommended approach.</span></span> <span data-ttu-id="a7e61-138"><xref:System.ServiceModel.ReceiveErrorHandling.Move>는 큐에서 포이즌 메시지를 제거하여 서비스가 계속해서 새 메시지를 처리할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-138"><xref:System.ServiceModel.ReceiveErrorHandling.Move> moves a poisoned message out of the queue so the service can continue to process new messages.</span></span> <span data-ttu-id="a7e61-139">그러면 포이즌 메시지 서비스가 포이즌 메시지를 개별적으로 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-139">The poison-message service can then process the poison message separately.</span></span>  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="a7e61-140">[포이즌 메시지 처리](../../../../docs/framework/wcf/feature-details/poison-message-handling.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-140"> [Poison Message Handling](../../../../docs/framework/wcf/feature-details/poison-message-handling.md).</span></span>  
  
## <a name="achieving-high-throughput"></a><span data-ttu-id="a7e61-141">높은 처리량 달성</span><span class="sxs-lookup"><span data-stu-id="a7e61-141">Achieving High Throughput</span></span>  
 <span data-ttu-id="a7e61-142">단일 끝점에서 높은 처리량을 달성하려면 다음을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-142">To achieve high throughput on a single endpoint, use the following:</span></span>  
  
-   <span data-ttu-id="a7e61-143">트랜잭션된 일괄 처리.</span><span class="sxs-lookup"><span data-stu-id="a7e61-143">Transacted batching.</span></span> <span data-ttu-id="a7e61-144">트랜잭션된 일괄처리를 사용하면 많은 메시지를 단일 트랜잭션으로 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-144">Transacted batching ensures that many messages can be read in a single transaction.</span></span> <span data-ttu-id="a7e61-145">이를 통해 트랜잭션 커밋이 최적화되어 전체 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-145">This optimizes transaction commits, increasing overall performance.</span></span> <span data-ttu-id="a7e61-146">일괄 처리 비용은 일괄 처리 내의 단일 메시지에 오류가 발생하는 경우 발생하며 이러한 경우 전체 일괄 처리가 롤백되고, 일괄 처리가 다시 안전할 때까지 메시지를 한 번에 하나씩 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-146">The cost of batching is that if a failure occurs in a single message within a batch, then the entire batch is rolled back and the messages must be processed one at a time until it is safe to batch again.</span></span> <span data-ttu-id="a7e61-147">대부분의 경우 포이즌 메시지가 발생하는 경우는 드물기 때문에 일괄 처리는 특히 트랜잭션에 참여하는 다른 리소스 관리자가 있는 경우 시스템 성능 향상을 위한 기본적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-147">In most cases, poison messages are rare, so batching is the preferred way to increase system performance, particularly when you have other resource managers that participate in the transaction.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="a7e61-148">[트랜잭션에서 메시지 일괄 처리](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-148"> [Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md).</span></span>  
  
-   <span data-ttu-id="a7e61-149">동시성.</span><span class="sxs-lookup"><span data-stu-id="a7e61-149">Concurrency.</span></span> <span data-ttu-id="a7e61-150">동시성은 처리량을 증가시키지만 또한 공유 리소스를 사용하는 데 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-150">Concurrency increases throughput, but concurrency also affects contention to shared resources.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="a7e61-151">[동시성](../../../../docs/framework/wcf/samples/concurrency.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-151"> [Concurrency](../../../../docs/framework/wcf/samples/concurrency.md).</span></span>  
  
-   <span data-ttu-id="a7e61-152">스로틀.</span><span class="sxs-lookup"><span data-stu-id="a7e61-152">Throttling.</span></span> <span data-ttu-id="a7e61-153">최적의 성능을 위해 디스패처 파이프라인의 메시지 수를 조절합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-153">For optimal performance, throttle the number of messages in the dispatcher pipeline.</span></span> <span data-ttu-id="a7e61-154">이 작업을 수행 하는 방법의 예제를 보려면 [제한](../../../../docs/framework/wcf/samples/throttling.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-154">For an example of how to do this, see [Throttling](../../../../docs/framework/wcf/samples/throttling.md).</span></span>  
  
 <span data-ttu-id="a7e61-155">일괄 처리를 사용하는 경우 동시성 및 스로틀이 동시 일괄 처리로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-155">When using batching, be aware that concurrency and throttling translate to concurrent batches.</span></span>  
  
 <span data-ttu-id="a7e61-156">높은 처리량 및 가용성을 실현하기 위해 큐에서 읽은 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 서비스 팜을 사용하십시오.</span><span class="sxs-lookup"><span data-stu-id="a7e61-156">To achieve higher throughput and availability, use a farm of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services that read from the queue.</span></span> <span data-ttu-id="a7e61-157">이를 사용하려면 이러한 모든 서비스가 동일한 끝점에서 동일한 계약을 노출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-157">This requires that all of these services expose the same contract on the same endpoint.</span></span> <span data-ttu-id="a7e61-158">팜 접근 방식은 많은 서비스를 동일한 큐에서 모두 읽을 수 있기 때문에 생산율이 높은 메시지가 있는 응용 프로그램에 가장 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-158">The farm approach works best for applications that have high production rates of messages because it enables a number of services to all read from the same queue.</span></span>  
  
 <span data-ttu-id="a7e61-159">MSMQ 3.0에서 팜을 사용하는 경우 트랜잭션된 원격 읽기를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-159">When using farms, be aware that MSMQ 3.0 does not support remote transacted reads.</span></span> <span data-ttu-id="a7e61-160">MSMQ 4.0은 트랜잭션된 원격 읽기를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-160">MSMQ 4.0 does support remote transacted reads.</span></span>  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="a7e61-161">[트랜잭션에서 메시지 일괄 처리](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md) 및 [Windows Vista, Windows Server 2003 및 Windows XP에서 큐 기능의 차이점](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-161"> [Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md) and [Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md).</span></span>  
  
## <a name="queuing-with-unit-of-work-semantics"></a><span data-ttu-id="a7e61-162">작업 단위 의미 체계를 사용한 큐</span><span class="sxs-lookup"><span data-stu-id="a7e61-162">Queuing with Unit of Work Semantics</span></span>  
 <span data-ttu-id="a7e61-163">일부 시나리오의 경우 큐에서 메시지 그룹이 관련될 수 있기 때문에 이러한 메시지의 순서 지정이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-163">In some scenarios a group of messages in a queue may be related and, therefore, the ordering of these messages is significant.</span></span> <span data-ttu-id="a7e61-164">이러한 시나리오에서는 관련 메시지 그룹을 단일 단위로 함께 처리합니다. 즉, 모든 메시지가 성공적으로 처리되거나 모두 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-164">In such scenarios, process a group of related messages together as a single unit: either all of the messages are processed successfully or none are.</span></span> <span data-ttu-id="a7e61-165">이러한 동작을 구현하려면 큐가 있는 세션을 사용하십시오.</span><span class="sxs-lookup"><span data-stu-id="a7e61-165">To implement such behavior, use sessions with queues.</span></span>  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="a7e61-166">[세션에서 대기 중인된 메시지 그룹화](../../../../docs/framework/wcf/feature-details/grouping-queued-messages-in-a-session.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-166"> [Grouping Queued Messages in a Session](../../../../docs/framework/wcf/feature-details/grouping-queued-messages-in-a-session.md).</span></span>  
  
## <a name="correlating-request-reply-messages"></a><span data-ttu-id="a7e61-167">요청-회신 메시지 상호 연결</span><span class="sxs-lookup"><span data-stu-id="a7e61-167">Correlating Request-Reply Messages</span></span>  
 <span data-ttu-id="a7e61-168">일반적으로 큐는 단방향이지만 일부 시나리오에서는 수신한 회신을 이전에 보낸 요청과 상호 연결해야 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-168">Though queues are typically one-way, in some scenarios you may want to correlate a reply received to a request sent earlier.</span></span> <span data-ttu-id="a7e61-169">이러한 상호 연결이 필요한 경우 메시지에 상호 연결 정보가 포함된 자체 SOAP 메시지 헤더를 적용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-169">If you require such correlation, it is recommended that you apply your own SOAP message header that contains correlation information with the message.</span></span> <span data-ttu-id="a7e61-170">일반적으로 보낸 사람은 이 헤더를 메시지에 첨부하고 받는 사람은 메시지 처리 및 회신 큐에 새 메시지로 다시 회신할 때 상호 연결 정보가 포함된 보낸 사람의 메시지 헤더를 첨부하여 보낸 사람이 요청 메시지를 통해 회신 메시지를 식별할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-170">Typically, the sender attaches this header with the message, and the receiver, upon processing the message and replying back with a new message on a reply queue, attaches the sender's message header that contains the correlation information so that the sender can identify the reply message with the request message.</span></span>  
  
## <a name="integrating-with-non-wcf-applications"></a><span data-ttu-id="a7e61-171">비WCF 응용 프로그램과 통합</span><span class="sxs-lookup"><span data-stu-id="a7e61-171">Integrating with Non-WCF Applications</span></span>  
 <span data-ttu-id="a7e61-172">`MsmqIntegrationBinding` 서비스 또는 클라이언트를 비[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 서비스 또는 클라이언트와 통합하는 경우 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-172">Use `MsmqIntegrationBinding` when integrating [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services or clients with non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services or clients.</span></span> <span data-ttu-id="a7e61-173">비[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 응용 프로그램은 System.Messaging, COM+, [!INCLUDE[vbprvb](../../../../includes/vbprvb-md.md)] 또는 C++를 사용하여 작성한 MSMQ 응용프로그램일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-173">The non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] application can be an MSMQ application written using System.Messaging, COM+, [!INCLUDE[vbprvb](../../../../includes/vbprvb-md.md)], or C++.</span></span>  
  
 <span data-ttu-id="a7e61-174">`MsmqIntegrationBinding`을 사용하는 경우 다음 사항에 주의하십시오.</span><span class="sxs-lookup"><span data-stu-id="a7e61-174">When using `MsmqIntegrationBinding`, be aware of the following:</span></span>  
  
-   <span data-ttu-id="a7e61-175">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 메시지 본문은 MSMQ 메시지 본문과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-175">A [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message body is not the same as a MSMQ message body.</span></span> <span data-ttu-id="a7e61-176">대기 중인 바인딩을 사용하여 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 메시지를 보내는 경우 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 메시지 본문이 MSMQ 메시지 내부에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-176">When sending a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message using a queued binding, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message body is placed inside of a MSMQ message.</span></span> <span data-ttu-id="a7e61-177">MSMQ 인프라는 이러한 추가 정보를 인식하지 못하고 MSMQ 메시지만 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-177">The MSMQ infrastructure is oblivious to this extra information; it sees only the MSMQ message.</span></span>  
  
-   <span data-ttu-id="a7e61-178">`MsmqIntegrationBinding`은 가장 많이 사용하는 serialization 형식을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-178">`MsmqIntegrationBinding` supports popular serialization types.</span></span> <span data-ttu-id="a7e61-179">serialization 형식에 기반한 일반 메시지의 본문 형식인 <xref:System.ServiceModel.MsmqIntegration.MsmqMessage%601>은 다른 형식의 매개 변수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-179">Based on the serialization type, the body type of the generic message, <xref:System.ServiceModel.MsmqIntegration.MsmqMessage%601>, takes different type parameters.</span></span> <span data-ttu-id="a7e61-180">예를 들어 <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat.ByteArray>는 `MsmqMessage\<byte[]>`가 필요하고 <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat.Stream>은 `MsmqMessage<Stream>`이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-180">For example, <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat.ByteArray> requires `MsmqMessage\<byte[]>` and <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat.Stream> requires `MsmqMessage<Stream>`.</span></span>  
  
-   <span data-ttu-id="a7e61-181">XML 직렬화에 지정할 수 있습니다를 사용 하 여 알려진된 형식은 `KnownTypes` 특성에 [ \<동작 >](../../../../docs/framework/configure-apps/file-schema/wcf/behavior-of-servicebehaviors.md) 는 다음 XML 메시지를 deserialize 하는 방법을 결정 하는 데 사용 되는 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="a7e61-181">With XML serialization, you can specify the known type using the `KnownTypes` attribute on the [\<behavior>](../../../../docs/framework/configure-apps/file-schema/wcf/behavior-of-servicebehaviors.md) element that is then used to determine how to deserialize the XML message.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a7e61-182">참고 항목</span><span class="sxs-lookup"><span data-stu-id="a7e61-182">See Also</span></span>  
 [<span data-ttu-id="a7e61-183">WCF의 큐</span><span class="sxs-lookup"><span data-stu-id="a7e61-183">Queuing in WCF</span></span>](../../../../docs/framework/wcf/feature-details/queuing-in-wcf.md)  
 [<span data-ttu-id="a7e61-184">방법: 대기 중인 WCF 끝점으로 메시지를 교환</span><span class="sxs-lookup"><span data-stu-id="a7e61-184">How to: Exchange Queued Messages with WCF Endpoints</span></span>](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md)  
 [<span data-ttu-id="a7e61-185">방법: WCF 끝점을 사용 하 여 메시지를 교환 하 고 메시지의 큐 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="a7e61-185">How to: Exchange Messages with WCF Endpoints and Message Queuing Applications</span></span>](../../../../docs/framework/wcf/feature-details/how-to-exchange-messages-with-wcf-endpoints-and-message-queuing-applications.md)  
 [<span data-ttu-id="a7e61-186">세션에서 대기 중인 메시지 그룹화</span><span class="sxs-lookup"><span data-stu-id="a7e61-186">Grouping Queued Messages in a Session</span></span>](../../../../docs/framework/wcf/feature-details/grouping-queued-messages-in-a-session.md)  
 [<span data-ttu-id="a7e61-187">트랜잭션에서 메시지 일괄 처리</span><span class="sxs-lookup"><span data-stu-id="a7e61-187">Batching Messages in a Transaction</span></span>](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)  
 [<span data-ttu-id="a7e61-188">배달 못 한 편지 큐를 사용 하 여 메시지 전송 오류 처리</span><span class="sxs-lookup"><span data-stu-id="a7e61-188">Using Dead-Letter Queues to Handle Message Transfer Failures</span></span>](../../../../docs/framework/wcf/feature-details/using-dead-letter-queues-to-handle-message-transfer-failures.md)  
 [<span data-ttu-id="a7e61-189">포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="a7e61-189">Poison Message Handling</span></span>](../../../../docs/framework/wcf/feature-details/poison-message-handling.md)  
 [<span data-ttu-id="a7e61-190">Windows Vista, Windows Server 2003 및 Windows XP에서 큐 기능 차이점</span><span class="sxs-lookup"><span data-stu-id="a7e61-190">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)  
 [<span data-ttu-id="a7e61-191">전송 보안을 사용 하 여 메시지 보안</span><span class="sxs-lookup"><span data-stu-id="a7e61-191">Securing Messages Using Transport Security</span></span>](../../../../docs/framework/wcf/feature-details/securing-messages-using-transport-security.md)  
 [<span data-ttu-id="a7e61-192">메시지 보안을 사용 하 여 메시지 보안</span><span class="sxs-lookup"><span data-stu-id="a7e61-192">Securing Messages Using Message Security</span></span>](../../../../docs/framework/wcf/feature-details/securing-messages-using-message-security.md)  
 [<span data-ttu-id="a7e61-193">대기 중인 메시지 문제 해결</span><span class="sxs-lookup"><span data-stu-id="a7e61-193">Troubleshooting Queued Messaging</span></span>](../../../../docs/framework/wcf/feature-details/troubleshooting-queued-messaging.md)

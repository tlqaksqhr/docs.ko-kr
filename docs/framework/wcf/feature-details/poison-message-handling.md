---
title: 포이즌 메시지 처리
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 8d1c5e5a-7928-4a80-95ed-d8da211b8595
caps.latest.revision: 29
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: 6fa35209b2dafc088605848a0dc96a53a2813dfd
ms.sourcegitcommit: 94d33cadc5ff81d2ac389bf5f26422c227832052
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/30/2018
---
# <a name="poison-message-handling"></a><span data-ttu-id="1a49a-102">포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="1a49a-102">Poison Message Handling</span></span>
<span data-ttu-id="1a49a-103">A *포이즌 메시지* 를 응용 프로그램에 배달 시도 최대 횟수를 초과한 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-103">A *poison message* is a message that has exceeded the maximum number of delivery attempts to the application.</span></span> <span data-ttu-id="1a49a-104">큐 기반 응용 프로그램에서 오류로 인해 메시지를 처리할 수 없는 경우 이러한 상황이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-104">This situation can arise when a queue-based application cannot process a message because of errors.</span></span> <span data-ttu-id="1a49a-105">안정성 요청을 충족하려면 대기 중인 응용 프로그램이 트랜잭션에서 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-105">To meet reliability demands, a queued application receives messages under a transaction.</span></span> <span data-ttu-id="1a49a-106">대기 중인 메시지를 받은 트랜잭션을 중단하면 메시지가 큐에 남으므로 새 트랜잭션에서 해당 메시지가 다시 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-106">Aborting the transaction in which a queued message was received leaves the message in the queue so that the message is retried under a new transaction.</span></span> <span data-ttu-id="1a49a-107">트랜잭션의 중단 문제가 해결되지 않은 경우에는 수신 응용 프로그램이 최대 전달 시도 횟수를 초과할 때까지 같은 메시지를 받고 중단하는 루프에 갇히고, 포이즌 메시지가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-107">If the problem that caused the transaction to abort is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until the maximum number of delivery attempts has been exceeded and a poison message results.</span></span>  
  
 <span data-ttu-id="1a49a-108">메시지는 여러 가지 이유로 포이즌 메시지가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-108">A message can become a poison message for many reasons.</span></span> <span data-ttu-id="1a49a-109">가장 일반적인 이유는 응용 프로그램마다 고유하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-109">The most common reasons are application specific.</span></span> <span data-ttu-id="1a49a-110">예를 들어 응용 프로그램이 큐에서 메시지를 읽고 일부 데이터베이스 처리를 수행하면 응용 프로그램이 데이터베이스에 대한 잠금을 얻지 못해 트랜잭션이 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-110">For example, if an application reads a message from a queue and performs some database processing, the application may fail to get a lock on the database, causing it to abort the transaction.</span></span> <span data-ttu-id="1a49a-111">데이터베이스 트랜잭션이 중단되었기 때문에 메시지가 큐에 남아 있으며 이로 인해 두 번째에서는 응용 프로그램이 메시지를 다시 읽고 데이터베이스에 대한 잠금을 얻도록 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-111">Because the database transaction was aborted, the message remains in the queue, which causes the application to reread the message a second time and make another attempt to acquire a lock on the database.</span></span> <span data-ttu-id="1a49a-112">메시지에 잘못된 정보가 들어 있는 경우 해당 메시지는 포이즌 메시지가 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-112">Messages can also become poison if they contain invalid information.</span></span> <span data-ttu-id="1a49a-113">예를 들면, 구매 주문서에 잘못된 고객 번호가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-113">For example, a purchase order may contain an invalid customer number.</span></span> <span data-ttu-id="1a49a-114">이 경우 응용 프로그램이 트랜잭션을 중단하고 메시지가 포이즌 메시지가 되도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-114">In these cases, the application may voluntarily abort the transaction and force the message to become a poison message.</span></span>  
  
 <span data-ttu-id="1a49a-115">경우에 따라 메시지가 응용 프로그램에 디스패치되지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-115">On rare occasions, messages can fail to get dispatched to the application.</span></span> <span data-ttu-id="1a49a-116">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] 계층에서 메시지에 잘못된 프레임이 있거나, 잘못된 메시지 자격 증명이 연결되어 있거나, 잘못된 동작 헤더가 있는 것처럼 메시지에 문제가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-116">The [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] layer may find a problem with the message, such as if the message has the wrong frame, invalid message credentials attached to it, or an invalid action header.</span></span> <span data-ttu-id="1a49a-117">이러한 경우 응용 프로그램이 메시지를 받지는 않지만 메시지가 포이즌 메시지가 될 수 있으며 그러한 메시지는 수동으로 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-117">In these cases, the application never receives the message; however, the message can still become a poison message and be processed manually.</span></span>  
  
## <a name="handling-poison-messages"></a><span data-ttu-id="1a49a-118">포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="1a49a-118">Handling Poison Messages</span></span>  
 <span data-ttu-id="1a49a-119">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]에서 포이즌 메시지 처리는 응용 프로그램에 디스패치할 수 없는 메시지나 응용 프로그램에 디스패치할 수 있지만 응용 프로그램의 고유한 이유로 인해 처리하지 못한 메시지를 처리할 수신 응용 프로그램에 대한 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-119">In [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], poison message handling provides a mechanism for a receiving application to deal with messages that cannot be dispatched to the application, or messages that are dispatched to the application but which fail to be processed because of application-specific reasons.</span></span> <span data-ttu-id="1a49a-120">포이즌 메시지 처리는 대기 중인 사용 가능한 각 바인딩에서 다음 속성으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-120">Poison message handling is configured by the following properties in each of the available queued bindings:</span></span>  
  
-   <span data-ttu-id="1a49a-121">`ReceiveRetryCount`.</span><span class="sxs-lookup"><span data-stu-id="1a49a-121">`ReceiveRetryCount`.</span></span> <span data-ttu-id="1a49a-122">응용 프로그램 큐에서 응용 프로그램으로 메시지 전달을 다시 시도하는 최대 횟수를 나타내는 정수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-122">An integer value that indicates the maximum number of times to retry delivery of a message from the application queue to the application.</span></span> <span data-ttu-id="1a49a-123">기본값은 5입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-123">The default value is 5.</span></span> <span data-ttu-id="1a49a-124">이 값은 데이터베이스의 임시 교착 상태처럼 문제 해결을 즉시 다시 시도하는 경우 충분합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-124">This is sufficient in cases where an immediate retry fixes the problem, such as with a temporary deadlock on a database.</span></span>  
  
-   <span data-ttu-id="1a49a-125">`MaxRetryCycles`.</span><span class="sxs-lookup"><span data-stu-id="1a49a-125">`MaxRetryCycles`.</span></span> <span data-ttu-id="1a49a-126">최대 재시도 주기 수를 나타내는 정수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-126">An integer value that indicates the maximum number of retry cycles.</span></span> <span data-ttu-id="1a49a-127">재시도 주기는 응용 프로그램 큐에서 재시도 하위 큐로 메시지를 전송하고, 구성 가능한 지연 시간 이후 재시도 하위 큐에서 전달을 다시 시도할 응용 프로그램 큐로 메시지를 다시 전송하는 것으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-127">A retry cycle consists of transferring a message from the application queue to the retry subqueue and, after a configurable delay, from the retry subqueue back into the application queue to reattempt delivery.</span></span> <span data-ttu-id="1a49a-128">기본값은 2입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-128">The default value is 2.</span></span> <span data-ttu-id="1a49a-129">[!INCLUDE[wv](../../../../includes/wv-md.md)]에서는 메시지가 최대 (`ReceiveRetryCount` +1) \* (`MaxRetryCycles` + 1)회까지 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-129">On [!INCLUDE[wv](../../../../includes/wv-md.md)], the message is tried a maximum of (`ReceiveRetryCount` +1) \* (`MaxRetryCycles` + 1) times.</span></span> <span data-ttu-id="1a49a-130">`MaxRetryCycles`는 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 및 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]에서 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-130">`MaxRetryCycles` is ignored on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
-   <span data-ttu-id="1a49a-131">`RetryCycleDelay`.</span><span class="sxs-lookup"><span data-stu-id="1a49a-131">`RetryCycleDelay`.</span></span> <span data-ttu-id="1a49a-132">재시도 주기 사이의 지연 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-132">The time delay between retry cycles.</span></span> <span data-ttu-id="1a49a-133">기본값은 30분입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-133">The default value is 30 minutes.</span></span> <span data-ttu-id="1a49a-134">`MaxRetryCycles` 및 `RetryCycleDelay`는 함께 정기적인 지연 시간 이후 재시도로 문제를 해결하는 문제 해결 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-134">`MaxRetryCycles` and `RetryCycleDelay` together provide a mechanism to address the problem where a retry after a periodic delay fixes the problem.</span></span> <span data-ttu-id="1a49a-135">예를 들면, 이 핸들은 SQL Server의 보류 중인 트랜잭션 커밋에 설정된 잠긴 행을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-135">For example, this handles a locked row set in SQL Server pending transaction commit.</span></span>  
  
-   <span data-ttu-id="1a49a-136">`ReceiveErrorHandling`.</span><span class="sxs-lookup"><span data-stu-id="1a49a-136">`ReceiveErrorHandling`.</span></span> <span data-ttu-id="1a49a-137">최대 재시도 횟수만큼 시도한 후에 전달하지 못한 메시지에 대해 수행할 작업을 나타내는 열거입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-137">An enumeration that indicates the action to take for a message that has failed delivery after the maximum number of retries has been attempted.</span></span> <span data-ttu-id="1a49a-138">이 값은 Fault, Drop, Reject 및 Move일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-138">The values can be Fault, Drop, Reject, and Move.</span></span> <span data-ttu-id="1a49a-139">기본 옵션은 Fault입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-139">The default option is Fault.</span></span>  
  
-   <span data-ttu-id="1a49a-140">Fault.</span><span class="sxs-lookup"><span data-stu-id="1a49a-140">Fault.</span></span> <span data-ttu-id="1a49a-141">이 옵션은 `ServiceHost`에 오류를 일으키는 수신기에 오류를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-141">This option sends a fault to the listener that caused the `ServiceHost` to fault.</span></span> <span data-ttu-id="1a49a-142">응용 프로그램이 큐의 메시지를 계속 처리하려면 외부 메커니즘을 통해 응용 프로그램 큐에서 메시지를 제거해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-142">The message must be removed from the application queue by some external mechanism before the application can continue to process messages from the queue.</span></span>  
  
-   <span data-ttu-id="1a49a-143">Drop.</span><span class="sxs-lookup"><span data-stu-id="1a49a-143">Drop.</span></span> <span data-ttu-id="1a49a-144">이 옵션은 포이즌 메시지를 삭제하므로 메시지가 응용 프로그램에 전달되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-144">This option drops the poison message and the message is never delivered to the application.</span></span> <span data-ttu-id="1a49a-145">메시지의 `TimeToLive` 속성이 이 시점에서 만료되면 메시지가 보낸 사람의 배달 못 한 큐에 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-145">If the message's `TimeToLive` property has expired at this point, then the message may appear in the sender's dead-letter queue.</span></span> <span data-ttu-id="1a49a-146">그렇지 않으면 메시지는 아무 곳에서도 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-146">If not, the message does not appear anywhere.</span></span> <span data-ttu-id="1a49a-147">이 옵션은 메시지가 손실된 경우 사용자가 수행할 작업을 지정하지 않았음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-147">This option indicates that the user has not specified what to do if the message is lost.</span></span>  
  
-   <span data-ttu-id="1a49a-148">Reject.</span><span class="sxs-lookup"><span data-stu-id="1a49a-148">Reject.</span></span> <span data-ttu-id="1a49a-149">이 옵션은 [!INCLUDE[wv](../../../../includes/wv-md.md)]에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-149">This option is available only on [!INCLUDE[wv](../../../../includes/wv-md.md)].</span></span> <span data-ttu-id="1a49a-150">이 옵션은 메시지 큐(MSMQ)에 응용 프로그램이 메시지를 받을 수 없는 전송 큐 관리자에게 부정 승인을 다시 보내도록 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-150">This instructs Message Queuing (MSMQ) to send a negative acknowledgement back to the sending queue manager that the application cannot receive the message.</span></span> <span data-ttu-id="1a49a-151">이 메시지는 전송 큐 관리자의 배달 못한 편지 큐에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-151">The message is placed in the sending queue manager's dead-letter queue.</span></span>  
  
-   <span data-ttu-id="1a49a-152">Move.</span><span class="sxs-lookup"><span data-stu-id="1a49a-152">Move.</span></span> <span data-ttu-id="1a49a-153">이 옵션은 [!INCLUDE[wv](../../../../includes/wv-md.md)]에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-153">This option is available only on [!INCLUDE[wv](../../../../includes/wv-md.md)].</span></span> <span data-ttu-id="1a49a-154">이 옵션은 포이즌 메시지 처리 응용 프로그램이 나중에 처리할 수 있도록 포이즌 메시지를 포이즌 메시지 큐로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-154">This moves the poison message to a poison-message queue for later processing by a poison-message handling application.</span></span> <span data-ttu-id="1a49a-155">포이즌 메시지 큐는 응용 프로그램 큐의 하위 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-155">The poison-message queue is a subqueue of the application queue.</span></span> <span data-ttu-id="1a49a-156">포이즌 메시지 처리 응용 프로그램은 포이즌 큐 외부의 메시지를 읽는 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 서비스일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-156">A poison-message handling application can be a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service that reads messages out of the poison queue.</span></span> <span data-ttu-id="1a49a-157">포이즌 큐는 응용 프로그램 큐의 하위 큐 및 net.msmq://의 주소\<*컴퓨터 이름*>/*applicationQueue*; poison, 여기서  *컴퓨터 이름* 큐가 있는 컴퓨터의 이름 및 *applicationQueue* 응용 프로그램별 큐의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-157">The poison queue is a subqueue of the application queue and can be addressed as net.msmq://\<*machine-name*>/*applicationQueue*;poison, where *machine-name* is the name of the computer on which the queue resides and the *applicationQueue* is the name of the application-specific queue.</span></span>  
  
 <span data-ttu-id="1a49a-158">다음은 메시지에 대한 최대 전달 시도 횟수입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-158">The following are the maximum number of delivery attempts made for a message:</span></span>  
  
-   <span data-ttu-id="1a49a-159">[!INCLUDE[wv](../../../../includes/wv-md.md)]의 경우, ((ReceiveRetryCount+1) \* (MaxRetryCycles + 1))</span><span class="sxs-lookup"><span data-stu-id="1a49a-159">((ReceiveRetryCount+1) \* (MaxRetryCycles + 1)) on [!INCLUDE[wv](../../../../includes/wv-md.md)].</span></span>  
  
-   <span data-ttu-id="1a49a-160">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 및 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]의 경우, (ReceiveRetryCount + 1)</span><span class="sxs-lookup"><span data-stu-id="1a49a-160">(ReceiveRetryCount + 1) on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1a49a-161">전달된 메시지에 대해서는 다시 시도하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-161">No retries are made for a message that is delivered successfully.</span></span>  
  
 <span data-ttu-id="1a49a-162">메시지 읽기를 시도한 횟수를 추적하려면 [!INCLUDE[wv](../../../../includes/wv-md.md)]에서 중단 횟수를 계산하는 지속적 메시지 속성과, 응용 프로그램 큐와 하위 큐 사이에서 메시지를 이동한 횟수를 계산하는 이동 횟수 속성을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-162">To keep track of the number of times a message read is attempted, [!INCLUDE[wv](../../../../includes/wv-md.md)] maintains a durable message property that counts the number of aborts and a move count property that counts the number of times the message moves between the application queue and subqueues.</span></span> <span data-ttu-id="1a49a-163">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 채널은 이러한 속성을 사용하여 받은 재시도 횟수와 재시도 주기 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-163">The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] channel uses these to compute the receive retry count and the retry cycles count.</span></span> <span data-ttu-id="1a49a-164">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 및 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]에서 중단 횟수는 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 채널에 의해 메모리에서 관리되고 응용 프로그램이 실패하면 재설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-164">On [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)], the abort count is maintained in memory by the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] channel and is reset if the application fails.</span></span> <span data-ttu-id="1a49a-165">또한 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 채널은 언제든지 메모리에 최대 256개의 메시지 중단 횟수를 보유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-165">Also, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] channel can hold the abort counts for up to 256 messages in memory at any time.</span></span> <span data-ttu-id="1a49a-166">257번째 메시지를 읽으면 가장 오래된 메시지의 중단 횟수가 재설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-166">If a 257th message is read, then the oldest message's abort count is reset.</span></span>  
  
 <span data-ttu-id="1a49a-167">중단 횟수와 이동 횟수 속성은 작업 컨텍스트를 통해 서비스 작업에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-167">The abort count and move count properties are available to the service operation through the operation context.</span></span> <span data-ttu-id="1a49a-168">다음 코드 예제에서는 이러한 속성에 액세스하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-168">The following code example shows how to access them.</span></span>  
  
 [!code-csharp[S_UE_MSMQ_Poison#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/service.cs#1)]  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="1a49a-169">에서는 대기 중인 두 개의 표준 바인딩을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-169"> provides two standard queued bindings:</span></span>  
  
-   <span data-ttu-id="1a49a-170"><xref:System.ServiceModel.NetMsmqBinding>.</span><span class="sxs-lookup"><span data-stu-id="1a49a-170"><xref:System.ServiceModel.NetMsmqBinding>.</span></span> <span data-ttu-id="1a49a-171">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 바인딩은 다른 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 끝점과 큐 기반 통신을 수행하는 데 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-171">A [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] binding suitable for performing queue-based communication with other [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] endpoints.</span></span>  
  
-   <span data-ttu-id="1a49a-172"><xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span><span class="sxs-lookup"><span data-stu-id="1a49a-172"><xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span></span> <span data-ttu-id="1a49a-173">기존 메시지 큐 응용 프로그램과 통신하는 데 적합한 바인딩입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-173">A binding suitable for communicating with existing Message Queuing applications.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1a49a-174">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 서비스 요구 사항을 기반으로 이러한 바인딩의 속성을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-174">You can alter properties in these bindings based on the requirements of your [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service.</span></span> <span data-ttu-id="1a49a-175">전체 포이즌 메시지 처리 메커니즘은 수신 응용 프로그램에 로컬입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-175">The entire poison message handling mechanism is local to the receiving application.</span></span> <span data-ttu-id="1a49a-176">프로세스는 수신 응용 프로그램이 최종적으로 부정 승인을 중지하고 발신자에게 다시 보내지 않으면 송신 응용 프로그램에 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-176">The process is invisible to the sending application unless the receiving application ultimately stops and sends a negative acknowledgment back to the sender.</span></span> <span data-ttu-id="1a49a-177">이 경우 메시지가 발신자의 배달 못 한 큐로 이동됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-177">In that case, the message is moved to the sender's dead-letter queue.</span></span>  
  
## <a name="best-practice-handling-msmqpoisonmessageexception"></a><span data-ttu-id="1a49a-178">최선의 방법: MsmqPoisonMessageException 처리</span><span class="sxs-lookup"><span data-stu-id="1a49a-178">Best Practice: Handling MsmqPoisonMessageException</span></span>  
 <span data-ttu-id="1a49a-179">서비스에서 메시지가 포이즌임을 확인하면 대기 중인 전송이 포이즌 메시지의 <xref:System.ServiceModel.MsmqPoisonMessageException>를 포함하는 `LookupId`을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-179">When the service determines that a message is poison, the queued transport throws a <xref:System.ServiceModel.MsmqPoisonMessageException> that contains the `LookupId` of the poison message.</span></span>  
  
 <span data-ttu-id="1a49a-180">수신 응용 프로그램이 <xref:System.ServiceModel.Dispatcher.IErrorHandler> 인터페이스를 구현하여 응용 프로그램에서 요청하는 모든 오류를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-180">A receiving application can implement the <xref:System.ServiceModel.Dispatcher.IErrorHandler> interface to handle any errors that the application requires.</span></span> <span data-ttu-id="1a49a-181">자세한 내용은 참조 [확장 제어를 통해 오류를 처리 하 고 보고](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-181">For more information, see [Extending Control Over Error Handling and Reporting](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md).</span></span>  
  
 <span data-ttu-id="1a49a-182">응용 프로그램에서 서비스가 큐의 남은 메시지에 액세스할 수 있도록 포이즌 메시지를 포이즌 메시지 큐로 이동하는 몇 가지 포이즌 메시지 자동 처리 작업이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-182">The application may require some kind of automated handling of poison messages that moves the poison messages to a poison message queue so that the service can access the rest of the messages in the queue.</span></span> <span data-ttu-id="1a49a-183"><xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> 설정이 <xref:System.ServiceModel.ReceiveErrorHandling.Fault>로 설정된 경우에만 오류 처리 메커니즘을 사용하여 포이즌 메시지 예외를 수신 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-183">The only scenario for using the error-handler mechanism to listen for poison-message exceptions is when the <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> setting is set to <xref:System.ServiceModel.ReceiveErrorHandling.Fault>.</span></span> <span data-ttu-id="1a49a-184">메시지 큐 3.0의 포이즌 메시지 샘플은 이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-184">The poison-message sample for Message Queuing 3.0 demonstrates this behavior.</span></span> <span data-ttu-id="1a49a-185">다음에서는 최선의 방법을 포함하여 포이즌 메시지를 처리하는 단계를 간략히 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-185">The following outlines the steps to take to handle poison messages, including best practices:</span></span>  
  
1.  <span data-ttu-id="1a49a-186">포이즌 설정이 응용 프로그램의 요구 사항을 반영하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-186">Ensure your poison settings reflect the requirements of your application.</span></span> <span data-ttu-id="1a49a-187">설정할 때 [!INCLUDE[wv](../../../../includes/wv-md.md)], [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 및 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 간 메시지 큐 기능의 차이점을 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-187">When working with the settings, ensure that you understand the differences between the capabilities of Message Queuing on [!INCLUDE[wv](../../../../includes/wv-md.md)], [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
2.  <span data-ttu-id="1a49a-188">필요한 경우 `IErrorHandler`를 구현하여 포이즌 메시지 오류를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-188">If required, implement the `IErrorHandler` to handle poison-message errors.</span></span> <span data-ttu-id="1a49a-189">`ReceiveErrorHandling`을 `Fault`로 설정하려면 큐에서 포이즌 메시지를 제거하거나 외부 종속 문제를 해결하는 수동 메커니즘이 필요하므로 일반적인 사용법은 다음 코드처럼 `IErrorHandler`이 `ReceiveErrorHandling`로 설정된 경우 `Fault`를 구현하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-189">Because setting `ReceiveErrorHandling` to `Fault` requires a manual mechanism to move the poison message out of the queue or to correct an external dependent issue, the typical usage is to implement `IErrorHandler` when `ReceiveErrorHandling` is set to `Fault`, as shown in the following code.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonerrorhandler.cs#2)]  
  
3.  <span data-ttu-id="1a49a-190">서비스 동작에서 사용할 수 있는 `PoisonBehaviorAttribute`를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-190">Create a `PoisonBehaviorAttribute` that the service behavior can use.</span></span> <span data-ttu-id="1a49a-191">이렇게 하면 디스패처에 `IErrorHandler`가 설치됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-191">The behavior installs the `IErrorHandler` on the dispatcher.</span></span> <span data-ttu-id="1a49a-192">다음 코드 예제를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="1a49a-192">See the following code example.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonbehaviorattribute.cs#3)]  
  
4.  <span data-ttu-id="1a49a-193">서비스에 포이즌 동작 특성으로 주석이 달려 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-193">Ensure that your service is annotated with the poison behavior attribute.</span></span>  
  
  
  
 <span data-ttu-id="1a49a-194">또한 `ReceiveErrorHandling`이 `Fault`로 설정된 경우 `ServiceHost`에서 포이즌 메시지를 발생하는 데 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-194">In addition, if the `ReceiveErrorHandling` is set to `Fault`, the `ServiceHost` faults when encountering the poison message.</span></span> <span data-ttu-id="1a49a-195">오류가 발생한 이벤트에 후크하고 서비스를 종료하며 수정 작업을 수행한 다음 다시 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-195">You can hook up to the faulted event and shut down the service, take corrective actions, and restart.</span></span> <span data-ttu-id="1a49a-196">예를 들어 `LookupId`로 전파된 <xref:System.ServiceModel.MsmqPoisonMessageException>의 `IErrorHandler`를 기록해 둔 다음, 서비스 호스트에 오류가 발생하는 경우 `System.Messaging` API를 사용하면 `LookupId`를 사용하여 큐에서 메시지를 받고, 큐에서 메시지를 제거하고, 외부 저장소 또는 다른 큐에 메시지를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-196">For example, the `LookupId` in the <xref:System.ServiceModel.MsmqPoisonMessageException> propagated to the `IErrorHandler` can be noted and when the service host faults, you could use the `System.Messaging` API to receive the message from the queue using the `LookupId` to remove the message from the queue and store the message in some external store or another queue.</span></span> <span data-ttu-id="1a49a-197">그런 다음 `ServiceHost`를 다시 시작하여 일반적인 처리를 다시 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-197">You can then restart `ServiceHost` to resume normal processing.</span></span> <span data-ttu-id="1a49a-198">[MSMQ 4.0에서 포이즌 메시지 처리](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md) 이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-198">The [Poison Message Handling in MSMQ 4.0](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md) demonstrates this behavior.</span></span>  
  
## <a name="transaction-time-out-and-poison-messages"></a><span data-ttu-id="1a49a-199">트랜잭션 제한 시간 및 포이즌 메시지</span><span class="sxs-lookup"><span data-stu-id="1a49a-199">Transaction Time-Out and Poison Messages</span></span>  
 <span data-ttu-id="1a49a-200">대기 중인 전송 채널과 사용자 코드 사이에 오류 클래스가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-200">A class of errors can occur between the queued transport channel and the user code.</span></span> <span data-ttu-id="1a49a-201">이러한 오류는 메시지 보안 계층이나 서비스 디스패치 논리와 같은 사이 계층에서 검색될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-201">These errors can be detected by layers in-between, such as the message security layer or the service dispatching logic.</span></span> <span data-ttu-id="1a49a-202">예를 들어 메시지가 응용 프로그램으로 디스패치되는 경우는 SOAP 보안 계층에서 검색되는 X.509 인증서가 없고 동작이 누락된 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-202">For example, a missing X.509 certificate detected in the SOAP security layer and a missing action are cases where the message does get dispatched to the application.</span></span> <span data-ttu-id="1a49a-203">이 경우 서비스 모델이 메시지를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-203">When this happens, the service model drops the message.</span></span> <span data-ttu-id="1a49a-204">메시지를 트랜잭션에서 읽고 해당 트랜잭션에 대한 결과를 제공할 수 없으므로 트랜잭션이 시간 초과되고 중단되며 메시지가 큐에 다시 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-204">Because the message is read in a transaction and an outcome for that transaction cannot be provided, the transaction eventually times out, aborts, and the message is put back into the queue.</span></span> <span data-ttu-id="1a49a-205">즉, 특정 오류 클래스에서 트랜잭션이 바로 중단되지는 않지만 트랜잭션 제한 시간을 초과할 때가지 기다립니다. <xref:System.ServiceModel.ServiceBehaviorAttribute>를 사용하여 서비스에 대한 트랜잭션 제한 시간을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-205">In other words, for a certain class of errors, the transaction does not immediately abort but waits until the transaction times out. You can modify the transaction time-out for a service using <xref:System.ServiceModel.ServiceBehaviorAttribute>.</span></span>  
  
 <span data-ttu-id="1a49a-206">컴퓨터 전체에서 트랜잭션 제한 시간을 변경하려면 machine.config 파일을 수정하고 해당 트랜잭션 제한 시간을 설정합니다. 트랜잭션에 설정된 제한 시간에 따라 트랜잭션이 중단되어 결국 큐로 돌아가므로 해당 트랜잭션의 중단 횟수가 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-206">To change the transaction time-out on a computer-wide basis, modify the machine.config file and set the appropriate transaction time-out. It is important to note that, depending on the time-out set in the transaction, the transaction eventually aborts and goes back to the queue and its abort count is incremented.</span></span> <span data-ttu-id="1a49a-207">결국 메시지는 포이즌이 되고 사용자 설정에 따라 적절히 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-207">Eventually, the message becomes poison and the right disposition is made according to the user settings.</span></span>  
  
## <a name="sessions-and-poison-messages"></a><span data-ttu-id="1a49a-208">세션 및 포이즌 메시지</span><span class="sxs-lookup"><span data-stu-id="1a49a-208">Sessions and Poison Messages</span></span>  
 <span data-ttu-id="1a49a-209">세션에서는 단일 메시지와 같은 재시도와 포이즌 메시지 처리 프로시저를 거칩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-209">A session undergoes the same retry and poison-message handling procedures as a single message.</span></span> <span data-ttu-id="1a49a-210">포이즌 메시지에 대해 위에 나열된 속성은 전체 세션에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-210">The properties previously listed for poison messages apply to the entire session.</span></span> <span data-ttu-id="1a49a-211">즉, 메시지가 거부되면 전체 세션이 다시 시도되고 최종 포이즌 메시지 큐나 발신자의 배달 못한 편지 큐로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-211">This means that the entire session is retried and goes to a final poison-message queue or the sender’s dead-letter queue if the message is rejected.</span></span>  
  
## <a name="batching-and-poison-messages"></a><span data-ttu-id="1a49a-212">일괄 처리 및 포이즌 메시지</span><span class="sxs-lookup"><span data-stu-id="1a49a-212">Batching and Poison Messages</span></span>  
 <span data-ttu-id="1a49a-213">메시지가 포이즌 메시지가 되고 일괄 처리에 포함되면 전체 일괄 처리가 롤백되고 채널이 한 번에 하나의 메시지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-213">If a message becomes a poison message and is part of a batch, then the entire batch is rolled back and the channel returns to reading one message at a time.</span></span> <span data-ttu-id="1a49a-214">일괄 처리 하는 방법에 대 한 자세한 내용은 참조 [트랜잭션에서 메시지 일괄 처리](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)</span><span class="sxs-lookup"><span data-stu-id="1a49a-214">For more information about batching, see [Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)</span></span>  
  
## <a name="poison-message-handling-for-messages-in-a-poison-queue"></a><span data-ttu-id="1a49a-215">포이즌 큐의 메시지에 대한 포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="1a49a-215">Poison-message Handling for Messages in a Poison Queue</span></span>  
 <span data-ttu-id="1a49a-216">메시지가 포이즌 메시지 큐에 놓이면 포이즌 메시지 처리가 종료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-216">Poison-message handling does not end when a message is placed in the poison-message queue.</span></span> <span data-ttu-id="1a49a-217">포이즌 메시지 큐의 메시지를 읽고 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-217">Messages in the poison-message queue must still be read and handled.</span></span> <span data-ttu-id="1a49a-218">최종 포이즌 하위 큐에서 메시지를 읽을 때 포이즌 메시지 처리 설정의 하위 집합을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-218">You can use a subset of the poison-message handling settings when reading messages from the final poison subqueue.</span></span> <span data-ttu-id="1a49a-219">`ReceiveRetryCount` 및 `ReceiveErrorHandling` 설정을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-219">The applicable settings are `ReceiveRetryCount` and `ReceiveErrorHandling`.</span></span> <span data-ttu-id="1a49a-220">`ReceiveErrorHandling`은 Drop, Reject 또는 Fault로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-220">You can set `ReceiveErrorHandling` to Drop, Reject, or Fault.</span></span> <span data-ttu-id="1a49a-221">`MaxRetryCycles`이 Move로 설정되면 `ReceiveErrorHandling`가 무시되고 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-221">`MaxRetryCycles` is ignored and an exception is thrown if `ReceiveErrorHandling` is set to Move.</span></span>  
  
## <a name="windows-vista-windows-server-2003-and-windows-xp-differences"></a><span data-ttu-id="1a49a-222">Windows Vista, Windows Server 2003 및 Windows XP의 차이점</span><span class="sxs-lookup"><span data-stu-id="1a49a-222">Windows Vista, Windows Server 2003, and Windows XP Differences</span></span>  
 <span data-ttu-id="1a49a-223">앞에서 설명한 대로 포이즌 메시지 처리 설정의 일부만 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 및 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-223">As noted earlier, not all poison-message handling settings apply to [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span> <span data-ttu-id="1a49a-224">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 및 [!INCLUDE[wv](../../../../includes/wv-md.md)]에서 메시지 큐의 주요 차이점은 포이즌 메시지 처리와 관련된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-224">The following key differences between Message Queuing on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], [!INCLUDE[wxp](../../../../includes/wxp-md.md)], and [!INCLUDE[wv](../../../../includes/wv-md.md)] are relevant to poison-message handling:</span></span>  
  
-   <span data-ttu-id="1a49a-225">[!INCLUDE[wv](../../../../includes/wv-md.md)]의 메시지 큐는 하위 큐를 지원하지만 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 및 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]는 하위 큐를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-225">Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports subqueues, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not support subqueues.</span></span> <span data-ttu-id="1a49a-226">하위 큐는 포이즌 메시지 처리에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-226">Subqueues are used in poison-message handling.</span></span> <span data-ttu-id="1a49a-227">재시도 큐와 포이즌 큐는 포이즌 메시지 처리 설정에 따라 만들어지는 응용 프로그램 큐의 하위 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-227">The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings.</span></span> <span data-ttu-id="1a49a-228">`MaxRetryCycles`는 만들 재시도 하위 큐의 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-228">The `MaxRetryCycles` dictates how many retry subqueues to create.</span></span> <span data-ttu-id="1a49a-229">따라서 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 또는 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]에서 실행하는 경우 `MaxRetryCycles`는 무시되며 `ReceiveErrorHandling.Move`는 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-229">Therefore, when running on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] or [!INCLUDE[wxp](../../../../includes/wxp-md.md)], `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed.</span></span>  
  
-   <span data-ttu-id="1a49a-230">[!INCLUDE[wv](../../../../includes/wv-md.md)]의 메시지 큐는 부정 승인을 지원하지만 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 및 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]에서는 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-230">Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports negative acknowledgment, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not.</span></span> <span data-ttu-id="1a49a-231">받는 큐 관리자에서 네거티브 승인을 사용하면 거부된 메시지가 보내는 큐 관리자의 배달 못한 편지 큐에 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-231">A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue.</span></span> <span data-ttu-id="1a49a-232">따라서 `ReceiveErrorHandling.Reject`는 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 및 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]에서 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-232">As such, `ReceiveErrorHandling.Reject` is not allowed with [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
-   <span data-ttu-id="1a49a-233">[!INCLUDE[wv](../../../../includes/wv-md.md)]의 메시지 큐는 메시지 전달 시도 횟수를 보관하는 메시지 속성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-233">Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports a message property that keeps count of the number of times message delivery is attempted.</span></span> <span data-ttu-id="1a49a-234">이 중단 횟수 속성은 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 및 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-234">This abort count property is not available on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span> [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="1a49a-235">에서는 중단 횟수가 메모리 내에 유지되기 때문에 팜에 있는 둘 이상의 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 서비스에서 같은 메시지를 읽을 경우에는 이 속성 값이 정확하지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a49a-235"> maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service in a farm.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1a49a-236">참고 항목</span><span class="sxs-lookup"><span data-stu-id="1a49a-236">See Also</span></span>  
 [<span data-ttu-id="1a49a-237">큐 개요</span><span class="sxs-lookup"><span data-stu-id="1a49a-237">Queues Overview</span></span>](../../../../docs/framework/wcf/feature-details/queues-overview.md)  
 [<span data-ttu-id="1a49a-238">Windows Vista, Windows Server 2003 및 Windows XP의 큐 기능 차이점</span><span class="sxs-lookup"><span data-stu-id="1a49a-238">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)  
 [<span data-ttu-id="1a49a-239">계약 및 서비스에서 오류 지정 및 처리</span><span class="sxs-lookup"><span data-stu-id="1a49a-239">Specifying and Handling Faults in Contracts and Services</span></span>](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)

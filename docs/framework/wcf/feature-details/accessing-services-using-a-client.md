---
title: 클라이언트를 사용하여 서비스 액세스
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c8329832-bf66-4064-9034-bf39f153fc2d
ms.openlocfilehash: 1369403b493683f58640047fe042708afc5d5b46
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33495998"
---
# <a name="accessing-services-using-a-client"></a><span data-ttu-id="746ff-102">클라이언트를 사용하여 서비스 액세스</span><span class="sxs-lookup"><span data-stu-id="746ff-102">Accessing Services Using a Client</span></span>
<span data-ttu-id="746ff-103">클라이언트 응용 프로그램 만들기, 구성 및 WCF 클라이언트 또는 채널 개체를 사용 하 여 서비스와 통신 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-103">Client applications must create, configure, and use WCF client or channel objects to communicate with services.</span></span> <span data-ttu-id="746ff-104">[WCF 클라이언트 개요](../../../../docs/framework/wcf/wcf-client-overview.md) 항목에서는 개체 및 기본 클라이언트 및 채널 개체 만들기 및 사용에 관련 된 단계에 대 한 개요를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-104">The [WCF Client Overview](../../../../docs/framework/wcf/wcf-client-overview.md) topic provides an overview of the objects and steps involved in creating basic client and channel objects and using them.</span></span>  
  
 <span data-ttu-id="746ff-105">이 항목에서는 시나리오에 따라 유용할 수 있는 클라이언트 및 채널 개체와 클라이언트 응용 프로그램과 관련된 몇 가지 문제에 대한 자세한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-105">This topic provides in-depth information about some of the issues with client applications and client and channel objects that may be useful depending upon your scenario.</span></span>  
  
## <a name="overview"></a><span data-ttu-id="746ff-106">개요</span><span class="sxs-lookup"><span data-stu-id="746ff-106">Overview</span></span>  
 <span data-ttu-id="746ff-107">이 항목에서는 다음과 관련된 동작 및 문제에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-107">This topic describes behavior and issues relating to:</span></span>  
  
-   <span data-ttu-id="746ff-108">채널 및 세션 수명</span><span class="sxs-lookup"><span data-stu-id="746ff-108">Channel and session lifetimes.</span></span>  
  
-   <span data-ttu-id="746ff-109">예외 처리</span><span class="sxs-lookup"><span data-stu-id="746ff-109">Handling exceptions.</span></span>  
  
-   <span data-ttu-id="746ff-110">블로킹 문제 이해</span><span class="sxs-lookup"><span data-stu-id="746ff-110">Understanding blocking issues.</span></span>  
  
-   <span data-ttu-id="746ff-111">대화형으로 채널 초기화</span><span class="sxs-lookup"><span data-stu-id="746ff-111">Initializing channels interactively.</span></span>  
  
### <a name="channel-and-session-lifetimes"></a><span data-ttu-id="746ff-112">채널 및 세션 수명</span><span class="sxs-lookup"><span data-stu-id="746ff-112">Channel and Session Lifetimes</span></span>  
 <span data-ttu-id="746ff-113">Windows Communication Foundation (WCF) 응용 프로그램에는 두 가지 범주의 채널 그램과 세션이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-113">Windows Communication Foundation (WCF) applications includes two categories of channels, datagram and sessionful.</span></span>  
  
 <span data-ttu-id="746ff-114">A *데이터 그램* 채널은 상호 관련 되지 않은 모든 메시지는 채널입니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-114">A *datagram* channel is a channel in which all messages are uncorrelated.</span></span> <span data-ttu-id="746ff-115">데이터그램 채널을 사용할 경우 입력 또는 출력 작업이 실패해도 일반적으로 다음 작업이 영향을 받지 않으며 동일한 채널을 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-115">With a datagram channel, if an input or output operation fails, the next operation is typically unaffected, and the same channel can be reused.</span></span> <span data-ttu-id="746ff-116">이 때문에 데이터그램 채널은 실패하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-116">Because of this, datagram channels typically do not fault.</span></span>  
  
 <span data-ttu-id="746ff-117">*세션* 채널 사항은 다른 끝점에 대 한 연결이 있는 채널입니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-117">*Sessionful* channels, however, are channels with a connection to the other endpoint.</span></span> <span data-ttu-id="746ff-118">한쪽의 세션 메시지는 항상 다른 쪽의 동일한 세션과 상호 관련됩니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-118">Messages in a session on one side are always correlated with the same session on the other side.</span></span> <span data-ttu-id="746ff-119">또한 한 세션이 성공한 것으로 간주되려면 해당 세션의 두 참가자가 모두 대화 요구 사항이 충족되었다고 동의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-119">In addition, both participants in a session must agree that the requirements of their conversation were met for that session to be considered successful.</span></span> <span data-ttu-id="746ff-120">동의할 수 없는 경우 세션 채널이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-120">If they cannot agree, the sessionful channel may fault.</span></span>  
  
 <span data-ttu-id="746ff-121">첫 번째 작업을 호출하여 명시적 또는 암시적으로 클라이언트를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-121">Open clients explicitly or implicitly by calling the first operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="746ff-122">알림을 받는 시기가 세션 구현에 따라 달라지므로 실패한 세션 채널을 명시적으로 검색하려는 시도는 일반적으로 유용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-122">Trying to explicitly detect faulted sessionful channels is not typically useful, because when you are notified depends upon the session implementation.</span></span> <span data-ttu-id="746ff-123">예를 들어 신뢰할 수 있는 세션을 사용하지 않는 <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType>은 TCP 연결의 세션을 표시하므로 서비스 또는 클라이언트의 <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> 이벤트를 수신 대기하면 네트워크 오류가 발생할 경우 신속하게 알림을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-123">For example, because the <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (with the reliable session disabled) surfaces the session of the TCP connection, if you listen to the <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> event on the service or the client you are likely to be notified quickly in the event of a network failure.</span></span> <span data-ttu-id="746ff-124">그러나 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType>를 사용하는 바인딩으로 설정된 신뢰할 수 있는 세션은 소규모 네트워크 오류로부터 서비스를 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-124">But reliable sessions (established by bindings in which the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> is enabled) are designed to insulate services from small network failures.</span></span> <span data-ttu-id="746ff-125">적절한 기간 내에 세션을 다시 설정할 수 있는 경우 보다 긴 기간 동안 중단이 계속될 때까지 신뢰할 수 있는 세션에 대해 구성된 동일한 바인딩이 실패하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-125">If the session can be reestablished within a reasonable period of time, the same binding—configured for reliable sessions—might not fault until the interruption continued for a longer period of time.</span></span>  
  
 <span data-ttu-id="746ff-126">채널을 응용 프로그램 계층에 노출하는 대부분의 시스템 제공 바인딩은 기본적으로 세션을 사용하지만 <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType>은 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-126">Most of the system-provided bindings (which expose channels to the application layer) use sessions by default, but the <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> does not.</span></span> <span data-ttu-id="746ff-127">자세한 내용은 참조 [를 사용 하 여 세션](../../../../docs/framework/wcf/using-sessions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-127">For more information, see [Using Sessions](../../../../docs/framework/wcf/using-sessions.md).</span></span>  
  
### <a name="the-proper-use-of-sessions"></a><span data-ttu-id="746ff-128">적절한 세션 사용</span><span class="sxs-lookup"><span data-stu-id="746ff-128">The Proper Use of Sessions</span></span>  
 <span data-ttu-id="746ff-129">세션은 전체 메시지 교환이 완료되었는지 여부 및 양쪽에서 성공했다고 간주하는지 여부를 확인하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-129">Sessions provide a way to know if the entire message exchange is complete, and if both sides considered it successful.</span></span> <span data-ttu-id="746ff-130">호출 응용 프로그램은 하나의 try 블록 내에서 채널을 열고 사용한 후 닫는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-130">It is recommended that a calling application open the channel, use it, and close the channel inside one try block.</span></span> <span data-ttu-id="746ff-131">세션 채널이 열려 있고 <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> 메서드를 한 번 호출한 후 해당 호출이 성공적으로 반환되면 세션이 성공했습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-131">If a session channel is open, and the <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> method is called once, and that call returns successfully, then the session was successful.</span></span> <span data-ttu-id="746ff-132">이 경우 성공은 바인딩에서 지정한 모든 배달 보증이 충족되었으며 다른 쪽이 <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType>를 호출하기 전에 채널에서 <xref:System.ServiceModel.ICommunicationObject.Close%2A>를 호출하지 않았음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-132">Successful in this case means that all delivery guarantees the binding specified were met, and the other side did not call <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> on the channel before calling <xref:System.ServiceModel.ICommunicationObject.Close%2A>.</span></span>  
  
 <span data-ttu-id="746ff-133">다음 섹션에서는 이 클라이언트 접근 방법의 예를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-133">The following section provides an example of this client approach.</span></span>  
  
### <a name="handling-exceptions"></a><span data-ttu-id="746ff-134">예외 처리</span><span class="sxs-lookup"><span data-stu-id="746ff-134">Handling Exceptions</span></span>  
 <span data-ttu-id="746ff-135">클라이언트 응용 프로그램의 예외 처리는 단순합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-135">Handling exceptions in client applications is straightforward.</span></span> <span data-ttu-id="746ff-136">하나의 try 블록 내에서 채널을 열고 사용한 후 닫으면 예외가 throw되지 않는 한 대화가 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-136">If a channel is opened, used, and closed inside a try block, then the conversation has succeeded, unless an exception is thrown.</span></span> <span data-ttu-id="746ff-137">일반적으로 예외가 throw되면 대화가 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-137">Typically, if an exception is thrown the conversation is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="746ff-138">사용은 `using` 문 (`Using` Visual basic에서) 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-138">Use of the `using` statement (`Using` in Visual Basic) is not recommended.</span></span> <span data-ttu-id="746ff-139">이는 `using` 문의 끝에서 예외가 발생하여 사용자가 확인해야 하는 다른 예외를 마스킹할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-139">This is because the end of the `using` statement can cause exceptions that can mask other exceptions you may need to know about.</span></span> <span data-ttu-id="746ff-140">자세한 내용은 참조 [Using 문과 문제 방지](../../../../docs/framework/wcf/samples/avoiding-problems-with-the-using-statement.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-140">For more information, see [Avoiding Problems with the Using Statement](../../../../docs/framework/wcf/samples/avoiding-problems-with-the-using-statement.md).</span></span>  
  
 <span data-ttu-id="746ff-141">다음 코드 예제에서는 `using` 문이 아니라 try/catch 블록을 사용한 권장되는 클라이언트 패턴을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-141">The following code example shows the recommended client pattern using a try/catch block and not the `using` statement.</span></span>  
  
 [!code-csharp[FaultContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
 [!code-vb[FaultContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]  
  
> [!NOTE]
>  <span data-ttu-id="746ff-142"><xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> 속성 값 확인은 경합 상태이며 채널을 다시 사용할지 또는 닫을지 결정하는 데 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-142">Checking the value of the <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> property is a race condition and is not recommended to determine whether to reuse or close a channel.</span></span>  
  
 <span data-ttu-id="746ff-143">데이터그램 채널은 닫을 때 예외가 발생하는 경우에도 실패하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-143">Datagram channels never fault even if exceptions occur when they are closed.</span></span> <span data-ttu-id="746ff-144">또한 보안 대화를 사용하여 인증할 수 없는 비이중 클라이언트는 일반적으로 <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-144">In addition, non-duplex clients that fail to authenticate using a secure conversation typically throw a <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="746ff-145">그러나 보안 대화를 사용하는 이중 클라이언트가 인증할 수 없는 경우 클라이언트는 대신 <xref:System.TimeoutException?displayProperty=nameWithType>을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-145">However if the duplex client using a secure conversation fails to authenticate, the client receives a <xref:System.TimeoutException?displayProperty=nameWithType> instead.</span></span>  
  
 <span data-ttu-id="746ff-146">응용 프로그램 수준에서 오류 정보로 작업 하는 방법에 대 한 자세한 정보를 참조 하십시오. [지정 및 계약 및 서비스에서 처리 오류](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-146">For more complete information about working with error information at the application level, see [Specifying and Handling Faults in Contracts and Services](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).</span></span> <span data-ttu-id="746ff-147">[예상 되는 오류](../../../../docs/framework/wcf/samples/expected-exceptions.md) 예상 되는 예외를 설명 하 고 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-147">[Expected Exceptions](../../../../docs/framework/wcf/samples/expected-exceptions.md) describes expected exceptions and shows how to handle them.</span></span> <span data-ttu-id="746ff-148">채널 개발 하는 경우 오류를 처리 하는 방법에 대 한 자세한 내용은 참조 [예외 처리 및 오류](../../../../docs/framework/wcf/extending/handling-exceptions-and-faults.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-148">For more information about how to handle errors when developing channels, see [Handling Exceptions and Faults](../../../../docs/framework/wcf/extending/handling-exceptions-and-faults.md).</span></span>  
  
### <a name="client-blocking-and-performance"></a><span data-ttu-id="746ff-149">클라이언트 차단 및 성능</span><span class="sxs-lookup"><span data-stu-id="746ff-149">Client Blocking and Performance</span></span>  
 <span data-ttu-id="746ff-150">응용 프로그램에서 동기적으로 request-reply 작업을 호출하는 경우 클라이언트는 반환 값이 수신되거나 <xref:System.TimeoutException?displayProperty=nameWithType> 같은 예외가 throw될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-150">When an application synchronously calls a request-reply operation, the client blocks until a return value is received or an exception (such as a <xref:System.TimeoutException?displayProperty=nameWithType>) is thrown.</span></span> <span data-ttu-id="746ff-151">이 동작은 로컬 동작과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-151">This behavior is similar to local behavior.</span></span> <span data-ttu-id="746ff-152">응용 프로그램을 WCF 클라이언트 개체 또는 채널에 대 한 작업을 동기적으로 호출, 네트워크 또는 예외가 throw 될 때까지 채널 계층에서 데이터를 쓸 수 클라이언트 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-152">When an application synchronously invokes an operation on a WCF client object or channel, the client does not return until the channel layer can write the data to the network or until an exception is thrown.</span></span> <span data-ttu-id="746ff-153"><xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType>를 `true`로 설정하여 작업을 표시함으로써 지정된 단방향 메시지 교환 패턴은 일부 클라이언트의 응답을 향상시키지만 바인딩 및 이미 전송된 메시지에 따라 단방향 작업이 차단될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-153">And while the one-way message exchange pattern (specified by marking an operation with <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> set to `true`) can make some clients more responsive, one-way operations can also block, depending upon the binding and what messages have already been sent.</span></span> <span data-ttu-id="746ff-154">단방향 작업은 메시지 교환에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-154">One-way operations are only about the message exchange, no more and no less.</span></span> <span data-ttu-id="746ff-155">자세한 내용은 참조 [단방향 서비스](../../../../docs/framework/wcf/feature-details/one-way-services.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-155">For more information, see [One-Way Services](../../../../docs/framework/wcf/feature-details/one-way-services.md).</span></span>  
  
 <span data-ttu-id="746ff-156">큰 데이터 청크는 메시지 교환 패턴에 관계없이 클라이언트 처리 속도를 저하시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-156">Large data chunks can slow client processing no matter what the message exchange pattern.</span></span> <span data-ttu-id="746ff-157">이러한 문제를 처리 하는 방법을 알아보려면 참조 [큰 데이터 및 스트리밍](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-157">To understand how to handle these issues, see [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="746ff-158">응용 프로그램는 작업이 완료 될 때 더 많은 작업을 수행 해야 하는 경우 WCF 클라이언트를 구현 하는 서비스 계약 인터페이스에는 비동기 메서드 쌍을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-158">If your application must do more work while an operation completes, you should create an asynchronous method pair on the service contract interface that your WCF client implements.</span></span> <span data-ttu-id="746ff-159">이 작업을 수행 하는 가장 쉬운 방법은 사용 하는 `/async` 스위치에 [ServiceModel Metadata 유틸리티 도구 (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-159">The easiest way to do this is to use the `/async` switch on the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="746ff-160">예를 들어 참조 [하는 방법: 비동기적 서비스 작업 호출](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-160">For an example, see [How to: Call Service Operations Asynchronously](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md).</span></span>  
  
 <span data-ttu-id="746ff-161">증가 클라이언트 성능에 대 한 자세한 내용은 참조 [중간 계층 클라이언트 응용 프로그램](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-161">For more information about increasing client performance, see [Middle-Tier Client Applications](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md).</span></span>  
  
### <a name="enabling-the-user-to-select-credentials-dynamically"></a><span data-ttu-id="746ff-162">사용자가 동적으로 자격 증명을 선택할 수 있도록 설정</span><span class="sxs-lookup"><span data-stu-id="746ff-162">Enabling the User to Select Credentials Dynamically</span></span>  
 <span data-ttu-id="746ff-163"><xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> 인터페이스를 사용하면 응용 프로그램이 시간 제한 타이머가 시작되기 전에 채널을 만드는 데 사용할 자격 증명을 사용자가 선택할 수 있도록 하는 사용자 인터페이스를 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-163">The <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> interface enables applications to display a user interface that enables the user to choose credentials with which a channel is created before the timeout timers start.</span></span>  
  
 <span data-ttu-id="746ff-164">응용 프로그램 개발자는 삽입된 <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer>를 두 가지 방법으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-164">Application developers can make use of an inserted <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> in two ways.</span></span> <span data-ttu-id="746ff-165">클라이언트 응용 프로그램 중 하나를 호출할 수 <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> 또는 <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (또는 비동기 버전)는 채널을 열기 전에 (의 *명시적* 접근 방식) 첫 번째 작업을 호출 하거나 (의 *암시적*접근 방식).</span><span class="sxs-lookup"><span data-stu-id="746ff-165">The client application can call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version) prior to opening the channel (the *explicit* approach) or call the first operation (the *implicit* approach).</span></span>  
  
 <span data-ttu-id="746ff-166">암시적 방법을 사용하는 경우 응용 프로그램은 <xref:System.ServiceModel.ClientBase%601> 또는 <xref:System.ServiceModel.IClientChannel> 확장에서 첫 번째 작업을 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-166">If using the implicit approach, the application must call the first operation on a <xref:System.ServiceModel.ClientBase%601> or <xref:System.ServiceModel.IClientChannel> extension.</span></span> <span data-ttu-id="746ff-167">다른 작업을 호출하면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-167">If it calls anything other than the first operation, an exception is thrown.</span></span>  
  
 <span data-ttu-id="746ff-168">명시적 방법을 사용하는 경우 응용 프로그램은 다음 단계를 순서대로 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-168">If using the explicit approach, the application must perform the following steps in order:</span></span>  
  
1.  <span data-ttu-id="746ff-169"><xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> 또는 <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType>(또는 비동기 버전)를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-169">Call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version).</span></span>  
  
2.  <span data-ttu-id="746ff-170">이니셜라이저가 반환되면 <xref:System.ServiceModel.ICommunicationObject.Open%2A> 개체 또는 <xref:System.ServiceModel.IClientChannel> 속성에서 반환된 <xref:System.ServiceModel.IClientChannel> 개체에서 <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-170">When the initializers have returned, call either the <xref:System.ServiceModel.ICommunicationObject.Open%2A> method on the <xref:System.ServiceModel.IClientChannel> object or on the <xref:System.ServiceModel.IClientChannel> object returned from the <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> property.</span></span>  
  
3.  <span data-ttu-id="746ff-171">작업을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-171">Call operations.</span></span>  
  
 <span data-ttu-id="746ff-172">프로덕션 품질 응용 프로그램에서는 명시적 방법을 사용하여 사용자 인터페이스 프로세스를 제어하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-172">It is recommended that production-quality applications control the user-interface process by adopting the explicit approach.</span></span>  
  
 <span data-ttu-id="746ff-173">암시적 방법을 사용하는 응용 프로그램은 사용자 인터페이스 이니셜라이저를 호출하지만, 응용 프로그램 사용자가 바인딩에 대한 전송 시간 제한 내에 응답하지 않을 경우 사용자 인터페이스가 반환될 때 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="746ff-173">Applications that use the implicit approach invoke the user-interface initializers, but if the user of the application fails to respond within the send timeout period of the binding, an exception is thrown when the user interface returns.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="746ff-174">참고 항목</span><span class="sxs-lookup"><span data-stu-id="746ff-174">See Also</span></span>  
 [<span data-ttu-id="746ff-175">이중 서비스</span><span class="sxs-lookup"><span data-stu-id="746ff-175">Duplex Services</span></span>](../../../../docs/framework/wcf/feature-details/duplex-services.md)  
 [<span data-ttu-id="746ff-176">방법: 단방향 및 요청-회신 계약을 사용하여 서비스 액세스</span><span class="sxs-lookup"><span data-stu-id="746ff-176">How to: Access Services with One-Way and Request-Reply Contracts</span></span>](../../../../docs/framework/wcf/feature-details/how-to-access-wcf-services-with-one-way-and-request-reply-contracts.md)  
 [<span data-ttu-id="746ff-177">방법: 이중 계약을 사용하여 서비스 액세스</span><span class="sxs-lookup"><span data-stu-id="746ff-177">How to: Access Services with a Duplex Contract</span></span>](../../../../docs/framework/wcf/feature-details/how-to-access-services-with-a-duplex-contract.md)  
 [<span data-ttu-id="746ff-178">방법: WSE 3.0 서비스 액세스</span><span class="sxs-lookup"><span data-stu-id="746ff-178">How to: Access a WSE 3.0 Service</span></span>](../../../../docs/framework/wcf/feature-details/how-to-access-a-wse-3-0-service-with-a-wcf-client.md)  
 [<span data-ttu-id="746ff-179">방법: ChannelFactory 사용</span><span class="sxs-lookup"><span data-stu-id="746ff-179">How to: Use the ChannelFactory</span></span>](../../../../docs/framework/wcf/feature-details/how-to-use-the-channelfactory.md)  
 [<span data-ttu-id="746ff-180">방법: 비동기적으로 서비스 작업 호출</span><span class="sxs-lookup"><span data-stu-id="746ff-180">How to: Call Service Operations Asynchronously</span></span>](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md)  
 [<span data-ttu-id="746ff-181">중간 계층 클라이언트 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="746ff-181">Middle-Tier Client Applications</span></span>](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md)

---
title: 데이터 계약의 컬렉션 형식
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: ''
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
caps.latest.revision: ''
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: e74bd7d90d5653890fd5cf48e76c81d0227c6172
ms.sourcegitcommit: c883637b41ee028786edceece4fa872939d2e64c
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/26/2018
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="954bb-102">데이터 계약의 컬렉션 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-102">Collection Types in Data Contracts</span></span>
<span data-ttu-id="954bb-103">*컬렉션* 은 특정 형식의 항목으로 구성된 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="954bb-104">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]의 경우 이러한 목록은 배열이나 여러 형식(제네릭 목록, 제네릭 <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>또는 <xref:System.Collections.ArrayList>)을 사용하여 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-104">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="954bb-105">예를 들어, 컬렉션은 지정된 고객에 대한 주소 목록을 보유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="954bb-106">실제 형식에 관계없이 이러한 컬렉션을 *목록 컬렉션*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-106">These collections are called *list collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="954bb-107">하나의 항목("키")과 다른 항목("값") 간의 연결을 나타내는 특별한 형태의 컬렉션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="954bb-108">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]에서 해당 컬렉션은 <xref:System.Collections.Hashtable> 및 제네릭 사전과 같은 형식으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-108">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="954bb-109">예를 들어, 연결 컬렉션은 도시("키")를 해당 도시의 인구("값")에 매핑할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="954bb-110">실제 형식에 관계없이 이러한 컬렉션을 *사전 컬렉션*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="954bb-111">데이터 계약 모델에서 컬렉션은 별도로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-111">Collections receive special treatment in the data contract model.</span></span>  
  
 <span data-ttu-id="954bb-112">배열 및 제네릭 컬렉션을 비롯하여 <xref:System.Collections.IEnumerable> 인터페이스를 구현하는 형식은 컬렉션으로 인식됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="954bb-113">이 중에서 <xref:System.Collections.IDictionary> 또는 제네릭 <xref:System.Collections.Generic.IDictionary%602> 인터페이스를 구현하는 형식은 사전 컬렉션이며, 다른 모든 형식은 목록 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>  
  
 <span data-ttu-id="954bb-114">`Add` 라는 메서드 및 기본 생성자를 사용하는 등 컬렉션 형식에 대한 추가 요구 사항은 다음 단원에서 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-114">Additional requirements on collection types, such as having a method called `Add` and a default constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="954bb-115">이렇게 하면 컬렉션 형식이 serialize되고 deserialize될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="954bb-116">따라서 기본 생성자가 없는 제네릭 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 과 같은 일부 컬렉션은 직접 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no default constructor).</span></span> <span data-ttu-id="954bb-117">이러한 제한을 해결하는 방법에 대한 자세한 내용은 이 항목의 뒷부분에 있는 "컬렉션 인터페이스 형식 및 읽기 전용 컬렉션 사용" 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>  
  
 <span data-ttu-id="954bb-118">컬렉션에 포함된 형식은 데이터 계약 형식이거나 serialize할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="954bb-119"> [데이터 계약 Serializer에서 지 원하는 형식](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-119"> [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span>  
  
 <span data-ttu-id="954bb-120">유효한 것으로 간주되는 컬렉션과 그렇지 않은 컬렉션 그리고 컬렉션을 serialize하는 방법[!INCLUDE[crabout](../../../../includes/crabout-md.md)] 이 항목에 있는 "고급 컬렉션 규칙" 단원의 컬렉션 serialize에 대한 내용을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-120">[!INCLUDE[crabout](../../../../includes/crabout-md.md)] what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>  
  
## <a name="interchangeable-collections"></a><span data-ttu-id="954bb-121">교환 가능 컬렉션</span><span class="sxs-lookup"><span data-stu-id="954bb-121">Interchangeable Collections</span></span>  
 <span data-ttu-id="954bb-122">동일한 형식의 모든 목록 컬렉션은 이 항목 뒷부분에서 설명하는 것처럼 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 사용하여 사용자 지정되지 않는 한 동일한 데이터 계약을 가지는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="954bb-123">예를 들어, 다음 데이터 계약은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-123">Thus, for example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
 [!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]  
  
 <span data-ttu-id="954bb-124">두 데이터 계약 모두 다음 코드와 유사한 XML이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-124">Both data contracts result in XML similar to the following code.</span></span>  
  
```xml  
<PurchaseOrder>  
    <customerName>...</customerName>  
    <items>  
        <Item>...</Item>  
        <Item>...</Item>  
        <Item>...</Item>  
        ...  
    </items>  
    <comments>  
        <string>...</string>  
        <string>...</string>  
        <string>...</string>  
        ...  
    </comments>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="954bb-125">예를 들어, 컬렉션 교환 가능성을 통해 서버의 성능에 맞게 최적화된 컬렉션 형식 및 클라이언트의 사용자 인터페이스 구성 요소에 바인딩되도록 디자인된 컬렉션 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>  
  
 <span data-ttu-id="954bb-126">목록 컬렉션과 마찬가지로 동일한 키 및 값 형식이 있는 모든 사전 컬렉션은 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 사용하여 사용자 지정되지 않는 한 동일한 데이터 계약을 가지는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>  
  
 <span data-ttu-id="954bb-127">컬렉션 일치에 있어서는 .NET 형식이 아닌 데이터 계약 형식만 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="954bb-128">즉, Type1 및 Type2에 동일한 데이터 계약이 있는 경우 Type1의 컬렉션과 Type2의 컬렉션이 동일하다고 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>  
  
 <span data-ttu-id="954bb-129">제네릭이 아닌 컬렉션에는 `Object`형식의 제네릭 컬렉션과 동일한 데이터 계약이 있는 것으로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="954bb-130">예를 들어, <xref:System.Collections.ArrayList> 의 데이터 계약 및 <xref:System.Collections.Generic.List%601> 의 제네릭 `Object` 은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>  
  
## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="954bb-131">컬렉션 인터페이스 형식 및 읽기 전용 컬렉션 사용</span><span class="sxs-lookup"><span data-stu-id="954bb-131">Using Collection Interface Types and Read-Only Collections</span></span>  
 <span data-ttu-id="954bb-132">또한 컬렉션 인터페이스 형식(<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, 제네릭 <xref:System.Collections.Generic.IDictionary%602>또는 이러한 인터페이스에서 파생된 인터페이스)에는 실제 컬렉션 형식의 컬렉션 데이터 계약과 동일한 컬렉션 데이터 계약이 있는 것으로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="954bb-133">따라서 serialize되는 형식을 컬렉션 인터페이스 형식으로 선언할 수 있으며, 결과는 실제 컬렉션 형식을 사용한 것과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="954bb-134">예를 들어, 다음 데이터 계약은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-134">For example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
 [!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]  
  
 <span data-ttu-id="954bb-135">serialization을 수행하는 동안 선언된 형식이 인터페이스인 경우 사용된 실제 인스턴스 형식은 해당 인터페이스를 구현하는 모든 형식이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="954bb-136">앞에서 설명한 제한 사항(기본 생성자 및 `Add` 메서드를 사용)은 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-136">Restrictions discussed previously (having a default constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="954bb-137">예를 들어, 제네릭 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 형식의 데이터 멤버를 직접 선언할 수 없는 경우에도 Customer2의 주소를 제네릭 주소 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>의 인스턴스로 설정할 수 있습니다</span><span class="sxs-lookup"><span data-stu-id="954bb-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>  
  
 <span data-ttu-id="954bb-138">deserialization을 수행하는 동안 선언된 형식이 인터페이스인 경우 serialization 엔진은 선언된 인터페이스를 구현하는 형식을 선택하고, 해당 형식은 인스턴스화됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="954bb-139">알려진 형식 메커니즘은 (에 설명 된 [데이터 계약 알려진 형식을](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) 아무 효과가 없습니다 선택한 형식 변환은에 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-139">The known types mechanism (described in [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) has no effect here; the choice of type is built into [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span>  
  
## <a name="customizing-collection-types"></a><span data-ttu-id="954bb-140">컬렉션 형식 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="954bb-140">Customizing Collection Types</span></span>  
 <span data-ttu-id="954bb-141">여러 용도로 사용되는 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 사용하여 컬렉션 형식을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>  
  
 <span data-ttu-id="954bb-142">컬렉션 형식을 사용자 지정하면 컬렉션 교환 가능성이 낮아지므로 가능하면 이 특성을 적용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="954bb-143">이 문제에 대한[!INCLUDE[crabout](../../../../includes/crabout-md.md)] 는 이 항목의 뒷부분에 있는 "고급 컬렉션 규칙" 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-143">[!INCLUDE[crabout](../../../../includes/crabout-md.md)] this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="collection-data-contract-naming"></a><span data-ttu-id="954bb-144">컬렉션 데이터 계약 명명</span><span class="sxs-lookup"><span data-stu-id="954bb-144">Collection Data Contract Naming</span></span>  
 <span data-ttu-id="954bb-145">컬렉션 형식의 명명 규칙은 [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md)에서 설명한 대로 일반 데이터 계약 형식의 명명 규칙과 유사하지만, 다음과 같은 중요한 차이점이 몇 개 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), although some important differences exist:</span></span>  
  
-   <span data-ttu-id="954bb-146"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성은 <xref:System.Runtime.Serialization.DataContractAttribute> 특성 대신 이름을 사용자 지정하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="954bb-147">또한 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성에는 `Name` 및 `Namespace` 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>  
  
-   <span data-ttu-id="954bb-148"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성이 적용되지 않는 경우 컬렉션 형식의 기본 이름 및 네임스페이스는 컬렉션에 포함된 형식의 이름 및 네임스페이스에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="954bb-149">컬렉션 형식의 이름 및 네임스페이스 자체는 컬렉션에 포함된 형식의 이름 및 네임스페이스에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="954bb-150">@FSHO1@예를 보려면 다음 형식을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-150">For an example, see the following types.</span></span>  
  
    ```  
    public CustomerList1 : Collection<string> {}  
    public StringList1 : Collection<string> {}  
    ```  
  
 <span data-ttu-id="954bb-151">두 형식의 데이터 계약 이름이 모두 "ArrayOfstring"이고 "CustomerList1" 또는 "StringList1"이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="954bb-152">즉, 루트 수준의 이러한 형식 중 하나를 serialize하면 다음 코드와 유사한 XML이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>  
  
```xml  
<ArrayOfstring>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</ArrayOfstring>  
```  
  
 <span data-ttu-id="954bb-153">문자열의 목록을 나타내는 사용자 지정되지 않은 형식에 동일한 데이터 계약 및 XML 표현이 있도록 이 명명 규칙을 선택했습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="954bb-154">이렇게 하면 컬렉션 교환이 가능하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="954bb-155">이 예제에서 CustomerList1과 StringList1은 완벽하게 교환 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>  
  
 <span data-ttu-id="954bb-156">그러나 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성이 적용된 경우 속성을 특성에 설정하지 않아도 컬렉션은 사용자 지정된 컬렉션 데이터 계약이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="954bb-157">따라서 컬렉션 데이터 계약의 이름 및 네임스페이스는 컬렉션 형식 자체에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="954bb-158">예를 보려면 다음 형식을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-158">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
 [!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]  
  
 <span data-ttu-id="954bb-159">serialize된 결과 XML은 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-159">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList2>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</CustomerList2>  
```  
  
 <span data-ttu-id="954bb-160">결과 XML은 사용자 지정되지 않은 형식의 XML 표현과 더 이상 동일하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>  
  
-   <span data-ttu-id="954bb-161">`Name` 및 `Namespace` 속성을 사용하여 명명을 추가로 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="954bb-162">다음 클래스를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-162">See the following class.</span></span>  
  
     [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
     [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]  
  
 <span data-ttu-id="954bb-163">결과 XML은 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-163">The resulting XML is similar to the following.</span></span>  
  
```xml  
<cust_list>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</cust_list>  
```  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="954bb-164"> 이 항목의 뒷부분에 나오는 "고급 컬렉션 규칙" 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-164"> the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="954bb-165">목록 컬렉션의 반복되는 요소 이름 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="954bb-165">Customizing the Repeating Element Name in List Collections</span></span>  
 <span data-ttu-id="954bb-166">목록 컬렉션에는 반복되는 항목이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-166">List collections contain repeating entries.</span></span> <span data-ttu-id="954bb-167">일반적으로 반복되는 각 항목은 컬렉션에 포함된 형식의 데이터 계약 이름에 따라 명명된 요소로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>  
  
 <span data-ttu-id="954bb-168">`CustomerList` 예제에서 컬렉션에는 문자열이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="954bb-169">문자열 기본 형식의 데이터 계약 이름을 반복 되는 요소 기간은 "문자열"은 "\<문자열 >"입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>  
  
 <span data-ttu-id="954bb-170">그러나 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> 특성의 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 속성을 사용하여 이 반복되는 요소 이름을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="954bb-171">예를 보려면 다음 형식을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-171">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
 [!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]  
  
 <span data-ttu-id="954bb-172">결과 XML은 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-172">The resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList4>  
    <customer>...</customer>  
    <customer>...</customer>  
    <customer>...</customer>  
    ...  
</CustomerList4>  
```  
  
 <span data-ttu-id="954bb-173">반복되는 요소의 네임스페이스는 앞에서 설명한 대로 `Namespace` 속성을 사용하여 사용자 지정할 수 있는 컬렉션 데이터 계약의 네임스페이스와 항상 같습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>  
  
### <a name="customizing-dictionary-collections"></a><span data-ttu-id="954bb-174">사전 컬렉션 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="954bb-174">Customizing Dictionary Collections</span></span>  
 <span data-ttu-id="954bb-175">사전 컬렉션은 기본적으로 항목의 목록이며 각 항목에는 키 다음에 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="954bb-176">일반 목록과 마찬가지로 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> 속성을 사용하여 반복되는 요소에 해당하는 요소 이름을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>  
  
 <span data-ttu-id="954bb-177">또한 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> 및 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> 속성을 사용하여 키 및 값을 나타내는 요소 이름을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="954bb-178">이러한 요소의 네임스페이스는 컬렉션 데이터 계약의 네임스페이스와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>  
  
 <span data-ttu-id="954bb-179">예를 보려면 다음 형식을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-179">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
 [!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]  
  
 <span data-ttu-id="954bb-180">serialize된 결과 XML은 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-180">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CountriesOrRegionsWithCapitals>  
    <entry>  
        <countryorregion>USA</countryorregion>  
        <capital>Washington</capital>  
    </entry>  
    <entry>  
        <countryorregion>France</countryorregion>  
        <capital>Paris</capital>  
    </entry>  
    ...  
</CountriesOrRegionsWithCapitals>  
```  
  
 <span data-ttu-id="954bb-181">사전 컬렉션에 대한[!INCLUDE[crabout](../../../../includes/crabout-md.md)] 는 이 항목의 뒷부분에 있는 "고급 컬렉션 규칙" 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-181">[!INCLUDE[crabout](../../../../includes/crabout-md.md)] dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
## <a name="collections-and-known-types"></a><span data-ttu-id="954bb-182">컬렉션 및 알려진 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-182">Collections and Known Types</span></span>  
 <span data-ttu-id="954bb-183">컬렉션 형식을 다른 컬렉션이나 컬렉션 인터페이스 대신 다형적으로 사용하는 경우 알려진 형식에 추가할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="954bb-184">예를 들어, <xref:System.Collections.IEnumerable> 형식의 데이터 멤버를 선언하고 이를 사용하여 <xref:System.Collections.ArrayList>의 인스턴스를 보내는 경우 <xref:System.Collections.ArrayList> 를 알려진 형식에 추가할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="954bb-185">비컬렉션 형식 대신 다형적으로 컬렉션을 사용하는 경우에는 알려진 형식에 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="954bb-186">예를 들어, `Object` 형식의 데이터 멤버를 선언하고 이를 사용하여 <xref:System.Collections.ArrayList>의 인스턴스를 보내는 경우 알려진 형식에 <xref:System.Collections.ArrayList> 를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="954bb-187">그러나 동일한 컬렉션을 다형적으로 serialize할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="954bb-188">예를 들어, <xref:System.Collections.ArrayList> 를 위 예제의 알려진 형식의 목록에 추가하는 경우 해당 목록에 동일한 데이터 계약이 있더라도 `Array of Object` 클래스를 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="954bb-189">따라서 비컬렉션 형식에 대한 serialization에서 알려진 형식의 일반 동작과 차이는 없지만, 컬렉션이 동일한 경우가 매우 일반적이기 때문에 컬렉션의 경우 이 동작을 이해하는 것이 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>  
  
 <span data-ttu-id="954bb-190">serialization을 수행하는 동안 지정된 데이터 계약의 지정된 범위에서 하나의 형식만을 알 수 있으며 모든 동일한 컬렉션에는 같은 데이터 계약이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="954bb-191">따라서 위 예제에서 <xref:System.Collections.ArrayList> 및 `Array of Object` 모두를 같은 범위의 알려진 형식에 추가할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="954bb-192">이 동작은 비컬렉션 형식에 대한 알려진 형식 동작과 동일하지만, 컬렉션의 경우 이를 이해하는 것이 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>  
  
 <span data-ttu-id="954bb-193">알려진 형식은 또한 컬렉션의 내용에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="954bb-194">예를 들어, <xref:System.Collections.ArrayList> 에 `Type1` 및 `Type2`의 인스턴스가 실제로 있는 경우 이 두 가지 형식 모두 알려진 형식에 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>  
  
 <span data-ttu-id="954bb-195">다음 예제에서는 컬렉션 및 알려진 형식을 사용하여 올바르게 생성된 개체 그래프를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="954bb-196">일반적으로 실제 응용 프로그램에서는 다음 데이터 멤버를 `Object`로 정의하지 않고 알려진 형식/다형성 문제가 없기 때문에 이 예제는 실제와 다소 거리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
 [!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]  
  
 <span data-ttu-id="954bb-197">deserialization에서 선언된 형식이 컬렉션 형식이면 실제로 보낸 형식과 관계없이 선언된 형식이 인스턴스화됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="954bb-198">선언된 형식이 컬렉션 인터페이스이면 deserializer에서는 알려진 형식과 관계없이 인스턴스화할 형식을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>  
  
 <span data-ttu-id="954bb-199">또한 deserialization에서 선언된 형식이 컬렉션 형식은 아니지만 컬렉션 형식을 보내는 경우 일치하는 컬렉션 형식이 알려진 형식 목록에서 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="954bb-200">deserialization에서 컬렉션 인터페이스 형식을 알려진 형식 목록에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="954bb-201">이 경우 deserialization 엔진은 인스턴스화할 형식을 다시 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>  
  
## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="954bb-202">컬렉션 및 NetDataContractSerializer 클래스</span><span class="sxs-lookup"><span data-stu-id="954bb-202">Collections and the NetDataContractSerializer Class</span></span>  
 <span data-ttu-id="954bb-203"><xref:System.Runtime.Serialization.NetDataContractSerializer> 클래스가 사용 중인 경우 배열이 아닌 사용자 지정되지 않은 컬렉션 형식( <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성이 없는 컬렉션)은 원래의 특수한 의미를 잃게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>  
  
 <span data-ttu-id="954bb-204"><xref:System.SerializableAttribute> 특성으로 표시된 사용자 지정되지 않은 컬렉션 형식은 <xref:System.Runtime.Serialization.NetDataContractSerializer> 특성이나 <xref:System.SerializableAttribute> 인터페이스 규칙에 따라 <xref:System.Runtime.Serialization.ISerializable> 클래스로 여전히 serialize할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>  
  
 <span data-ttu-id="954bb-205">사용자 지정된 컬렉션 형식, 컬렉션 인터페이스 및 배열은 <xref:System.Runtime.Serialization.NetDataContractSerializer> 클래스가 사용 중인 경우에도 컬렉션으로서 계속 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>  
  
## <a name="collections-and-schema"></a><span data-ttu-id="954bb-206">컬렉션 및 스키마</span><span class="sxs-lookup"><span data-stu-id="954bb-206">Collections and Schema</span></span>  
 <span data-ttu-id="954bb-207">모든 동일한 컬렉션에는 동일한 표현의 XSD(XML 스키마 정의 언어) 스키마가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="954bb-208">이 때문에 일반적으로 서버의 컬렉션 형식과 동일한 컬렉션 형식을 생성된 클라이언트 코드에서 얻을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="954bb-209">예를 들어, 서버에서 정수 데이터 멤버의 제네릭 <xref:System.Collections.Generic.List%601> 와 함께 데이터 계약을 사용할 수 있지만, 생성된 클라이언트 코드에서 동일한 데이터 멤버가 정수 배열이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>  
  
 <span data-ttu-id="954bb-210">사전 컬렉션은 사전임을 나타내는 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]관련 스키마 주석으로 표시됩니다. 그렇지 않으면 키 및 값을 가진 항목이 포함된 단순 목록과 사전 컬렉션이 구분될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-210">Dictionary collections are marked with a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="954bb-211">데이터 계약 스키마에서 컬렉션이 표시되는 방법에 대한 정확한 설명은 [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>  
  
 <span data-ttu-id="954bb-212">기본적으로 가져온 코드의 사용자 지정되지 않은 컬렉션에 대해서는 형식이 생성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="954bb-213">목록 컬렉션 형식의 데이터 멤버는 배열로 가져오며, 사전 컬렉션 형식의 데이터 멤버는 제네릭 사전으로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>  
  
 <span data-ttu-id="954bb-214">그러나 사용자 지정된 컬렉션의 경우 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성으로 표시되는 별도의 형식이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="954bb-215">스키마에서 사용자 지정된 컬렉션 형식은 기본 네임스페이스, 이름, 반복되는 요소 이름 또는 키/값 요소 이름을 사용하지 않습니다. 이러한 형식은 목록 형식의 경우 제네릭 <xref:System.Collections.Generic.List%601>에서 파생되고, 사전 형식의 경우 제네릭 사전에서 파생되는 빈 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>  
  
 <span data-ttu-id="954bb-216">예를 들어, 서버에 다음 형식이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-216">For example, you may have the following types on the server.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
 [!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]  
  
 <span data-ttu-id="954bb-217">스키마를 내보내고 다시 가져온 경우 생성되는 클라이언트 코드는 다음과 유사합니다. 읽기 용이하도록 속성 대신 필드가 표시되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
 [!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]  
  
 <span data-ttu-id="954bb-218">생성된 코드에서 기본 형식 대신 다른 형식을 사용해야 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="954bb-219">예를 들어, 사용자 인터페이스 구성 요소에 쉽게 바인딩할 수 있도록 데이터 멤버의 일반 배열 대신 제네릭 <xref:System.ComponentModel.BindingList%601> 를 사용해야 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>  
  
 <span data-ttu-id="954bb-220">생성할 컬렉션 형식을 선택하려면 스키마를 가져올 때 사용할 컬렉션 형식의 목록을 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> 개체의 <xref:System.Runtime.Serialization.ImportOptions> 속성에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="954bb-221">이러한 형식을 *참조된 컬렉션 형식*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-221">These types are called *referenced collection types*.</span></span>  
  
 <span data-ttu-id="954bb-222">제네릭 형식을 참조할 때 해당 제네릭 형식은 완전 개방형 제네릭 형식 또는 완전 폐쇄형 제네릭 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="954bb-223">Svcutil.exe 도구를 사용하는 경우 **/collectionType** 명령줄 스위치(약식: **/ct**)를 사용하여 이 참조를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="954bb-224">또한 **/reference** 스위치(약식: **/r**)를 사용하여 참조된 컬렉션 형식에 대한 어셈블리를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="954bb-225">형식이 제네릭이면 뒤에는 역따옴표 및 제네릭 매개 변수의 수가 와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="954bb-226">역따옴표(\`)를 작은따옴표(‘) 문자와 혼동해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="954bb-227">**/collectionType** 스위치를 두 번 이상 사용하여 여러 개의 참조된 컬렉션 형식을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>  
  
 <span data-ttu-id="954bb-228">예를 들어, 모든 목록을 제네릭 <xref:System.Collections.Generic.List%601>로 가져오려면 다음을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>  
  
```  
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1  
```  
  
 <span data-ttu-id="954bb-229">컬렉션을 가져올 때 이 참조된 컬렉션 형식 목록을 검색한 다음 사용자 지정되지 않은 컬렉션의 경우 데이터 멤버 형식으로 컬렉션을 찾거나, 사용자 지정된 컬렉션의 경우 파생될 기본 형식으로 컬렉션을 찾아 가장 일치하는 컬렉션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="954bb-230">사전은 사전에 대해서만 일치하며 목록은 목록에 대해서만 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>  
  
 <span data-ttu-id="954bb-231">예를 들어, 제네릭 <xref:System.ComponentModel.BindingList%601> 및 <xref:System.Collections.Hashtable> 을 참조된 형식 목록에 추가하면 앞의 예제에서 생성된 클라이언트 코드는 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
 [!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]  
  
 <span data-ttu-id="954bb-232">컬렉션 인터페이스 형식을 참조된 컬렉션 형식의 일부로 지정할 수 있지만 `Add` 메서드 또는 public 생성자가 없는 컬렉션 형식과 같은 잘못된 컬렉션 형식을 지정할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>  
  
 <span data-ttu-id="954bb-233">폐쇄형 제네릭이 가장 일치하는 항목으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="954bb-234">제네릭이 아닌 형식은 `Object`의 폐쇄형 제네릭과 동일한 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="954bb-235">예를 들어, <xref:System.Collections.Generic.List%601> 의 제네릭 <xref:System.DateTime>, 제네릭 <xref:System.ComponentModel.BindingList%601> (개방형 제네릭) 및 <xref:System.Collections.ArrayList> 형식이 참조된 컬렉션 형식이면 다음이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
 [!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]  
  
 <span data-ttu-id="954bb-236">목록 컬렉션에서는 다음 표에 있는 것과 같은 경우만 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-236">For list collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="954bb-237">참조된 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-237">Referenced type</span></span>|<span data-ttu-id="954bb-238">참조된 형식으로 구현된 인터페이스</span><span class="sxs-lookup"><span data-stu-id="954bb-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="954bb-239">예제</span><span class="sxs-lookup"><span data-stu-id="954bb-239">Example</span></span>|<span data-ttu-id="954bb-240">처리되는 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-240">Type treated as:</span></span>|  
|---------------------|----------------------------------------------|-------------|----------------------|  
|<span data-ttu-id="954bb-241">제네릭이 아닌 형식 또는 폐쇄형 제네릭 형식(매개 변수 수에는 제한 없음)</span><span class="sxs-lookup"><span data-stu-id="954bb-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="954bb-242">제네릭이 아닌 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="954bb-243">또는</span><span class="sxs-lookup"><span data-stu-id="954bb-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="954bb-244">여기서 T= `int`</span><span class="sxs-lookup"><span data-stu-id="954bb-244">where T= `int`</span></span>|<span data-ttu-id="954bb-245">`Object` 의 폐쇄형 제네릭 형식(예: `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="954bb-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|  
|<span data-ttu-id="954bb-246">제네릭이 아닌 형식 또는 폐쇄형 제네릭 형식(컬렉션 형식과 일치하지 않아도 되는 임의의 수의 매개 변수)</span><span class="sxs-lookup"><span data-stu-id="954bb-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="954bb-247">폐쇄형 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="954bb-248">또는</span><span class="sxs-lookup"><span data-stu-id="954bb-248">or</span></span><br /><br /> <span data-ttu-id="954bb-249">`MyType<T> : IList<string>` 여기서 T=`int`</span><span class="sxs-lookup"><span data-stu-id="954bb-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="954bb-250">폐쇄형 제네릭 형식(예: `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="954bb-250">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="954bb-251">여러 개의 매개 변수가 있는 폐쇄형 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="954bb-252">형식의 매개 변수 중 하나를 사용하는 개방형 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="954bb-253">여기서 T=`int`, U=`string`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="954bb-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="954bb-254">폐쇄형 제네릭 형식(예: `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="954bb-254">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="954bb-255">하나의 매개 변수가 있는 개방형 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-255">Open generic with one parameter</span></span>|<span data-ttu-id="954bb-256">형식의 매개 변수를 사용하는 개방형 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="954bb-257">`MyType<T> : IList<T>`, T는 개방형</span><span class="sxs-lookup"><span data-stu-id="954bb-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="954bb-258">개방형 제네릭 형식(예: `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="954bb-258">Open generic (for example, `IList<T>`)</span></span>|  
  
 <span data-ttu-id="954bb-259">형식에서 두 개 이상의 목록 컬렉션 인터페이스를 구현하는 경우 다음 제한 사항이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="954bb-260">형식에서 제네릭 <xref:System.Collections.Generic.IEnumerable%601> 또는 파생된 인터페이스를 다른 형식으로 여러 번 구현하는 경우 해당 형식은 유효한 참조된 컬렉션 형식으로 간주되지 않고 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="954bb-261">일부 구현이 잘못된 경우 또는 개방형 제네릭을 사용하는 경우에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="954bb-262">예를 들어, <xref:System.Collections.Generic.IEnumerable%601> 의 제네릭 `int` 및 T의 제네릭 <xref:System.Collections.Generic.IEnumerable%601> 을 구현하는 형식은 `int` 를 허용하는 `Add` 메서드, T 형식의 매개 변수를 허용하는 `int` 메서드 또는 두 메서드 모두가 해당 형식에 있는지 여부와 관계없이 `Add` 또는 다른 형식의 참조된 컬렉션으로 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>  
  
-   <span data-ttu-id="954bb-263">형식에서 <xref:System.Collections.IList>및 제네릭 컬렉션 인터페이스를 구현하는 경우 제네릭 컬렉션 인터페이스가 <xref:System.Object>형식의 폐쇄형 제네릭이 아니면 해당 형식은 참조된 컬렉션 형식으로 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="954bb-264">사전 컬렉션에서는 다음 표에 있는 것과 같은 경우만 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-264">For dictionary collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="954bb-265">참조된 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-265">Referenced type</span></span>|<span data-ttu-id="954bb-266">참조된 형식으로 구현된 인터페이스</span><span class="sxs-lookup"><span data-stu-id="954bb-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="954bb-267">예제</span><span class="sxs-lookup"><span data-stu-id="954bb-267">Example</span></span>|<span data-ttu-id="954bb-268">처리되는 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-268">Type treated as</span></span>|  
|---------------------|----------------------------------------------|-------------|---------------------|  
|<span data-ttu-id="954bb-269">제네릭이 아닌 형식 또는 폐쇄형 제네릭 형식(매개 변수 수에는 제한 없음)</span><span class="sxs-lookup"><span data-stu-id="954bb-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="954bb-270">또는</span><span class="sxs-lookup"><span data-stu-id="954bb-270">or</span></span><br /><br /> <span data-ttu-id="954bb-271">`MyType<T> : IDictionary` 여기서 T=`int`</span><span class="sxs-lookup"><span data-stu-id="954bb-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="954bb-272">폐쇄형 제네릭 형식(예: `IDictionary<object,object>`)</span><span class="sxs-lookup"><span data-stu-id="954bb-272">Closed generic `IDictionary<object,object>`</span></span>|  
|<span data-ttu-id="954bb-273">폐쇄형 제네릭 형식(여러 개의 매개 변수)</span><span class="sxs-lookup"><span data-stu-id="954bb-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="954bb-274"><xref:System.Collections.Generic.IDictionary%602>, 폐쇄형</span><span class="sxs-lookup"><span data-stu-id="954bb-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="954bb-275">`MyType<T> : IDictionary<string, bool>` 여기서 T =`int`</span><span class="sxs-lookup"><span data-stu-id="954bb-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="954bb-276">폐쇄형 제네릭 형식(예: `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="954bb-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|  
|<span data-ttu-id="954bb-277">폐쇄형 제네릭 형식(여러 개의 매개 변수)</span><span class="sxs-lookup"><span data-stu-id="954bb-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="954bb-278">제네릭 <xref:System.Collections.Generic.IDictionary%602>, 값 또는 키 중 하나가 폐쇄형이며, 나머지 하나는 개방형이고 형식의 매개 변수 중 하나를 사용</span><span class="sxs-lookup"><span data-stu-id="954bb-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="954bb-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span><span class="sxs-lookup"><span data-stu-id="954bb-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="954bb-280">또는</span><span class="sxs-lookup"><span data-stu-id="954bb-280">or</span></span><br /><br /> <span data-ttu-id="954bb-281">`MyType<Z> : IDictionary<Z,bool>` 여기서 Z =`string`</span><span class="sxs-lookup"><span data-stu-id="954bb-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="954bb-282">폐쇄형 제네릭 형식(예: `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="954bb-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|  
|<span data-ttu-id="954bb-283">폐쇄형 제네릭 형식(여러 개의 매개 변수)</span><span class="sxs-lookup"><span data-stu-id="954bb-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="954bb-284">제네릭 <xref:System.Collections.Generic.IDictionary%602>, 키와 값 모두 개방형이고 각각은 형식의 매개 변수 중 하나를 사용</span><span class="sxs-lookup"><span data-stu-id="954bb-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="954bb-285">`MyType<T,U,V> : IDictionary<V,U>` 여기서 T=`int`, U=`bool`, V=`string`</span><span class="sxs-lookup"><span data-stu-id="954bb-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="954bb-286">폐쇄형 제네릭 형식(예: `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="954bb-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|  
|<span data-ttu-id="954bb-287">개방형 제네릭 형식(두 개의 매개 변수)</span><span class="sxs-lookup"><span data-stu-id="954bb-287">Open generic (two parameters)</span></span>|<span data-ttu-id="954bb-288">제네릭 <xref:System.Collections.Generic.IDictionary%602>, 개방형, 형식의 제네릭 매개 변수가 나타나는 순서대로 두 개의 매개 변수 모두 사용</span><span class="sxs-lookup"><span data-stu-id="954bb-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="954bb-289">`MyType<K,V> : IDictionary<K,V>`, K와 V 모두 개방형</span><span class="sxs-lookup"><span data-stu-id="954bb-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="954bb-290">개방형 제네릭 형식(예: `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="954bb-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|  
  
 <span data-ttu-id="954bb-291">형식에서 <xref:System.Collections.IDictionary> 및 제네릭 <xref:System.Collections.Generic.IDictionary%602>를 모두 구현하는 경우 제네릭 <xref:System.Collections.Generic.IDictionary%602> 만 고려됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>  
  
 <span data-ttu-id="954bb-292">부분 제네릭 형식의 참조는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-292">Referencing partial generic types is not supported.</span></span>  
  
 <span data-ttu-id="954bb-293">예를 들어, 중복은 허용되지 않으므로 <xref:System.Collections.Generic.List%601> 의 제네릭 `Integer` 및 `Integer` 의 제네릭 컬렉션을 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>에 모두 추가할 수는 없습니다. 이는 정수 목록이 스키마에 있는 경우 사용할 대상을 결정할 수 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="954bb-294">중복 문제를 노출하는 형식이 스키마에 있는 경우에만 중복이 감지됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="954bb-295">예를 들어, 가져오는 스키마에 정수 목록이 없는 경우 <xref:System.Collections.Generic.List%601> 의 제네릭 `Integer` 및 `Integer` 에 있는 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>의 제네릭 컬렉션을 모두 포함할 수 있지만 둘 다 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>  
  
## <a name="advanced-collection-rules"></a><span data-ttu-id="954bb-296">고급 컬렉션 규칙</span><span class="sxs-lookup"><span data-stu-id="954bb-296">Advanced Collection Rules</span></span>  
  
### <a name="serializing-collections"></a><span data-ttu-id="954bb-297">컬렉션 serialize</span><span class="sxs-lookup"><span data-stu-id="954bb-297">Serializing Collections</span></span>  
 <span data-ttu-id="954bb-298">컬렉션 serialization 규칙 목록은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-298">The following is a list of collection rules for serialization:</span></span>  
  
-   <span data-ttu-id="954bb-299">컬렉션의 컬렉션이 있는 컬렉션 형식의 결합이 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="954bb-300">가변 배열은 컬렉션의 컬렉션으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="954bb-301">다차원 배열은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-301">Multidimensional arrays are not supported.</span></span>  
  
-   <span data-ttu-id="954bb-302">바이트의 배열 및 <xref:System.Xml.XmlNode> 의 배열은 컬렉션이 아닌 기본 형식으로 처리되는 특수 배열 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="954bb-303">바이트의 배열을 serialize하면 각 바이트에 대한 별도의 요소 대신 Base64 인코딩된 데이터의 청크가 포함된 하나의 XML 요소가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="954bb-304"> 배열의 처리 방법에 대한 <xref:System.Xml.XmlNode> 는 [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="954bb-304"> how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="954bb-305">물론 이러한 특수 형식은 컬렉션에 참여할 수 있습니다. 바이트 배열의 배열은 여러 XML 요소가 되며 각 요소는 Base64 인코딩된 데이터의 청크를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>  
  
-   <span data-ttu-id="954bb-306"><xref:System.Runtime.Serialization.DataContractAttribute> 특성이 컬렉션 형식에 적용되는 경우 해당 형식은 컬렉션이 아닌 일반 데이터 계약 형식으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>  
  
-   <span data-ttu-id="954bb-307">컬렉션 형식이 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스를 구현하는 경우 `myType:IList<string>, IXmlSerializable`형식이 지정된 다음 규칙이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>  
  
    -   <span data-ttu-id="954bb-308">선언된 형식이 `IList<string>`인 경우 형식이 목록으로 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>  
  
    -   <span data-ttu-id="954bb-309">선언된 형식이 `myType`인 경우 형식이 `IXmlSerializable`로 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>  
  
    -   <span data-ttu-id="954bb-310">선언된 형식이 `IXmlSerializable`인 경우 `IXmlSerializable`로 serialize되지만 `myType` 을 알려진 형식 목록에 추가하는 경우에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>  
  
-   <span data-ttu-id="954bb-311">컬렉션은 다음 표에 나와 있는 메서드를 사용하여 serialize되고 deserialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>  
  
|<span data-ttu-id="954bb-312">컬렉션 형식에서 구현하는 인터페이스</span><span class="sxs-lookup"><span data-stu-id="954bb-312">Collection type implements</span></span>|<span data-ttu-id="954bb-313">serialization에서 호출된 메서드</span><span class="sxs-lookup"><span data-stu-id="954bb-313">Method(s) called on serialization</span></span>|<span data-ttu-id="954bb-314">deserialization에서 호출된 메서드</span><span class="sxs-lookup"><span data-stu-id="954bb-314">Method(s) called on deserialization</span></span>|  
|--------------------------------|-----------------------------------------|-------------------------------------------|  
|<span data-ttu-id="954bb-315">제네릭 <xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="954bb-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="954bb-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="954bb-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="954bb-317">제네릭 Add</span><span class="sxs-lookup"><span data-stu-id="954bb-317">Generic Add</span></span>|  
|<xref:System.Collections.IDictionary>|<span data-ttu-id="954bb-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="954bb-318">`get_Keys`, `get_Values`</span></span>|`Add`|  
|<span data-ttu-id="954bb-319">제네릭 <xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="954bb-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="954bb-320">제네릭 <xref:System.Collections.Generic.IList%601> 인덱서</span><span class="sxs-lookup"><span data-stu-id="954bb-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="954bb-321">제네릭 Add</span><span class="sxs-lookup"><span data-stu-id="954bb-321">Generic Add</span></span>|  
|<span data-ttu-id="954bb-322">제네릭 <xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="954bb-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="954bb-323">열거자</span><span class="sxs-lookup"><span data-stu-id="954bb-323">Enumerator</span></span>|<span data-ttu-id="954bb-324">제네릭 Add</span><span class="sxs-lookup"><span data-stu-id="954bb-324">Generic Add</span></span>|  
|<xref:System.Collections.IList>|<span data-ttu-id="954bb-325"><xref:System.Collections.IList> 인덱서</span><span class="sxs-lookup"><span data-stu-id="954bb-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|  
|<span data-ttu-id="954bb-326">제네릭 <xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="954bb-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="954bb-327">적절한 형식(제네릭 매개 변수의 형식 또는 기본 형식 중 하나)의 매개 변수 하나를 사용하는 `Add` 라는 비정적 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="954bb-328">해당 메서드는 serialization 및 deserialization을 수행하는 동안 serializer에서 컬렉션 형식을 컬렉션으로 처리하도록 존재해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
|<span data-ttu-id="954bb-329"><xref:System.Collections.IEnumerable> 및 여기서 파생된 <xref:System.Collections.ICollection></span><span class="sxs-lookup"><span data-stu-id="954bb-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="954bb-330">`Add` 형식의 매개 변수 하나를 사용하는 `Object`라는 비정적 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="954bb-331">해당 메서드는 serialization 및 deserialization을 수행하는 동안 serializer에서 컬렉션 형식을 컬렉션으로 처리하도록 존재해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
  
 <span data-ttu-id="954bb-332">위 표에는 컬렉션 인터페이스의 우선 순위가 내림차순으로 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="954bb-333">예를 들어, 형식에서 <xref:System.Collections.IList> 및 제네릭 <xref:System.Collections.Generic.IEnumerable%601>을 모두 구현하는 경우 컬렉션은 다음과 같은 <xref:System.Collections.IList> 규칙에 따라 serialize되고 deserialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>  
  
-   <span data-ttu-id="954bb-334">deserialization에서 모든 컬렉션은 기본 생성자를 호출하여 먼저 형식의 인스턴스를 만들어 deserialize됩니다. 여기서 기본 생성자는 serialization 및 deserialization을 수행하는 동안 serializer에서 컬렉션 형식을 컬렉션으로 처리하도록 존재해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the default constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>  
  
-   <span data-ttu-id="954bb-335">동일한 제네릭 컬렉션 인터페이스가 두 번 이상 구현되고(예를 들어, 형식이 <xref:System.Collections.Generic.ICollection%601> 의 제네릭 `Integer` 및 <xref:System.Collections.Generic.ICollection%601> 의 제네릭 <xref:System.String>을 모두 구현하는 경우), 우선 순위가 더 높은 인터페이스가 없는 경우 컬렉션은 유효한 컬렉션으로 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>  
  
-   <span data-ttu-id="954bb-336">컬렉션 형식은 이 컬렉션 형식에 적용된 <xref:System.SerializableAttribute> 특성을 가질 수 있으며, <xref:System.Runtime.Serialization.ISerializable> 인터페이스를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="954bb-337">이 특성 및 인터페이스가 모두 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-337">Both of these are ignored.</span></span> <span data-ttu-id="954bb-338">그러나 `Add` 메서드가 없는 경우와 같이 형식에서 컬렉션 형식 요구 사항을 충분히 충족하지 않는 경우 형식은 컬렉션 형식으로 간주되지 않으므로 <xref:System.SerializableAttribute> 특성 및 <xref:System.Runtime.Serialization.ISerializable> 인터페이스에 의해 형식이 serialize될 수 있는지 여부가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>  
  
-   <span data-ttu-id="954bb-339">컬렉션을 사용자 지정하기 위해 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 컬렉션에 적용하면 위의 <xref:System.SerializableAttribute> 대체 메커니즘이 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="954bb-340">대신 사용자 지정된 컬렉션에서 컬렉션 형식 요구 사항을 충족하지 않는 경우 <xref:System.Runtime.Serialization.InvalidDataContractException> 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="954bb-341">예외 문자열에는 `Add` 메서드 없음, 기본 생성자 없음과 같은 형식이 유효한 컬렉션으로 간주되지 않는 이유를 설명하는 정보가 종종 포함됩니다. 따라서 디버깅 목적으로 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 적용하는 것이 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no default constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>  
  
### <a name="collection-naming"></a><span data-ttu-id="954bb-342">컬렉션 명명</span><span class="sxs-lookup"><span data-stu-id="954bb-342">Collection Naming</span></span>  
 <span data-ttu-id="954bb-343">컬렉션 명명 규칙 목록은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-343">The following is a list of collection naming rules:</span></span>  
  
-   <span data-ttu-id="954bb-344">모든 사전 컬렉션 데이터 계약에 대 한 것은 물론 기본 형식이 포함 된 목록 컬렉션 데이터 계약의 기본 네임 스페이스 http://schemas.microsoft.com/2003/10/Serialization/Arrays Namespace를 사용 하 여 재정의 되지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="954bb-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is http://schemas.microsoft.com/2003/10/Serialization/Arrays unless overridden using Namespace.</span></span> <span data-ttu-id="954bb-345">`char`, `Timespan`및 `Guid` 형식과 함께 기본 제공 XSD 형식에 매핑되는 형식은 이러한 목적으로 기본 형식으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>  
  
-   <span data-ttu-id="954bb-346">기본 형식이 아닌 형식이 포함된 컬렉션 형식의 기본 네임스페이스는 Namespace를 사용하여 재정의되지 않는 한 컬렉션에 포함된 형식의 데이터 계약 네임스페이스와 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>  
  
-   <span data-ttu-id="954bb-347">목록 컬렉션 데이터 계약의 기본 이름은 Name을 사용하여 재정의되지 않는 한 컬렉션에 포함된 형식의 데이터 계약 이름과 결합된 문자열인 "ArrayOf"입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="954bb-348">예를 들어, 정수의 제네릭 목록에 대한 데이터 계약 이름은 "ArrayOfint"입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="954bb-349">`Object` 의 데이터 계약 이름은 "anyType"이므로 <xref:System.Collections.ArrayList> 와 같은 제네릭이 아닌 목록의 데이터 계약 이름은 "ArrayOfanyType"입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>  
  
 <span data-ttu-id="954bb-350">사전 컬렉션 데이터 계약의 기본 이름은 `Name`을 사용하여 재정의되지 않는 한 값 형식의 데이터 계약 이름 앞에 나오는 키 형식의 데이터 계약 이름과 결합된 문자열 "ArrayOfKeyValueOf"입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="954bb-351">예를 들어, 문자열 및 정수의 제네릭 사전에 대한 데이터 계약 이름은 "ArrayOfKeyValueOfstringint"입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="954bb-352">또한 키 또는 값 형식 중 하나가 기본 형식이 아닌 경우 키 및 값 형식의 데이터 계약 네임스페이스의 네임스페이스 해시가 이름에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="954bb-353"> 는 [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="954bb-353"> namespace hashes, see [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span></span>  
  
 <span data-ttu-id="954bb-354">각 사전 컬렉션 데이터 계약에는 사전에 있는 하나의 항목을 나타내는 도우미 데이터 계약이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="954bb-355">이 계약의 이름은 "ArrayOf" 접두사를 제외하고 사전 데이터 계약과 동일하며 네임스페이스는 사전 데이터 계약과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="954bb-356">예를 들어, "ArrayOfKeyValueOfstringint" 사전 데이터 계약의 경우 "KeyValueofstringint" 데이터 계약은 사전에 있는 하나의 항목을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="954bb-357">다음 단원에서 설명한 대로 `ItemName` 속성을 사용하여 이 데이터 계약의 이름을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>  
  
 <span data-ttu-id="954bb-358">제네릭 형식 명명 규칙은 [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md)에서 설명한 대로 컬렉션 형식에 완전히 적용됩니다. 즉, 이름 내에 중괄호를 사용하여 제네릭 형식 매개 변수를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-358">Generic type naming rules, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="954bb-359">그러나 괄호 내의 수는 컬렉션 내에 포함된 형식이 아닌 제네릭 매개 변수를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>  
  
## <a name="collection-customization"></a><span data-ttu-id="954bb-360">컬렉션 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="954bb-360">Collection Customization</span></span>  
 <span data-ttu-id="954bb-361"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성은 다음과 같이 사용할 수 없으며, 다음과 같이 사용된 경우 <xref:System.Runtime.Serialization.InvalidDataContractException> 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>  
  
-   <span data-ttu-id="954bb-362"><xref:System.Runtime.Serialization.DataContractAttribute> 특성을 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성이 적용된 형식이나 파생 형식 중 하나에 적용</span><span class="sxs-lookup"><span data-stu-id="954bb-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>  
  
-   <span data-ttu-id="954bb-363"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스를 구현하는 형식에 적용</span><span class="sxs-lookup"><span data-stu-id="954bb-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
-   <span data-ttu-id="954bb-364"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 비컬렉션 형식에 적용</span><span class="sxs-lookup"><span data-stu-id="954bb-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>  
  
-   <span data-ttu-id="954bb-365">사전이 아닌 형식에 적용된 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> 특성에 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> 또는 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 을 설정하려는 경우</span><span class="sxs-lookup"><span data-stu-id="954bb-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>  
  
### <a name="polymorphism-rules"></a><span data-ttu-id="954bb-366">다형성 규칙</span><span class="sxs-lookup"><span data-stu-id="954bb-366">Polymorphism Rules</span></span>  
 <span data-ttu-id="954bb-367">이미 설명한 바와 같이 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 사용하여 컬렉션을 사용자 지정하면 컬렉션 교환 가능성에 방해가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="954bb-368">사전 컬렉션에서 키 및 값 이름뿐만 아니라 사전 컬렉션의 이름, 네임스페이스, 항목 이름이 일치하는 경우에만 사용자 지정된 두 개의 컬렉션 형식을 동일한 것으로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>  
  
 <span data-ttu-id="954bb-369">사용자 지정으로 인해 두 개 중 한 컬렉션 데이터 계약이 필요한 곳에 다른 나머지 컬렉션 데이터 계약을 잘못 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="954bb-370">이러한 경우가 발생해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-370">This should be avoided.</span></span> <span data-ttu-id="954bb-371">다음 형식을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-371">See the following types.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
 [!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]  
  
 <span data-ttu-id="954bb-372">이 경우 `Marks1` 의 인스턴스는 `testMarks`에 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="954bb-373">그러나 데이터 계약이 `Marks2` 데이터 계약과 동일하지 않으므로 `IList<int>` 를 사용해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="954bb-374">데이터 계약 이름을 "아닌 Marks2" 및 "ArrayOfint", 이며 반복 되는 요소 이름 "\<표시 >"가 아닌 "\<int >"입니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>  
  
 <span data-ttu-id="954bb-375">다음 표의 규칙은 컬렉션의 다형적 할당에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>  
  
|<span data-ttu-id="954bb-376">선언된 형식</span><span class="sxs-lookup"><span data-stu-id="954bb-376">Declared type</span></span>|<span data-ttu-id="954bb-377">사용자 지정되지 않은 컬렉션 할당</span><span class="sxs-lookup"><span data-stu-id="954bb-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="954bb-378">사용자 지정된 컬렉션 할당</span><span class="sxs-lookup"><span data-stu-id="954bb-378">Assigning a customized collection</span></span>|  
|-------------------|--------------------------------------------|---------------------------------------|  
|<span data-ttu-id="954bb-379">Object</span><span class="sxs-lookup"><span data-stu-id="954bb-379">Object</span></span>|<span data-ttu-id="954bb-380">계약 이름이 serialize되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-380">Contract name is serialized.</span></span>|<span data-ttu-id="954bb-381">계약 이름이 serialize되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="954bb-382">사용자 지정이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-382">Customization is used.</span></span>|  
|<span data-ttu-id="954bb-383">컬렉션 인터페이스</span><span class="sxs-lookup"><span data-stu-id="954bb-383">Collection interface</span></span>|<span data-ttu-id="954bb-384">계약 이름이 serialize되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-384">Contract name is not serialized.</span></span>|<span data-ttu-id="954bb-385">계약 이름이 serialize되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="954bb-386">사용자 지정이 사용되지 않습니다.\*</span><span class="sxs-lookup"><span data-stu-id="954bb-386">Customization is not used.\*</span></span>|  
|<span data-ttu-id="954bb-387">사용자 지정되지 않은 컬렉션</span><span class="sxs-lookup"><span data-stu-id="954bb-387">Non-customized collection</span></span>|<span data-ttu-id="954bb-388">계약 이름이 serialize되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-388">Contract name is not serialized.</span></span>|<span data-ttu-id="954bb-389">계약 이름이 serialize되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="954bb-390">사용자 지정이 사용됩니다.**</span><span class="sxs-lookup"><span data-stu-id="954bb-390">Customization is used.**</span></span>|  
|<span data-ttu-id="954bb-391">사용자 지정된 컬렉션</span><span class="sxs-lookup"><span data-stu-id="954bb-391">Customized collection</span></span>|<span data-ttu-id="954bb-392">계약 이름이 serialize되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-392">Contract name is serialized.</span></span> <span data-ttu-id="954bb-393">사용자 지정이 사용되지 않습니다.**</span><span class="sxs-lookup"><span data-stu-id="954bb-393">Customization is not used.**</span></span>|<span data-ttu-id="954bb-394">계약 이름이 serialize되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="954bb-395">할당된 형식의 사용자 지정이 사용됩니다.**</span><span class="sxs-lookup"><span data-stu-id="954bb-395">Customization of the assigned type is used.**</span></span>|  
  
 <span data-ttu-id="954bb-396">\*이 경우 <xref:System.Runtime.Serialization.NetDataContractSerializer> 클래스와 함께 사용자 지정이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-396">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="954bb-397">또한 <xref:System.Runtime.Serialization.NetDataContractSerializer> 클래스는 이 경우의 실제 형식 이름을 serialize하므로 deserialization이 예상대로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>  
  
 <span data-ttu-id="954bb-398">**이러한 경우 스키마에 맞지 않는 인스턴스가 발생하므로 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="954bb-398">**These cases result in schema-invalid instances and thus should be avoided.</span></span>  
  
 <span data-ttu-id="954bb-399">계약 이름이 serialize된 경우에는 할당된 컬렉션 형식이 알려진 형식 목록에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="954bb-400">반대의 경우도 마찬가지입니다. 이름이 serialize되지 않은 경우에는 형식을 알려진 형식 목록에 추가할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>  
  
 <span data-ttu-id="954bb-401">파생 형식의 배열은 기본 형식의 배열에 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="954bb-402">이 경우 파생 형식의 계약 이름이 반복되는 각 요소에 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="954bb-403">예를 들어, `Book` 형식이 `LibraryItem`형식에서 파생되는 경우 `Book` 의 배열을 `LibraryItem`의 배열에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="954bb-404">이는 다른 컬렉션 형식에 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-404">This does not apply to other collection types.</span></span> <span data-ttu-id="954bb-405">예를 들어, `Generic List of Book` 을 `Generic List of LibraryItem`에 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="954bb-406">그러나 `Generic List of LibraryItem` 인스턴스를 포함하는 `Book` 을 할당할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="954bb-407">배열인 경우든 배열이 아닌 경우든 `Book` 은 알려진 형식 목록에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>  
  
## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="954bb-408">컬렉션 및 개체 참조 유지</span><span class="sxs-lookup"><span data-stu-id="954bb-408">Collections and Object Reference Preservation</span></span>  
 <span data-ttu-id="954bb-409">serializer가 개체 참조를 유지하는 모드에서 작동하는 경우 개체 참조 유지도 컬렉션에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="954bb-410">특히 개체 ID는 전체 컬렉션 및 컬렉션에 포함된 개별 항목 모두에 대해 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="954bb-411">사전의 경우 개체 ID는 키/값 쌍 개체, 개별 키 개체 및 값 개체 모두에 대해 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="954bb-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="954bb-412">참고 항목</span><span class="sxs-lookup"><span data-stu-id="954bb-412">See Also</span></span>  
 <xref:System.Runtime.Serialization.CollectionDataContractAttribute>

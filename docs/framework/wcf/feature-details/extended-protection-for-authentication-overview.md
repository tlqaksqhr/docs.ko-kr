---
title: "인증에 대한 확장된 보호 개요"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 3d2ceffe-a7bf-4bd9-a5a2-9406423bd7f8
caps.latest.revision: "4"
author: BrucePerlerMS
ms.author: bruceper
manager: mbaldwin
ms.workload: dotnet
ms.openlocfilehash: b061f9395c3917c196030678ede007071e681027
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/22/2017
---
# <a name="extended-protection-for-authentication-overview"></a><span data-ttu-id="d9401-102">인증에 대한 확장된 보호 개요</span><span class="sxs-lookup"><span data-stu-id="d9401-102">Extended Protection for Authentication Overview</span></span>
<span data-ttu-id="d9401-103">인증에 대한 보호를 강화하면 공격자가 클라이언트의 자격 증명을 가로채서 서버로 전달하는 MITM(Man-In-The-Middle) 공격을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-103">Extended Protection for Authentication helps protect against man-in-the-middle (MITM) attacks, in which an attacker intercepts a client’s credentials and forwards them to a server.</span></span>  
  
 <span data-ttu-id="d9401-104">클라이언트, 서버, 공격자의 세 참가자가 있는 시나리오를 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-104">Consider a scenario with three participants: a client, server, and attacker.</span></span> <span data-ttu-id="d9401-105">서버의 URL은 `https://server`이고 공격자의 URL은 `https://attacker`입니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-105">The server has the URL `https://server`, whereas the attacker has the URL `https://attacker`.</span></span> <span data-ttu-id="d9401-106">공격자는 자신의 URL을 서버인 것처럼 가장하여 클라이언트가 액세스하도록 한 다음</span><span class="sxs-lookup"><span data-stu-id="d9401-106">The attacker tricks the client into accessing the attacker as if it were the server.</span></span> <span data-ttu-id="d9401-107">서버로 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-107">The attacker then sends a request to the server.</span></span> <span data-ttu-id="d9401-108">공격자가 보안 리소스에 액세스하려고 하면 서버에서는 WWW-Authenticate 헤더를 사용해 공격자에게 회신을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-108">If the attacker is trying to access a secure resource, the server replies to the attacker with a WWW-Authenticate header.</span></span> <span data-ttu-id="d9401-109">공격자에게는 인증 정보가 없으므로 서버는 WWW-Authenticate 헤더를 클라이언트에게 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-109">The attacker does not have the authentication information, so it sends the WWW-Authenticate header on to the client.</span></span> <span data-ttu-id="d9401-110">그러면 클라이언트가 Authorization 헤더를 공격자에게 보내고, 공격자는 이 헤더를 서버로 보내 클라이언트의 자격 증명으로 보안 리소스에 액세스하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-110">The client sends the Authorization header to the attacker, and the attacker sends the header on to the server and gets access to the secure resources using the client’s credentials.</span></span>  
  
 <span data-ttu-id="d9401-111">현재는 클라이언트 응용 프로그램이 Kerberos, 다이제스트 또는 NTLM(HTTPS 사용)을 통해 서버에 인증할 때 TLS(전송 수준 보안) 채널이 먼저 설정되며 이 채널을 사용해 인증이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-111">Currently, when a client application authenticates itself to the server using Kerberos, Digest, or NTLM using HTTPS, a Transport Level Security (TLS) channel is first established and authentication takes place using this channel.</span></span> <span data-ttu-id="d9401-112">그러나 SSL(Secure Sockets Layer)을 통해 생성되는 세션 키와 인증 중에 생성되는 세션 키는 서로 바인딩되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-112">However, there is no binding between the session key generated by Secure Sockets Layer (SSL) and the session key that is generated during authentication.</span></span> <span data-ttu-id="d9401-113">따라서 위의 시나리오에서 HTTPS 채널 등의 TLS를 통해 통신이 수행되는 경우 SSL 채널이 두 개(클라이언트와 공격자 간에 하나, 공격자와 서버 간에 하나) 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-113">So, in the previous scenario, if the communication takes places over a TLS (such as an HTTPS channel), there are two SSL channels created: one between the client and the attacker, and another between the attacker and the server.</span></span> <span data-ttu-id="d9401-114">클라이언트의 자격 증명은 클라이언트에서 서버로 전송될 때 먼저 클라이언트와 공격자 간의 SSL 채널을 통해 전송된 다음, 공격자와 서버 간의 채널을 통해 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-114">The client’s credentials are sent from the client to the server first over the SSL channel between the client and the attacker and then over the channel between the attacker and the server.</span></span> <span data-ttu-id="d9401-115">클라이언트의 자격 증명이 서버에 도달하면 서버는 해당 자격 증명을 보내는 데 사용된 채널이 클라이언트의 채널이 아닌 공격자의 채널임을 검색하지 않고 자격 증명을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-115">Once the client’s credentials reach the server, the server verifies the credentials without detecting that the channel over which those credentials were sent originated with the attacker and not the client.</span></span>  
  
 <span data-ttu-id="d9401-116">이러한 공격을 방지하려면 TLS로 보호되는 외부 채널과 클라이언트가 인증한 내부 채널을 사용하고 서버로 CBT(채널 바인딩 토큰)를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-116">The solution is to use a TLS-secured outer channel and a client-authenticated inner channel, and to pass a Channel Binding Token (CBT) to the server.</span></span> <span data-ttu-id="d9401-117">CBT는 TLS로 보호되는 외부 채널의 속성으로, 클라이언트가 인증한 내부 채널을 통한 대화에 외부 채널을 바인딩하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-117">The CBT is a property of the TLS-secured outer channel, and is used to bind the outer channel to a conversation over the client-authenticated inner channel.</span></span>  
  
 <span data-ttu-id="d9401-118">위의 시나리오에서 클라이언트와 공격자 간 TLS 채널의 CBT는 서버로 전송되는 권한 부여 정보에 병합됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-118">In the previous scenario, the CBT of the client-attacker TLS channel is merged with the authorization information that is sent to the server.</span></span> <span data-ttu-id="d9401-119">CBT를 인식하는 서버는 클라이언트 권한 부여 정보에 포함된 CBT(클라이언트와 공격자 간 채널에 해당함)를 공격자와 서버 간 채널에 연결된 CBT와 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-119">A CBT-aware server compares the CBT contained in the client authentication information, which corresponds to the client-attacker channel, to the CBT attached to the attacker-server channel.</span></span> <span data-ttu-id="d9401-120">CBT는 채널 대상별로 다르므로 클라이언트와 공격자 간 CBT는 공격자와 서버 간 CBT와 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-120">A CBT is specific to a channel’s destination, so the client-attacker CBT does not match the attacker-server CBT.</span></span> <span data-ttu-id="d9401-121">따라서 서버가 MITM 공격을 검색하여 인증 요청을 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-121">This lets the server detect the MITM attack and refuse the authentication request.</span></span>  
  
 <span data-ttu-id="d9401-122">클라이언트측은 구성 설정이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-122">The client side does not require any configuration setting.</span></span> <span data-ttu-id="d9401-123">클라이언트는 CBT를 서버로 전달하도록 업데이트되면 항상 CBT를 서버로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-123">Once the client has been updated to pass the CBT to the server, it always does so.</span></span> <span data-ttu-id="d9401-124">서버도 업데이트된 경우에는 CBT를 사용하거나 무시하도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-124">If the server has also been updated, it can be configured to use the CBT or ignore it.</span></span> <span data-ttu-id="d9401-125">서버가 업데이트되지 않은 경우에는 CBT가 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-125">If it has not been updated, it ignores it.</span></span>  
  
 <span data-ttu-id="d9401-126">서버는 다음과 같은 보호 수준을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-126">The server can have the following levels of protection:</span></span>  
  
-   <span data-ttu-id="d9401-127">없음</span><span class="sxs-lookup"><span data-stu-id="d9401-127">None.</span></span> <span data-ttu-id="d9401-128">채널 바인딩 유효성 검사가 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-128">No channel binding validation is performed.</span></span> <span data-ttu-id="d9401-129">업데이트되지 않은 모든 서버의 기본 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-129">This is the behavior of all servers that have not been updated.</span></span>  
  
-   <span data-ttu-id="d9401-130">부분.</span><span class="sxs-lookup"><span data-stu-id="d9401-130">Partial.</span></span> <span data-ttu-id="d9401-131">업데이트된 모든 클라이언트는 채널 바인딩 정보를 서버에 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-131">All clients that have been updated must provide channel binding information to the server.</span></span> <span data-ttu-id="d9401-132">업데이트되지 않은 클라이언트는 해당 정보를 제공하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-132">Clients that have not been updated do not have to do so.</span></span> <span data-ttu-id="d9401-133">응용 프로그램 호환성을 허용하는 중간 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-133">This is an intermediate option that allows for application compatibility.</span></span>  
  
-   <span data-ttu-id="d9401-134">전체.</span><span class="sxs-lookup"><span data-stu-id="d9401-134">Full.</span></span> <span data-ttu-id="d9401-135">모든 클라이언트는 채널 바인딩 정보를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-135">All clients must provide channel binding information.</span></span> <span data-ttu-id="d9401-136">서버는 채널 바인딩 정보를 제공하지 않는 클라이언트의 인증 요청을 거부합니다.</span><span class="sxs-lookup"><span data-stu-id="d9401-136">The server rejects authentication requests from clients that do not do so.</span></span>  
  
 <span data-ttu-id="d9401-137">자세한 내용은 Win7 CBT/Extended Protection 샘플을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="d9401-137">For more information, see the Win7 CBT/Extended Protection sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d9401-138">참고 항목</span><span class="sxs-lookup"><span data-stu-id="d9401-138">See Also</span></span>  
 [<span data-ttu-id="d9401-139">Windows Server App Fabric에 대 한 보안 모델</span><span class="sxs-lookup"><span data-stu-id="d9401-139">Security Model for Windows Server App Fabric</span></span>](http://go.microsoft.com/fwlink/?LinkID=201279&clcid=0x409)

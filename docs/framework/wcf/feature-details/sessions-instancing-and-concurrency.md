---
title: 세션, 인스턴스 및 동시성
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 50797a3b-7678-44ed-8138-49ac1602f35b
caps.latest.revision: 16
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: 6dd96ea552bb92dd90c1c47abac744c55e2e67e5
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/28/2018
---
# <a name="sessions-instancing-and-concurrency"></a><span data-ttu-id="ee5d6-102">세션, 인스턴스 및 동시성</span><span class="sxs-lookup"><span data-stu-id="ee5d6-102">Sessions, Instancing, and Concurrency</span></span>
<span data-ttu-id="ee5d6-103">*세션* 은 두 개의 끝점 사이에 전송된 모든 메시지의 상관 관계입니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-103">A *session* is a correlation of all messages sent between two endpoints.</span></span> <span data-ttu-id="ee5d6-104">*인스턴스 만들기* 는 사용자 정의 서비스 개체와 관련 <xref:System.ServiceModel.InstanceContext> 개체의 수명 제어를 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-104">*Instancing* refers to controlling the lifetime of user-defined service objects and their related <xref:System.ServiceModel.InstanceContext> objects.</span></span> <span data-ttu-id="ee5d6-105">*동시성* 은 <xref:System.ServiceModel.InstanceContext> 에서 동시에 실행되는 스레드 수의 제어를 의미하는 용어입니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-105">*Concurrency* is the term given to the control of the number of threads executing in an <xref:System.ServiceModel.InstanceContext> at the same time.</span></span>  
  
 <span data-ttu-id="ee5d6-106">이 항목에서는 이러한 설정, 설정 사용 방법 및 설정 간의 다양한 상호 작용에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-106">This topic describes these settings, how to use them, and the various interactions between them.</span></span>  
  
## <a name="sessions"></a><span data-ttu-id="ee5d6-107">세션</span><span class="sxs-lookup"><span data-stu-id="ee5d6-107">Sessions</span></span>  
 <span data-ttu-id="ee5d6-108">서비스 계약이 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 속성을 <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType>로 설정할 경우 해당 계약은 모든 호출(호출을 지원하는 기본 메시지 교환)이 동일한 대화의 일부이어야 함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-108">When a service contract sets the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType>, that contract is saying that all calls (that is, the underlying message exchanges that support the calls) must be part of the same conversation.</span></span> <span data-ttu-id="ee5d6-109">계약이 세션을 허용하지만 특정 세션이 필요 없음을 지정하는 경우, 클라이언트는 세션을 연결하여 설정하거나 설정하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-109">If a contract specifies that it allows sessions but does not require one, clients can connect and either establish a session or not.</span></span> <span data-ttu-id="ee5d6-110">세션이 종료되고 메시지가 동일한 세션 기반 채널을 통해 전송될 경우 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-110">If the session ends and a message is sent over the same session-based channel an exception is thrown.</span></span>  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="ee5d6-111"> 세션에는 다음과 같은 주요 개념적 기능이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-111"> sessions have the following main conceptual features:</span></span>  
  
-   <span data-ttu-id="ee5d6-112">이러한 기능은 호출 응용 프로그램에 의해 명시적으로 시작되고 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-112">They are explicitly initiated and terminated by the calling application.</span></span>  
  
-   <span data-ttu-id="ee5d6-113">한 세션 동안 배달된 메시지는 수신된 순서대로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-113">Messages delivered during a session are processed in the order in which they are received.</span></span>  
  
-   <span data-ttu-id="ee5d6-114">세션은 메시지 그룹을 대화에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-114">Sessions correlate a group of messages into a conversation.</span></span> <span data-ttu-id="ee5d6-115">상관 관계의 의미는 추상적입니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-115">The meaning of that correlation is an abstraction.</span></span> <span data-ttu-id="ee5d6-116">예를 들어, 공유된 네트워크 연결을 기반으로 메시지와 연결될 수 있는 세션 기반 채널이 있는 반면 메시지 본문의 공유 태그를 기반으로 메시지와 연결될 수 있는 세션 기반 채널도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-116">For instance, one session-based channel may correlate messages based on a shared network connection while another session-based channel may correlate messages based on a shared tag in the message body.</span></span> <span data-ttu-id="ee5d6-117">세션에서 파생될 수 있는 기능은 상관 관계의 특성에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-117">The features that can be derived from the session depend on the nature of the correlation.</span></span>  
  
-   <span data-ttu-id="ee5d6-118">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 세션과 연결된 일반 데이터 저장소는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-118">There is no general data store associated with a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] session.</span></span>  
  
 <span data-ttu-id="ee5d6-119"><xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> 응용 프로그램의 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 클래스 및 기능에 익숙한 경우, 해당 유형의 세션 및 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 세션 사이에 다음과 같은 차이점이 있음을 알 수 있습니다</span><span class="sxs-lookup"><span data-stu-id="ee5d6-119">If you are familiar with the <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> class in [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] applications and the functionality it provides, you might notice the following differences between that kind of session and [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] sessions:</span></span>  
  
-   [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]<span data-ttu-id="ee5d6-120"> 세션은 항상 서버에 의해 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-120"> sessions are always server-initiated.</span></span>  
  
-   [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]<span data-ttu-id="ee5d6-121"> 세션은 암시적으로 순서가 지정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-121"> sessions are implicitly unordered.</span></span>  
  
-   [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]<span data-ttu-id="ee5d6-122"> 세션은 요청을 통해 일반 데이터 저장소 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-122"> sessions provide a general data storage mechanism across requests.</span></span>  
  
 <span data-ttu-id="ee5d6-123">클라이언트 응용 프로그램과 서비스 응용 프로그램은 서로 다른 방법으로 세션과 상호 작용합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-123">Client applications and service applications interact with sessions in different ways.</span></span> <span data-ttu-id="ee5d6-124">클라이언트 응용 프로그램은 세션을 시작한 다음 세션 내에서 전송된 메시지를 수신하여 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-124">Client applications initiate sessions and then receive and process the messages sent within the session.</span></span> <span data-ttu-id="ee5d6-125">서비스 응용 프로그램은 세션을 확장성 지점으로 사용하여 추가 동작을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-125">Service applications can use sessions as an extensibility point to add additional behavior.</span></span> <span data-ttu-id="ee5d6-126"><xref:System.ServiceModel.InstanceContext> 와 직접 작업하거나 사용자 지정 인스턴스 컨텍스트 공급자를 구현하여 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-126">This is done by working directly with the <xref:System.ServiceModel.InstanceContext> or implementing a custom instance context provider.</span></span>  
  
## <a name="instancing"></a><span data-ttu-id="ee5d6-127">인스턴스 만들기</span><span class="sxs-lookup"><span data-stu-id="ee5d6-127">Instancing</span></span>  
 <span data-ttu-id="ee5d6-128">인스턴스 만들기 동작(<xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 속성을 사용하여 설정)은 들어오는 메시지에 대한 응답으로 <xref:System.ServiceModel.InstanceContext>를 만드는 방법을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-128">The instancing behavior (set by using the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property) controls how the <xref:System.ServiceModel.InstanceContext> is created in response to incoming messages.</span></span> <span data-ttu-id="ee5d6-129">기본적으로 각 <xref:System.ServiceModel.InstanceContext> 는 하나의 사용자 정의 서비스 개체와 연결되기 때문에 기본적인 경우 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 속성을 설정하면 사용자 정의 서비스 개체의 인스턴스 만들기도 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-129">By default, each <xref:System.ServiceModel.InstanceContext> is associated with one user-defined service object, so (in the default case) setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> property also controls the instancing of user-defined service objects.</span></span> <span data-ttu-id="ee5d6-130"><xref:System.ServiceModel.InstanceContextMode> 열거형은 인스턴스 만들기 모드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-130">The <xref:System.ServiceModel.InstanceContextMode> enumeration defines the instancing modes.</span></span>  
  
 <span data-ttu-id="ee5d6-131">사용할 수 있는 인스턴스 만들기 모드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-131">The following instancing modes are available:</span></span>  
  
-   <span data-ttu-id="ee5d6-132"><xref:System.ServiceModel.InstanceContextMode.PerCall>: 새로운 <xref:System.ServiceModel.InstanceContext> (및 그에 따른 서비스 개체)가 각 클라이언트 요청에 대해 만들어 집니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-132"><xref:System.ServiceModel.InstanceContextMode.PerCall>: A new <xref:System.ServiceModel.InstanceContext> (and therefore service object) is created for each client request.</span></span>  
  
-   <span data-ttu-id="ee5d6-133"><xref:System.ServiceModel.InstanceContextMode.PerSession>: 새로운 <xref:System.ServiceModel.InstanceContext> (및 그에 따른 서비스 개체)가 새로운 각각의 클라이언트 세션에 대해 생성되고 해당 세션의 수명이 유지 관리됩니다. 이를 수행하려면 세션을 지원하는 바인딩이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-133"><xref:System.ServiceModel.InstanceContextMode.PerSession>: A new <xref:System.ServiceModel.InstanceContext> (and therefore service object) is created for each new client session and maintained for the lifetime of that session (this requires a binding that supports sessions).</span></span>  
  
-   <span data-ttu-id="ee5d6-134"><xref:System.ServiceModel.InstanceContextMode.Single>: 단일 <xref:System.ServiceModel.InstanceContext> (및 그에 따른 서비스 개체)는 응용 프로그램의 수명에 대한 모든 클라이언트 요청을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-134"><xref:System.ServiceModel.InstanceContextMode.Single>: A single <xref:System.ServiceModel.InstanceContext> (and therefore service object) handles all client requests for the lifetime of the application.</span></span>  
  
 <span data-ttu-id="ee5d6-135">다음 코드 예제에서는 명시적으로 서비스 클래스에 설정되는 기본 <xref:System.ServiceModel.InstanceContextMode> 값인 <xref:System.ServiceModel.InstanceContextMode.PerSession> 을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-135">The following code example shows the default <xref:System.ServiceModel.InstanceContextMode> value, <xref:System.ServiceModel.InstanceContextMode.PerSession> being explicitly set on a service class.</span></span>  
  
```  
[ServiceBehavior(InstanceContextMode=InstanceContextMode.PerSession)]   
public class CalculatorService : ICalculatorInstance   
{   
    ...  
}  
```  
  
 <span data-ttu-id="ee5d6-136">또한 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 속성은 <xref:System.ServiceModel.InstanceContext>가 해제되는 주기를 제어하는 반면에 <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> 및 <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A?displayProperty=nameWithType> 속성은 서비스 개체가 해제되는 시점을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-136">And while the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property controls how often the <xref:System.ServiceModel.InstanceContext> is released, the <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A?displayProperty=nameWithType> properties control when the service object is released.</span></span>  
  
### <a name="well-known-singleton-services"></a><span data-ttu-id="ee5d6-137">잘 알려진 singleton 서비스</span><span class="sxs-lookup"><span data-stu-id="ee5d6-137">Well-Known Singleton Services</span></span>  
 <span data-ttu-id="ee5d6-138">단일 인스턴스 서비스 개체에 대한 변형된 개체가 유용한 경우도 있습니다. 서비스 개체를 직접 만들고 해당 개체를 사용하여 서비스 호스트를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-138">One variation on single instance service objects is sometimes useful: you can create a service object yourself and create the service host using that object.</span></span> <span data-ttu-id="ee5d6-139">이렇게 하려면 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 속성도 <xref:System.ServiceModel.InstanceContextMode.Single>로 설정해야 하며, 그렇지 않으면 서비스 호스트를 열 때 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-139">To do so, you must also set the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.InstanceContextMode.Single> or an exception is thrown when the service host is opened.</span></span>  
  
 <span data-ttu-id="ee5d6-140"><xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> 생성자를 사용하여 이러한 서비스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-140">Use the <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> constructor to create such a service.</span></span> <span data-ttu-id="ee5d6-141">singleton 서비스에서 사용할 특정 개체 인스턴스를 제공하려면 사용자 지정 <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer?displayProperty=nameWithType>를 구현하는 대신 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-141">It provides an alternative to implementing a custom <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer?displayProperty=nameWithType> when you wish to provide a specific object instance for use by a singleton service.</span></span> <span data-ttu-id="ee5d6-142">예를 들어, 매개 변수가 없는 기본 public 생성자를 구현하지 않는 경우와 같이 서비스 구현 형식을 생성하기 어려운 경우 이 오버로드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-142">You can use this overload when your service implementation type is difficult to construct (for example, if it does not implement a default parameterless public constructor).</span></span>  
  
 <span data-ttu-id="ee5d6-143">이 생성자에 개체가 제공되면 [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] 인스턴스 만들기 동작과 관련된 일부 기능이 다르게 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-143">Note that when an object is provided to this constructor, some features related to the [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] instancing behavior work differently.</span></span> <span data-ttu-id="ee5d6-144">예를 들어 singleton 개체 인스턴스를 제공하는 경우 <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A?displayProperty=nameWithType> 호출은 아무런 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-144">For example, calling <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A?displayProperty=nameWithType> has no effect when a singleton object instance is provided.</span></span> <span data-ttu-id="ee5d6-145">마찬가지로 다른 인스턴스 해제 메커니즘도 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-145">Similarly, any other instance-release mechanism is ignored.</span></span> <span data-ttu-id="ee5d6-146"><xref:System.ServiceModel.ServiceHost>는 항상 모든 작업에 대해 <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> 속성이 <xref:System.ServiceModel.ReleaseInstanceMode.None?displayProperty=nameWithType>으로 설정된 것처럼 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-146">The <xref:System.ServiceModel.ServiceHost> always behaves as if the <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> property is set to <xref:System.ServiceModel.ReleaseInstanceMode.None?displayProperty=nameWithType> for all operations.</span></span>  
  
### <a name="sharing-instancecontext-objects"></a><span data-ttu-id="ee5d6-147">InstanceContext 개체 공유</span><span class="sxs-lookup"><span data-stu-id="ee5d6-147">Sharing InstanceContext Objects</span></span>  
 <span data-ttu-id="ee5d6-148">또한 해당 연결을 직접 수행하여 <xref:System.ServiceModel.InstanceContext> 개체와 연결된 세션 채널 또는 호출을 제어할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-148">You can also control which sessionful channel or call is associated with which <xref:System.ServiceModel.InstanceContext> object by performing that association yourself.</span></span>  
  
## <a name="concurrency"></a><span data-ttu-id="ee5d6-149">동시성</span><span class="sxs-lookup"><span data-stu-id="ee5d6-149">Concurrency</span></span>  
 <span data-ttu-id="ee5d6-150">동시성은 <xref:System.ServiceModel.InstanceContext> 에서 동시에 활성화되는 스레드 수의 제어입니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-150">Concurrency is the control of the number of threads active in an <xref:System.ServiceModel.InstanceContext> at any one time.</span></span> <span data-ttu-id="ee5d6-151"><xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> 열거형과 함께 <xref:System.ServiceModel.ConcurrencyMode>를 사용하여 이를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-151">This is controlled by using the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> with the <xref:System.ServiceModel.ConcurrencyMode> enumeration.</span></span>  
  
 <span data-ttu-id="ee5d6-152">사용할 수 있는 세 가지 동시성 모드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-152">The following three concurrency modes are available:</span></span>  
  
-   <span data-ttu-id="ee5d6-153"><xref:System.ServiceModel.ConcurrencyMode.Single>: 각 인스턴스 컨텍스트는 한 번에 인스턴스 컨텍스트에서 메시지를 처리하는 하나의 스레드의 최대값을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-153"><xref:System.ServiceModel.ConcurrencyMode.Single>: Each instance context is allowed to have a maximum of one thread processing messages in the instance context at a time.</span></span> <span data-ttu-id="ee5d6-154">동일한 인스턴스 컨텍스트를 사용하려는 다른 스레드는 원래 스레드가 인스턴스 컨텍스트를 종료할 때까지 차단되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-154">Other threads wishing to use the same instance context must block until the original thread exits the instance context.</span></span>  
  
-   <span data-ttu-id="ee5d6-155"><xref:System.ServiceModel.ConcurrencyMode.Multiple>: 각 서비스 인스턴스는 메시지를 동시에 처리하는 여러 스레드를 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-155"><xref:System.ServiceModel.ConcurrencyMode.Multiple>: Each service instance can have multiple threads processing messages concurrently.</span></span> <span data-ttu-id="ee5d6-156">이 동시성 모드를 사용하려면 스레드로부터 안전하게 서비스를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-156">The service implementation must be thread-safe to use this concurrency mode.</span></span>  
  
-   <span data-ttu-id="ee5d6-157"><xref:System.ServiceModel.ConcurrencyMode.Reentrant>: 각 서비스 인스턴스가 한 번에 하나의 메시지를 처리하지만 재진입 작업 호출을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-157"><xref:System.ServiceModel.ConcurrencyMode.Reentrant>: Each service instance processes one message at a time, but accepts re-entrant operation calls.</span></span> <span data-ttu-id="ee5d6-158">서비스는 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 클라이언트 개체를 통해 호출하는 경우에만 이러한 호출을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-158">The service only accepts these calls when it is calling out through a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] client object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee5d6-159">둘 이상의 스레드를 안전하게 사용하는 코드를 이해하고 개발하기는 쉽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-159">Understanding and developing code that safely uses more than one thread can be difficult to write successfully.</span></span> <span data-ttu-id="ee5d6-160"><xref:System.ServiceModel.ConcurrencyMode.Multiple> 또는 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> 값을 사용하기 전에 이러한 모드에 대해 해당 서비스가 적절하게 디자인되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-160">Before using <xref:System.ServiceModel.ConcurrencyMode.Multiple> or <xref:System.ServiceModel.ConcurrencyMode.Reentrant> values, ensure that your service is properly designed for these modes.</span></span> <span data-ttu-id="ee5d6-161">자세한 내용은 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-161">For more information, see <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>.</span></span>  
  
 <span data-ttu-id="ee5d6-162">동시성 사용은 인스턴스 만들기 모드와 관련됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-162">The use of concurrency is related to the instancing mode.</span></span> <span data-ttu-id="ee5d6-163"><xref:System.ServiceModel.InstanceContextMode.PerCall> 만들기에서는 동시성이 관련 되지 않습니다, 새 각 메시지를 처리 하기 때문에 <xref:System.ServiceModel.InstanceContext> 둘 이상의 스레드가에 활성화 된 따라서 및는 <xref:System.ServiceModel.InstanceContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-163">In <xref:System.ServiceModel.InstanceContextMode.PerCall> instancing, concurrency is not relevant, because each message is processed by a new <xref:System.ServiceModel.InstanceContext> and, therefore, never more than one thread is active in the <xref:System.ServiceModel.InstanceContext>.</span></span>  
  
 <span data-ttu-id="ee5d6-164">다음 코드 예제에서는 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 속성을 <xref:System.ServiceModel.ConcurrencyMode.Multiple>로 설정하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-164">The following code example demonstrates setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> property to <xref:System.ServiceModel.ConcurrencyMode.Multiple>.</span></span>  
  
```  
[ServiceBehavior(ConcurrencyMode=ConcurrencyMode.Multiple, InstanceContextMode = InstanceContextMode.Single)]   
public class CalculatorService : ICalculatorConcurrency   
{   
    ...  
}  
```  
  
## <a name="sessions-interact-with-instancecontext-settings"></a><span data-ttu-id="ee5d6-165">세션이 InstanceContext 설정과 상호 작용</span><span class="sxs-lookup"><span data-stu-id="ee5d6-165">Sessions Interact with InstanceContext Settings</span></span>  
 <span data-ttu-id="ee5d6-166">세션 및 <xref:System.ServiceModel.InstanceContext>는 계약의 <xref:System.ServiceModel.SessionMode> 열거형 값 조합 및 채널과 특정 서비스 개체 간의 연결을 제어하는 서비스 구현의 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 속성에 따라 상호 작용합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-166">Sessions and <xref:System.ServiceModel.InstanceContext> interact depending upon the combination of the value of the <xref:System.ServiceModel.SessionMode> enumeration in a contract and the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property on the service implementation, which controls the association between channels and specific service objects.</span></span>  
  
 <span data-ttu-id="ee5d6-167">다음 표에서는 서비스에서 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 속성과 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 속성의 값을 조합하는 경우 세션을 지원하거나 지원하지 않는 들어오는 채널의 결과를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-167">The following table shows the result of an incoming channel either supporting sessions or not supporting sessions given a service's combination of the values of the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property and the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property.</span></span>  
  
|<span data-ttu-id="ee5d6-168">InstanceContextMode 값</span><span class="sxs-lookup"><span data-stu-id="ee5d6-168">InstanceContextMode value</span></span>|<xref:System.ServiceModel.SessionMode.Required>|<xref:System.ServiceModel.SessionMode.Allowed>|<xref:System.ServiceModel.SessionMode.NotAllowed>|  
|-------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<span data-ttu-id="ee5d6-169">PerCall</span><span class="sxs-lookup"><span data-stu-id="ee5d6-169">PerCall</span></span>|<span data-ttu-id="ee5d6-170">-세션 채널 동작: 세션 및 <xref:System.ServiceModel.InstanceContext> 각 호출에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-170">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each call.</span></span><br /><span data-ttu-id="ee5d6-171">-세션 없는 채널 동작: 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-171">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="ee5d6-172">-세션 채널 동작: 세션 및 <xref:System.ServiceModel.InstanceContext> 각 호출에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-172">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each call.</span></span><br /><span data-ttu-id="ee5d6-173">-세션 없는 채널 동작:는 <xref:System.ServiceModel.InstanceContext> 각 호출에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-173">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|<span data-ttu-id="ee5d6-174">-세션 채널 동작: 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-174">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="ee5d6-175">-세션 없는 채널 동작:는 <xref:System.ServiceModel.InstanceContext> 각 호출에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-175">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|  
|<span data-ttu-id="ee5d6-176">PerSession</span><span class="sxs-lookup"><span data-stu-id="ee5d6-176">PerSession</span></span>|<span data-ttu-id="ee5d6-177">-세션 채널 동작: 세션 및 <xref:System.ServiceModel.InstanceContext> 각 채널에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-177">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each channel.</span></span><br /><span data-ttu-id="ee5d6-178">-세션 없는 채널 동작: 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-178">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="ee5d6-179">-세션 채널 동작: 세션 및 <xref:System.ServiceModel.InstanceContext> 각 채널에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-179">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each channel.</span></span><br /><span data-ttu-id="ee5d6-180">-세션 없는 채널 동작:는 <xref:System.ServiceModel.InstanceContext> 각 호출에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-180">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|<span data-ttu-id="ee5d6-181">-세션 채널 동작: 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-181">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="ee5d6-182">-세션 없는 채널 동작:는 <xref:System.ServiceModel.InstanceContext> 각 호출에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-182">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|  
|<span data-ttu-id="ee5d6-183">Single</span><span class="sxs-lookup"><span data-stu-id="ee5d6-183">Single</span></span>|<span data-ttu-id="ee5d6-184">-세션 채널 동작: 하나의 세션 및 하나의 <xref:System.ServiceModel.InstanceContext> 모든 호출에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-184">-   Behavior with sessionful channel: A session and one <xref:System.ServiceModel.InstanceContext> for all calls.</span></span><br /><span data-ttu-id="ee5d6-185">-세션 없는 채널 동작: 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-185">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="ee5d6-186">-세션 채널 동작: 세션 및 <xref:System.ServiceModel.InstanceContext> 만들거나 사용자 지정 singleton에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-186">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for the created or user-specified singleton.</span></span><br /><span data-ttu-id="ee5d6-187">-세션 없는 채널 동작:는 <xref:System.ServiceModel.InstanceContext> 만들거나 사용자 지정 singleton에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-187">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for the created or user-specified singleton.</span></span>|<span data-ttu-id="ee5d6-188">-세션 채널 동작: 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-188">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="ee5d6-189">-세션 없는 채널 동작:는 <xref:System.ServiceModel.InstanceContext> 각 만들어진된 singleton 또는 사용자 지정 singleton에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee5d6-189">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each created singleton or for the user-specified singleton.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="ee5d6-190">참고 항목</span><span class="sxs-lookup"><span data-stu-id="ee5d6-190">See Also</span></span>  
 [<span data-ttu-id="ee5d6-191">세션 사용</span><span class="sxs-lookup"><span data-stu-id="ee5d6-191">Using Sessions</span></span>](../../../../docs/framework/wcf/using-sessions.md)  
 [<span data-ttu-id="ee5d6-192">방법: 세션이 필요한 서비스 만들기</span><span class="sxs-lookup"><span data-stu-id="ee5d6-192">How to: Create a Service That Requires Sessions</span></span>](../../../../docs/framework/wcf/feature-details/how-to-create-a-service-that-requires-sessions.md)  
 [<span data-ttu-id="ee5d6-193">방법: 서비스 인스턴스 만들기 제어</span><span class="sxs-lookup"><span data-stu-id="ee5d6-193">How to: Control Service Instancing</span></span>](../../../../docs/framework/wcf/feature-details/how-to-control-service-instancing.md)  
 [<span data-ttu-id="ee5d6-194">동시성</span><span class="sxs-lookup"><span data-stu-id="ee5d6-194">Concurrency</span></span>](../../../../docs/framework/wcf/samples/concurrency.md)  
 [<span data-ttu-id="ee5d6-195">인스턴스 만들기</span><span class="sxs-lookup"><span data-stu-id="ee5d6-195">Instancing</span></span>](../../../../docs/framework/wcf/samples/instancing.md)  
 [<span data-ttu-id="ee5d6-196">세션</span><span class="sxs-lookup"><span data-stu-id="ee5d6-196">Session</span></span>](../../../../docs/framework/wcf/samples/session.md)

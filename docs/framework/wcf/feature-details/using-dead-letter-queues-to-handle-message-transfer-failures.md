---
title: "배달 못 한 편지 큐를 사용하여 메시지 전송 오류 처리"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
ms.assetid: 9e891c6a-d960-45ea-904f-1a00e202d61a
caps.latest.revision: "19"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: 1b02d1d826e78d7f324e638d7e2baac96bb8bbaa
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="using-dead-letter-queues-to-handle-message-transfer-failures"></a><span data-ttu-id="31363-102">배달 못 한 편지 큐를 사용하여 메시지 전송 오류 처리</span><span class="sxs-lookup"><span data-stu-id="31363-102">Using Dead-Letter Queues to Handle Message Transfer Failures</span></span>
<span data-ttu-id="31363-103">대기 중인 메시지를 배달하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-103">Queued messages can fail delivery.</span></span> <span data-ttu-id="31363-104">이러한 실패 메시지는 배달 못 한 편지 큐에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="31363-104">These failed messages are recorded in a dead-letter queue.</span></span> <span data-ttu-id="31363-105">네트워크 오류, 삭제된 큐, 꽉 찬 큐, 인증 오류 또는 정시 배달 실패와 같은 이유로 인해 배달 실패가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-105">The failed delivery can be caused by reasons such as network failures, a deleted queue, a full queue, authentication failure, or a failure to deliver on time.</span></span>  
  
 <span data-ttu-id="31363-106">대기 중인 메시지는 수신 응용 프로그램이 적절한 시간 내에 큐에서 메시지를 읽지 못하는 경우 오랫동안 큐에 남을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-106">Queued messages can remain in the queue for a long time if the receiving application does not read them from the queue in a timely fashion.</span></span> <span data-ttu-id="31363-107">이러한 동작은 시간이 중요한 메시지에 적합하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-107">This behavior may not be appropriate for time-sensitive messages.</span></span> <span data-ttu-id="31363-108">시간이 중요한 메시지에는 대기 중인 바인딩에 설정되어 있는 TTL(Time to Live) 속성이 있으며, 이 속성은 메시지가 만료되기 전에 큐에 있을 수 있는 시간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="31363-108">Time-sensitive messages have a Time to Live (TTL) property set in the queued binding, which indicates how long the messages can be in the queue before they must expire.</span></span> <span data-ttu-id="31363-109">만료된 메시지는 배달 못한 편지 큐라는 특수 큐로 보내집니다.</span><span class="sxs-lookup"><span data-stu-id="31363-109">Expired messages are sent to a special queue called the dead-letter queue.</span></span> <span data-ttu-id="31363-110">또한 큐 할당량 초과 또는 인증 오류 등 다른 이유로 메시지가 배달 못 한 편지 큐에 배치될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-110">Messages can also be put in a dead-letter queue for other reasons, such as exceeding a queue quota or because of authentication failure.</span></span>  
  
 <span data-ttu-id="31363-111">일반적으로 응용 프로그램에서는 배달 못 한 편지 큐에서 메시지를 읽는 보정 논리 및 실패 이유를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-111">Generally, applications write compensation logic to read messages from the dead-letter queue and failure reasons.</span></span> <span data-ttu-id="31363-112">보정 논리는 실패의 원인에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="31363-112">The compensation logic depends on the cause of the failure.</span></span> <span data-ttu-id="31363-113">예를 들어, 인증 오류의 경우 메시지에 첨부된 인증서를 수정하여 메시지를 다시 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-113">For example, in the case of authentication failure, you can correct the certificate attached with the message and resend the message.</span></span> <span data-ttu-id="31363-114">대상 큐 할당량을 초과하여 배달에 실패한 경우 할당량 문제가 해결되었기를 기대하며 배달을 다시 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-114">If delivery failed because the target queue quota was reached, you can reattempt delivery in the hope that the quota problem was resolved.</span></span>  
  
 <span data-ttu-id="31363-115">대부분의 큐 시스템에는 해당 시스템에서 실패한 모든 메시지가 저장되는 시스템 차원의 배달 못 한 편지 큐가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-115">Most queuing systems have a system-wide dead-letter queue where all failed messages from that system are stored.</span></span> <span data-ttu-id="31363-116">메시지 큐(MSMQ)에서는 두 개의 시스템 차원의 배달 못 한 편지 큐를 제공합니다. 하나는 트랜잭션 큐에 배달하지 못한 메시지를 저장하는 시스템 차원의 배달 못 한 트랜잭션 큐이고 다른 하나는 비트랜잭션 큐에 배달하지 못한 메시지를 저장하는 시스템 차원의 배달 못 한 비트랜잭션 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="31363-116">Message Queuing (MSMQ) provides two system-wide dead-letter queues: a transactional system-wide dead-letter queue that stores messages that failed delivery to the transactional queue and a non-transactional system-wide dead-letter queue that stores messages that failed delivery to the non-transactional queue.</span></span> <span data-ttu-id="31363-117">두 클라이언트에서 서로 다른 두 개의 서비스에 메시지를 보내는 경우 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]에 있는 서로 다른 큐는 보낼 동일한 MSMQ 서비스를 공유하므로 배달 못 한 시스템 큐에 유형이 다른 여러 메시지가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-117">If two clients are sending messages to two different services, and therefore different queues in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] are sharing the same MSMQ service to send, then it is possible to have a mix of messages in the system dead-letter queue.</span></span> <span data-ttu-id="31363-118">이 방법이 항상 최상은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="31363-118">This is not always optimal.</span></span> <span data-ttu-id="31363-119">예를 들어 보안과 같이 경우에 따라 한 클라이언트가 배달 못 한 편지 큐에서 다른 클라이언트의 메시지를 읽을 수 없도록 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-119">In several cases (security, for example), you may not want one client to read another client's messages from a dead-letter queue.</span></span> <span data-ttu-id="31363-120">또한 공유된 배달 못 한 편지 큐에서는 클라이언트가 큐를 탐색하여 보낸 메시지를 찾도록 합니다. 이런 경우 배달 못 한 편지 큐에 있는 메시지의 수에 따라 지나치게 많은 비용이 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-120">A shared dead-letter queue also requires clients to browse through the queue to find a message that they sent, which can be prohibitively expensive based on the number of messages in the dead-letter queue.</span></span> <span data-ttu-id="31363-121">따라서 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] `NetMsmqBinding`, `MsmqIntegrationBinding,` 및 MSMQ에 [!INCLUDE[wv](../../../../includes/wv-md.md)] (응용 프로그램별 배달 못 한 편지 큐 라고도 함)는 사용자 지정 배달 못 한 편지 큐를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-121">Therefore, in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]`NetMsmqBinding`, `MsmqIntegrationBinding,` and MSMQ on [!INCLUDE[wv](../../../../includes/wv-md.md)] provide a custom dead-letter queue (sometimes referred to as an application-specific dead-letter queue).</span></span>  
  
 <span data-ttu-id="31363-122">사용자 지정 배달 못 한 편지 큐에서는 메시지를 보내는 동일한 MSMQ 서비스를 공유하는 클라이언트를 격리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-122">The custom dead-letter queue provides isolation between clients that share the same MSMQ service to send messages.</span></span>  
  
 <span data-ttu-id="31363-123">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 및 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]에서 [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]는 시스템 차원의 배달 못 한 편지 큐를 대기 중인 모든 클라이언트 응용 프로그램에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-123">On [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)], [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] provides a system-wide dead-letter queue for all queued client applications.</span></span> <span data-ttu-id="31363-124">[!INCLUDE[wv](../../../../includes/wv-md.md)]에서 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]는 배달 못 한 편지 큐를 대기 중인 각 클라이언트 응용 프로그램에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-124">On [!INCLUDE[wv](../../../../includes/wv-md.md)], [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] provides a dead-letter queue for each queued client application.</span></span>  
  
## <a name="specifying-use-of-the-dead-letter-queue"></a><span data-ttu-id="31363-125">배달 못 한 편지 큐의 사용 지정</span><span class="sxs-lookup"><span data-stu-id="31363-125">Specifying Use of the Dead-Letter Queue</span></span>  
 <span data-ttu-id="31363-126">배달 못 한 편지 큐는 송신 응용 프로그램의 큐 관리자에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-126">A dead-letter queue is in the queue manager of the sending application.</span></span> <span data-ttu-id="31363-127">이 관리자는 만료되었거나 전송 또는 배달하지 못한 메시지를 보관합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-127">It stores messages that have expired or that have failed transfer or delivery.</span></span>  
  
 <span data-ttu-id="31363-128">바인딩에는 다음과 같은 배달 못 한 편지 큐 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-128">The binding has the following dead-letter queue properties:</span></span>  
  
-   <xref:System.ServiceModel.MsmqBindingBase.DeadLetterQueue%2A>  
  
-   <xref:System.ServiceModel.MsmqBindingBase.CustomDeadLetterQueue%2A>  
  
## <a name="reading-messages-from-the-dead-letter-queue"></a><span data-ttu-id="31363-129">배달 못 한 편지 큐에서 메시지 읽기</span><span class="sxs-lookup"><span data-stu-id="31363-129">Reading Messages from the Dead-Letter Queue</span></span>  
 <span data-ttu-id="31363-130">배달 못 한 편지 큐에서 메시지를 읽는 응용 프로그램은 다음과 같은 사소한 차이를 제외하면 응용 프로그램 큐에서 읽는 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 서비스와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-130">An application that reads messages out of a dead-letter queue is similar to a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service that reads from an application queue, except for the following minor differences:</span></span>  
  
-   <span data-ttu-id="31363-131">시스템 트랜잭션 배달 못 한 편지 큐에서 메시지를 읽으려면 URI(Uniform Resource Identifier)가 net.msmq://localhost/system$;DeadXact 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-131">To read messages from a system transactional dead-letter queue, the Uniform Resource Identifier (URI) must be of the form: net.msmq://localhost/system$;DeadXact.</span></span>  
  
-   <span data-ttu-id="31363-132">배달 못 한 시스템 비트랜잭션 큐에서 메시지를 읽으려면 URI가 net.msmq://localhost/system$;DeadLetter 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-132">To read messages from a system non-transactional dead-letter queue, the URI must be of the form: net.msmq://localhost/system$;DeadLetter.</span></span>  
  
-   <span data-ttu-id="31363-133">양식: net.msmq://localhost/private/의 사용자 지정 배달 못 한 편지 큐에서 메시지를 알아보려면 URI 여야 합니다\<*사용자 지정 dlq가 이름*> 여기서 *사용자 지정 dlq가 이름* 사용자 지정의 이름 배달 못 한 편지 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="31363-133">To read messages from a custom dead-letter queue, the URI must be of the form:net.msmq://localhost/private/\<*custom-dlq-name*> where *custom-dlq-name* is the name of the custom dead-letter queue.</span></span>  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="31363-134">큐 주소를 참조 하는 방법 [서비스 끝점 및 큐 주소 지정](../../../../docs/framework/wcf/feature-details/service-endpoints-and-queue-addressing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-134"> how to address queues, see [Service Endpoints and Queue Addressing](../../../../docs/framework/wcf/feature-details/service-endpoints-and-queue-addressing.md).</span></span>  
  
 <span data-ttu-id="31363-135">수신자의 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 스택에서는 서비스가 수신 대기하는 주소와 메시지의 주소가 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-135">The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] stack on the receiver matches addresses that the service is listening on with the address on the message.</span></span> <span data-ttu-id="31363-136">주소가 일치하면 메시지가 디스패치되고, 그렇지 않으면 메시지가 디스패치되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-136">If the addresses match, the message is dispatched; if not, the message is not dispatched.</span></span> <span data-ttu-id="31363-137">일반적으로 배달 못 한 편지 큐에 있는 메시지는 배달 못 한 편지 큐 서비스가 아닌 서비스에 주소가 지정되기 때문에 배달 못 한 편지 큐에서 메시지를 읽을 때 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-137">This can cause problems when reading from the dead-letter queue, because messages in the dead-letter queue are typically addressed to the service and not the dead-letter queue service.</span></span> <span data-ttu-id="31363-138">따라서 배달 못 한 편지 큐에서 메시지를 읽는 서비스는 수신자와 관계없이 큐의 모든 메시지를 일치시키도록 스택에 지시하는 주소 필터 `ServiceBehavior`를 설치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-138">Therefore, the service reading from the dead-letter queue must install an address filter `ServiceBehavior` that instructs the stack to match all messages in the queue independently of the addressee.</span></span> <span data-ttu-id="31363-139">특히 `ServiceBehavior`를 <xref:System.ServiceModel.AddressFilterMode.Any> 매개 변수와 함께 배달 못 한 편지 큐에서 메시지를 읽는 서비스에 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-139">Specifically, you must add a `ServiceBehavior` with the <xref:System.ServiceModel.AddressFilterMode.Any> parameter to the service reading messages from the dead-letter queue.</span></span>  
  
## <a name="poison-message-handling-from-the-dead-letter-queue"></a><span data-ttu-id="31363-140">배달 못 한 편지 큐에서 포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="31363-140">Poison Message Handling from the Dead-Letter Queue</span></span>  
 <span data-ttu-id="31363-141">경우에 따라 배달 못 한 편지 큐에서 포이즌 메시지 처리가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-141">Poison message handling is available on dead-letter queues, with some conditions.</span></span> <span data-ttu-id="31363-142">시스템 큐에서 하위 큐를 만들 수 없기 때문에 배달 못 한 시스템 큐에서 메시지를 읽는 경우 `ReceiveErrorHandling`을 `Move`로 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="31363-142">Because you cannot create sub-queues from system queues, when reading from the system dead-letter queue, the `ReceiveErrorHandling` cannot be set to `Move`.</span></span> <span data-ttu-id="31363-143">사용자 지정 배달 못 한 편지 큐에서 메시지를 읽는 경우 하위 큐를 사용할 수 있으므로 `Move`는 포이즌 메시지의 유효한 처리 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="31363-143">Note that if you are reading from a custom dead-letter queue, you can have sub-queues and, therefore, `Move` is a valid disposition for the poison message.</span></span>  
  
 <span data-ttu-id="31363-144">`ReceiveErrorHandling`이 `Reject`로 설정된 경우 사용자 지정 배달 못 한 편지 큐에서 메시지를 읽으면 포이즌 메시지가 배달 못 한 시스템 큐에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="31363-144">When `ReceiveErrorHandling` is set to `Reject`, when reading from the custom dead letter queue, the poison message is put in the system dead-letter queue.</span></span> <span data-ttu-id="31363-145">배달 못 한 시스템 큐에서 메시지를 읽는 경우 메시지가 손실/삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="31363-145">If reading from the system dead-letter queue, the message is dropped (purged).</span></span> <span data-ttu-id="31363-146">MSMQ에서 배달 못 한 시스템 큐의 거부로 인해 메시지가 손실/삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="31363-146">A reject from a system dead-letter queue in MSMQ drops (purges) the message.</span></span>  
  
## <a name="example"></a><span data-ttu-id="31363-147">예제</span><span class="sxs-lookup"><span data-stu-id="31363-147">Example</span></span>  
 <span data-ttu-id="31363-148">다음 예제에서는 배달 못 한 편지 큐를 만드는 방법 및 이를 사용하여 만료된 메시지를 처리하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="31363-148">The following example shows how to create a dead-letter queue and how to use it to process expired messages.</span></span> <span data-ttu-id="31363-149">예제를 기반으로 하는 예제 [하는 방법: WCF 끝점으로 메시지 큐에 대기를 교환](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="31363-149">The example is based on the example in [How to: Exchange Queued Messages with WCF Endpoints](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md).</span></span> <span data-ttu-id="31363-150">다음 예제에서는 각 응용 프로그램의 배달 못 한 편지 큐를 사용하는 주문 처리 서비스에 클라이언트 코드를 작성하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="31363-150">The following example shows how to write the client code to the order processing service that uses a dead-letter queue for each application.</span></span> <span data-ttu-id="31363-151">또한 예제에서는 배달 못 한 편지 큐에서 메시지를 처리하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="31363-151">The example also shows how to process messages from the dead-letter queue.</span></span>  
  
 <span data-ttu-id="31363-152">다음은 각 응용 프로그램의 배달 못 한 편지 큐를 지정하는 클라이언트의 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="31363-152">The following is code for a client that specifies a dead-letter queue for each application.</span></span>  
  
 [!code-csharp[S_DeadLetter#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_deadletter/cs/client.cs#1)]
 [!code-vb[S_DeadLetter#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_deadletter/vb/client.vb#1)]  
  
 <span data-ttu-id="31363-153">다음은 클라이언트 구성 파일의 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="31363-153">The following is code for the client configuration file.</span></span>  
  
  
  
 <span data-ttu-id="31363-154">다음은 배달 못 한 편지 큐의 메시지를 처리하는 서비스의 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="31363-154">The following is code for a service processing messages from a dead-letter queue.</span></span>  
  
 [!code-csharp[S_DeadLetter#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_deadletter/cs/dlservice.cs#3)]
 [!code-vb[S_DeadLetter#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_deadletter/vb/dlservice.vb#3)]  
  
 <span data-ttu-id="31363-155">다음은 배달 못 한 편지 큐 서비스 구성 파일의 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="31363-155">The following is code for the dead-letter queue service configuration file.</span></span>  
  
  
  
## <a name="see-also"></a><span data-ttu-id="31363-156">참고 항목</span><span class="sxs-lookup"><span data-stu-id="31363-156">See Also</span></span>  
 [<span data-ttu-id="31363-157">큐 개요</span><span class="sxs-lookup"><span data-stu-id="31363-157">Queues Overview</span></span>](../../../../docs/framework/wcf/feature-details/queues-overview.md)  
 [<span data-ttu-id="31363-158">방법: 대기 중인 WCF 끝점으로 메시지를 교환</span><span class="sxs-lookup"><span data-stu-id="31363-158">How to: Exchange Queued Messages with WCF Endpoints</span></span>](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md)  
 [<span data-ttu-id="31363-159">포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="31363-159">Poison Message Handling</span></span>](../../../../docs/framework/wcf/feature-details/poison-message-handling.md)

---
title: 데이터 계약의 XML 및 ADO.NET 형식
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
ms.openlocfilehash: ae21174d19ad69f87165427cf5a0bfd29ac872db
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33509108"
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="1a9a9-102">데이터 계약의 XML 및 ADO.NET 형식</span><span class="sxs-lookup"><span data-stu-id="1a9a9-102">XML and ADO.NET Types in Data Contracts</span></span>
<span data-ttu-id="1a9a9-103">Windows Communication Foundation (WCF) 데이터 계약 모델 XML을 직접 표시 하는 일부 형식을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-103">The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="1a9a9-104">이러한 형식이 XML에 serialize되면 serializer는 추가 처리 없이 이러한 형식의 XML 콘텐츠를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="1a9a9-105">지원되는 형식에는 <xref:System.Xml.XmlElement>을 구현하는 형식, <xref:System.Xml.XmlNode> 및 `XmlNode`의 배열이 있습니다. 단, <xref:System.Xml.Serialization.IXmlSerializable> 형식 자체는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="1a9a9-106"><xref:System.Data.DataSet> 및 <xref:System.Data.DataTable> 형식은 형식화된 데이터 집합과 마찬가지로 데이터베이스 프로그래밍에 자주 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="1a9a9-107">이러한 형식은 `IXmlSerializable` 인터페이스를 구현하므로 데이터 계약 모델에서 serialize할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="1a9a9-108">이러한 형식에 대한 몇 가지 특별한 고려 사항은 이 항목의 끝부분에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="1a9a9-109">XML 형식</span><span class="sxs-lookup"><span data-stu-id="1a9a9-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="1a9a9-110">XML 요소</span><span class="sxs-lookup"><span data-stu-id="1a9a9-110">Xml Element</span></span>  
 <span data-ttu-id="1a9a9-111">`XmlElement` 형식은 XML 콘텐츠를 사용하여 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="1a9a9-112">예를 들어, 다음 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="1a9a9-113">이 형식은 다음과 같이 XML로 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="1a9a9-114">래퍼 데이터 멤버 요소 `<myDataMember>`가 여전히 있음을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="1a9a9-115">데이터 계약 모델에서 이 요소를 제거할 수 있는 방법은 없으며,</span><span class="sxs-lookup"><span data-stu-id="1a9a9-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="1a9a9-116">이 모델을 처리하는 serializer(<xref:System.Runtime.Serialization.DataContractSerializer> 및 <xref:System.Runtime.Serialization.NetDataContractSerializer>)가 특수 특성을 이 래퍼 요소로 내보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="1a9a9-117">이러한 특성에는 표준 XML 스키마 인스턴스 "nil" 특성(`XmlElement`가 `null`인 경우 허용) 및 "type" 특성(`XmlElement`가 다형적으로 사용되는 경우 허용)이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="1a9a9-118">또한 다음과 같은 XML 특성은 WCF 관련: "Id", "Ref", "Type" 및 "Assembly"입니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-118">Also, the following XML attributes are specific to WCF: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="1a9a9-119">이러한 특성을 내보내서 개체 그래프 유지 모드가 활성화된 상태로 또는 `XmlElement`로 <xref:System.Runtime.Serialization.NetDataContractSerializer> 사용을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="1a9a9-120">(개체 그래프 유지 모드가 대 한 자세한 내용은 참조 [Serialization 및 Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span><span class="sxs-lookup"><span data-stu-id="1a9a9-120">(For more information about the object graph preservation mode, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="1a9a9-121">`XmlElement`의 배열 또는 컬렉션이 허용되며 다른 배열이나 컬렉션과 같이 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="1a9a9-122">즉, 전체 컬렉션에 대한 래퍼 요소와 배열의 각 `<myDataMember>`에 대한 개별 래퍼 요소(이전 예제의 `XmlElement`와 유사)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="1a9a9-123">deserialize할 때 deserializer는 들어오는 XML에서 `XmlElement`를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="1a9a9-124">또한 deserializer는 유효한 부모 <xref:System.Xml.XmlDocument>를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="1a9a9-125">`XmlElement`로 deserialize되는 XML 단편은 사용할 모든 접두사를 정의하고 상위 요소의 접두사 정의를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="1a9a9-126">이는 `DataContractSerializer`를 사용하여 `DataContractSerializer`가 아닌 다른 소스의 XML에 액세스하는 경우에만 문제가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="1a9a9-127">와 함께 사용할 경우의 `DataContractSerializer`, `XmlElement` 형식의 데이터 멤버에만 다형적으로 할당할 수 있습니다 <xref:System.Object>합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="1a9a9-128"><xref:System.Collections.IEnumerable>가 `XmlElement`을 구현할지라도 이를 컬렉션 형식으로 사용할 수 없으며 <xref:System.Collections.IEnumerable> 데이터 멤버에 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="1a9a9-129">모든 다형적 할당과 마찬가지로 `DataContractSerializer` 데이터 계약 이름을 결과 XML에서이 예제의 중인 "XmlElement"는 "http://schemas.datacontract.org/2004/07/System.Xml" 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="1a9a9-130">`NetDataContractSerializer`에서는 `XmlElement` 또는 `Object`에 대한 `IEnumerable`의 모든 유효한 다형적 할당이 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="1a9a9-131">다형적으로 할당되는지 여부에 관계없이 이러한 serializer를 `XmlElement`에서 파생된 형식과 함께 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="1a9a9-132">XmlNode 배열</span><span class="sxs-lookup"><span data-stu-id="1a9a9-132">Array of XmlNode</span></span>  
 <span data-ttu-id="1a9a9-133"><xref:System.Xml.XmlNode> 배열의 사용 방식은 `XmlElement` 사용 방식과 매우 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="1a9a9-134">`XmlNode`의 배열을 사용하면 `XmlElement`를 사용할 때보다 유연성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="1a9a9-135">데이터 멤버 래핑 요소 내에 여러 개의 요소를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="1a9a9-136">또한 데이터 멤버 래핑 요소 내에 요소 이외의 콘텐츠(예: XML 주석)를 삽입할 수도 있으며,</span><span class="sxs-lookup"><span data-stu-id="1a9a9-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="1a9a9-137">마지막으로 래핑 데이터 멤버 요소에 특성을 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="1a9a9-138">이러한 작업은 `XmlNode`의 배열을 `XmlNode`의 특정 파생 클래스(예: <xref:System.Xml.XmlAttribute>, `XmlElement` 또는 <xref:System.Xml.XmlComment>)로 채워서 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="1a9a9-139">예를 들어, 다음 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="1a9a9-140">serialize한 후의 결과 XML은 다음 코드와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="1a9a9-141">데이터 멤버 래퍼 요소 `<myDataMember>`에는 특성, 주석 및 두 개의 요소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="1a9a9-142">이들은 serialize된 4개의 `XmlNode` 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="1a9a9-143">잘못된 XML을 생성하는 `XmlNode` 배열은 serialize할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="1a9a9-144">예를 들어 첫 번째 인스턴스가 `XmlNode`이고 두 번째 인스턴스가 `XmlElement`인 두 <xref:System.Xml.XmlAttribute> 인스턴스의 배열은 이 시퀀스가 올바른 XML 인스턴스에 해당하지 않고 특성을 연결할 위치가 없으므로 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="1a9a9-145">`XmlNode` 배열을 deserialize하면 노드가 만들어지고 들어오는 XML의 정보로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="1a9a9-146">또한 deserializer는 유효한 부모 <xref:System.Xml.XmlDocument>를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="1a9a9-147">모든 특성을 래퍼 데이터 멤버 요소를 포함 하 여 모든 노드가 deserialize 됩니다 하지만 (예: 다형적 할당을 나타내는 데 사용 되는 특성) WCF serializer에 의해 배치 된 특성 제외 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="1a9a9-148">XML 단편에서 모든 네임스페이스 접두사를 정의하는 방법에 대한 경고가 `XmlNode`를 deserialize하는 경우와 마찬가지로 `XmlElement` 배열의 deserialization에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="1a9a9-149">개체 그래프 유지가 설정된 상태로 serializer를 사용하는 경우 개별 `XmlNode` 인스턴스가 아니라 `XmlNode` 배열 수준에서만 개체 동일성이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="1a9a9-150">노드 중 하나 이상이 `XmlNode`로 설정된 `null` 배열은 serialize하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="1a9a9-151">전체 배열 멤버가 `null`일 수는 있지만 배열에 포함된 개별 `XmlNode`가 null일 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="1a9a9-152">전체 배열 멤버가 null이면 래퍼 데이터 멤버 요소에 null임을 나타내는 특수 특성이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="1a9a9-153">deserialize할 때는 전체 배열 멤버가 null이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="1a9a9-154">`XmlNode`의 일반 배열만 serializer에서 특별하게 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="1a9a9-155">`XmlNode`가 포함된 다른 컬렉션 형식으로 선언된 데이터 멤버 또는 `XmlNode`에서 파생된 형식의 배열로 선언된 데이터 멤버는 특별하게 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="1a9a9-156">따라서 이러한 데이터 멤버가 serialization에 대한 다른 조건 중 하나를 충족하지 않으면 일반적으로 데이터 멤버를 serialize할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="1a9a9-157">`XmlNode` 배열이나 배열의 컬렉션은 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="1a9a9-158">전체 컬렉션에 대한 래퍼 요소와 외부 배열 또는 컬렉션의 각 `<myDataMember>` 배열의 개별 래퍼 요소(이전 예제의 `XmlNode`와 유사)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="1a9a9-159"><xref:System.Array>의 `Object` 형식이나 `Array`의 `IEnumerable` 형식 데이터 멤버를 `XmlNode` 인스턴스로 채우면 데이터 멤버가 `Array` 인스턴스의 `XmlNode`로 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="1a9a9-160">각 배열 멤버는 개별적으로 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="1a9a9-161">`DataContractSerializer`와 함께 사용되는 경우 `XmlNode`는 `Object` 형식의 데이터 멤버에만 다형적으로 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="1a9a9-162">`IEnumerable`가 `XmlNode`을 구현할지라도 이 배열을 컬렉션 형식으로 사용할 수 없으며 `IEnumerable` 데이터 멤버에 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="1a9a9-163">모든 다형적 할당과 마찬가지로 `DataContractSerializer` 데이터 계약 이름을 결과 XML에서이 예제의 중인 "ArrayOfXmlNode"는 "http://schemas.datacontract.org/2004/07/System.Xml" 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="1a9a9-164">와 함께 사용할 경우의 `NetDataContractSerializer`, 모든 유효한 할당이 `XmlNode` 배열이 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="1a9a9-165">스키마 고려 사항</span><span class="sxs-lookup"><span data-stu-id="1a9a9-165">Schema Considerations</span></span>  
 <span data-ttu-id="1a9a9-166">XML 형식 매핑 스키마에 대 한 세부 정보를 참조 하십시오. [데이터 계약 스키마 참조](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="1a9a9-167">이 단원에서는 중요한 사항을 요약하여 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="1a9a9-168">`XmlElement` 형식의 데이터 멤버는 다음 익명 형식을 사용하여 정의된 요소에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="1a9a9-169">`XmlNode`의 Array 형식 데이터 멤버는 다음 익명 형식을 사용하여 정의된 요소에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="1a9a9-170">IXmlSerializable 인터페이스를 구현하는 형식</span><span class="sxs-lookup"><span data-stu-id="1a9a9-170">Types Implementing the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="1a9a9-171">`IXmlSerializable` 인터페이스를 구현하는 형식은 `DataContractSerializer`에서 완전히 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="1a9a9-172">이러한 형식의 스키마를 제어하려면 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 특성을 항상 이러한 형식에 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="1a9a9-173">`IXmlSerializable`을 구현하는 형식에는 임의의 콘텐츠를 나타내는 형식, 단일 요소를 나타내는 형식 및 레거시 <xref:System.Data.DataSet> 형식 등 세 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
-   <span data-ttu-id="1a9a9-174">콘텐츠 형식은 `XmlSchemaProviderAttribute` 특성에 지정된 스키마 공급자 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="1a9a9-175">이 메서드는 `null`을 반환하지 않으며 특성의 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 속성은 기본값인 `false`로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="1a9a9-176">이는 `IXmlSerializable` 형식의 가장 일반적인 사용입니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
-   <span data-ttu-id="1a9a9-177">요소 형식은 `IXmlSerializable` 형식이 루트 요소 이름을 제어해야 하는 경우에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="1a9a9-178">형식을 요소 형식으로 표시하려면 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 특성의 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 속성을 `true`로 설정하거나 스키마 공급자 메서드의 null을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="1a9a9-179">스키마 공급자 메서드 사용은 요소 형식의 옵션이며 `XmlSchemaProviderAttribute`에 메서드 이름 대신 null을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="1a9a9-180">그러나 `IsAny`가 `true`이고 스키마 공급자 메서드가 지정된 경우 메서드는 null을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
-   <span data-ttu-id="1a9a9-181">레거시 <xref:System.Data.DataSet> 형식은 `IXmlSerializable` 특성으로 표시되지 않은 `XmlSchemaProviderAttribute` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="1a9a9-182">대신 이러한 형식은 스키마 생성 시 <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="1a9a9-183">이 패턴은 `DataSet` 형식에 사용되고 해당 형식화된 데이터 집합은 이전 버전의 .NET Framework에서는 클래스를 파생하지만 현재는 더 이상 사용되지 않으며 레거시 용도로만 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="1a9a9-184">이 패턴을 사용하는 대신 `XmlSchemaProviderAttribute`를 항상 `IXmlSerializable` 형식에 적용하세요.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="1a9a9-185">IXmlSerializable 콘텐츠 형식</span><span class="sxs-lookup"><span data-stu-id="1a9a9-185">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="1a9a9-186">이전에 정의한 콘텐츠 형식이며 `IXmlSerializable`을 구현하는 형식의 데이터 멤버를 serialize할 때 serializer는 데이터 멤버의 래퍼 요소를 쓰고 제어를 <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 메서드에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="1a9a9-187"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 구현은 특성을 래퍼 요소에 추가하는 것을 포함하여 모든 XML을 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="1a9a9-188">`WriteXml`이 완료되면 serializer는 요소를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="1a9a9-189">`IXmlSerializable`을 구현하고 이전에 정의된 콘텐츠 형식인 형식의 데이터 멤버를 deserialize할 때 deserializer는 데이터 멤버의 래퍼 요소에 XML 판독기를 배치하고 제어를 <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> 메서드에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="1a9a9-190">메서드는 시작 및 끝 태그를 비롯하여 전체 요소를 읽어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="1a9a9-191">`ReadXml` 코드는 요소가 비어 있는 경우를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="1a9a9-192">또한 `ReadXml` 구현은 래퍼 요소의 이름이 특정한 방식으로 지정되는 데 의존해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="1a9a9-193">serializer에서 선택되는 이름은 다양할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="1a9a9-194">`IXmlSerializable` 형식의 데이터 멤버 등에 다형적으로 <xref:System.Object> 콘텐츠 형식을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="1a9a9-195">또한 형식 인스턴스는 null일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="1a9a9-196">마지막으로 개체 그래프 유지가 활성화된 상태 및 `IXmlSerializable`로 <xref:System.Runtime.Serialization.NetDataContractSerializer>을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="1a9a9-197">이러한 모든 기능에는 특정 특성을 래퍼 요소에 연결 하는 WCF serializer 필요 ("nil" 및 "type" XML 스키마 인스턴스 네임 스페이스 및 "Id", "Ref", "Type" 및 "Assembly" WCF 관련 네임 스페이스에).</span><span class="sxs-lookup"><span data-stu-id="1a9a9-197">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="1a9a9-198">ReadXml을 구현할 때 무시할 특성</span><span class="sxs-lookup"><span data-stu-id="1a9a9-198">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="1a9a9-199">제어를 `ReadXml` 코드에 전달하기 전에 deserializer는 XML 요소를 검사하고 이러한 특수 XML 특성을 검색하여 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="1a9a9-200">예를 들어 "nil"이 `true`이면 null 값이 deserialize되고 `ReadXml`은 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="1a9a9-201">다형성이 검색되면 요소의 콘텐츠가 다른 형식인 것처럼 deserialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="1a9a9-202">다형적으로 할당된 형식의 `ReadXml` 구현이 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="1a9a9-203">어떤 경우에든 이러한 특수 특성은 deserializer에 의해 처리되므로 `ReadXml` 구현에서는 해당 특수 특성을 무시해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="1a9a9-204">IXmlSerializable 콘텐츠 형식의 스키마 고려 사항</span><span class="sxs-lookup"><span data-stu-id="1a9a9-204">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="1a9a9-205">스키마를 `IXmlSerializable` 콘텐츠 형식으로 내보내면 스키마 공급자 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="1a9a9-206"><xref:System.Xml.Schema.XmlSchemaSet>가 스키마 공급자 메서드로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="1a9a9-207">메서드는 유효한 스키마를 모두 스키마 집합에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="1a9a9-208">스키마 집합에는 스키마를 내보낼 때 이미 알려진 스키마가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="1a9a9-209">스키마 공급자 메서드는 스키마 집합에 항목을 추가해야 하는 경우 해당 네임스페이스를 가진 <xref:System.Xml.Schema.XmlSchema>가 집합에 이미 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="1a9a9-210">이미 있으면 스키마 공급자 메서드는 기존 `XmlSchema`에 새 항목을 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="1a9a9-211">없는 경우에는 새 `XmlSchema` 인스턴스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="1a9a9-212">이 기능은 `IXmlSerializable` 형식의 배열을 사용하는 경우에 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="1a9a9-213">예를 들어 "B" 네임스페이스에 "A" 형식으로 내보내지는 `IXmlSerializable` 형식이 있는 경우 스키마 공급자 메서드가 호출될 때까지 스키마 집합에 "ArrayOfA" 형식을 보유할 "B"의 스키마가 이미 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="1a9a9-214"><xref:System.Xml.Schema.XmlSchemaSet>에 형식을 추가하는 것 외에 콘텐츠 형식의 스키마 공급자 메서드는 null이 아닌 값을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="1a9a9-215">이 메서드는 지정된 <xref:System.Xml.XmlQualifiedName> 형식에 사용할 스키마 형식의 이름을 지정하는 `IXmlSerializable`을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="1a9a9-216">이 정규화된 이름은 형식의 데이터 계약 이름과 네임스페이스로도 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="1a9a9-217">스키마 공급자 메서드가 반환될 때 즉시 스키마 집합에 없는 형식을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="1a9a9-218">그러나 관련된 모든 형식을 내보낼 때까지, 즉 <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A>의 모든 관련 형식에 대해 <xref:System.Runtime.Serialization.XsdDataContractExporter> 메서드가 호출되고 <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> 속성에 액세스할 때까지 형식은 스키마 집합에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="1a9a9-219">관련된 `Schemas` 호출을 수행하기 전에 `Export` 속성에 액세스하면 <xref:System.Xml.Schema.XmlSchemaException>이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="1a9a9-220">내보내기 프로세스에 대 한 자세한 내용은 참조 [클래스에서 스키마 내보내기](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-220">For more information about the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="1a9a9-221">스키마 공급자 메서드는 또한 사용할 <xref:System.Xml.Schema.XmlSchemaType>을 반환할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="1a9a9-222">형식은 익명이거나 익명이 아닐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="1a9a9-223">익명인 경우 `IXmlSerializable` 형식을 데이터 멤버로 사용할 때마다 `IXmlSerializable` 형식의 스키마가 익명 형식으로 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="1a9a9-224">`IXmlSerializable` 형식에 여전히 데이터 계약 이름과 네임스페이스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="1a9a9-225">(에 설명 된 대로이 확인할 [데이터 계약 이름을](../../../../docs/framework/wcf/feature-details/data-contract-names.md) 점을 제외 하 고는 <xref:System.Runtime.Serialization.DataContractAttribute> 특성을 사용 하 여 이름을 사용자 지정할 수 없습니다.) 익명이 아닌 경우 `XmlSchemaSet`의 형식 중 하나여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-225">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="1a9a9-226">이 경우는 형식의 `XmlQualifiedName`을 반환하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="1a9a9-227">또한 전역 요소 선언이 형식에 대해 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="1a9a9-228">형식에 <xref:System.Xml.Serialization.XmlRootAttribute> 특성이 적용되지 않은 경우 요소가 데이터 계약과 동일한 이름 및 네임스페이스를 갖게 되며 "nillable" 속성이 true가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="1a9a9-229">이 유일한 예외는 스키마 네임 스페이스 ("http://www.w3.org/2001/XMLSchema") – 새 요소는 스키마 네임 스페이스를 추가할 수는 없으므로 해당 전역 요소가 빈 네임 스페이스에는 형식의 데이터 계약이이 네임 스페이스에 포함 된 경우.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="1a9a9-230">형식에 `XmlRootAttribute` 특성이 적용되어 있으면 전역 요소 선언이 <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> 및 <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> 속성을 사용하여 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="1a9a9-231">`XmlRootAttribute`가 적용된 경우의 기본값은 데이터 계약 이름, 빈 네임스페이스 및 true인 "nillable"입니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="1a9a9-232">레거시 데이터 집합 형식에도 동일한 전역 요소 선언 규칙이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="1a9a9-233">`XmlRootAttribute`는 사용자 지정 코드를 통해 추가된, 즉 스키마 공급자 메서드를 사용하거나 레거시 데이터 집합 형식의 경우 `XmlSchemaSet`를 통해 `GetSchema`에 추가된 전역 요소 선언을 재정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="1a9a9-234">IXmlSerializable 요소 형식</span><span class="sxs-lookup"><span data-stu-id="1a9a9-234">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="1a9a9-235">`IXmlSerializable` 요소 형식은 `IsAny` 속성이 `true`로 설정되어 있거나 스키마 공급자 메서드가 `null`을 반환하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="1a9a9-236">요소 형식의 serialize 및 deserialize는 콘텐츠 형식의 serialize 및 deserialize와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="1a9a9-237">그러나 다음과 같은 중요한 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-237">However, there are some important differences:</span></span>  
  
-   <span data-ttu-id="1a9a9-238">`WriteXml` 구현은 정확히 하나의 요소를 씁니다. 물론 이 요소는 여러 개의 자식 요소를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="1a9a9-239">이 단일 요소, 여러 개의 형제 요소 또는 혼합 콘텐츠 외부의 특성을 쓰면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="1a9a9-240">요소는 비어 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-240">The element may be empty.</span></span>  
  
-   <span data-ttu-id="1a9a9-241">`ReadXml` 구현은 래퍼 요소를 읽어서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="1a9a9-242">`WriteXml`에서 생성하는 하나의 요소를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
-   <span data-ttu-id="1a9a9-243">예를 들어 데이터 계약의 데이터 멤버로 정기적으로 요소 형식을 serialize하는 경우 serializer는 콘텐츠 형식과 마찬가지로 `WriteXml`을 호출하기 전에 래퍼 요소를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="1a9a9-244">그러나 최상위 수준에서 요소 형식을 serialize할 때 serializer는 일반적으로 `WriteXml` 또는 `DataContractSerializer` 생성자에서 serializer를 생성할 때 루트 이름과 네임스페이스를 명시적으로 지정하지 않은 경우 `NetDataContractSerializer`에서 쓰는 요소를 둘러싼 래퍼 요소를 출력하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="1a9a9-245">자세한 내용은 참조 [Serialization 및 Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-245">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
-   <span data-ttu-id="1a9a9-246">생성 시 루트 이름과 네임스페이스를 지정하지 않고 최상위 수준에서 요소 형식을 serialize하는 경우 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> 및 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A>에서 아무 작업도 수행하지 않으며 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>는 `WriteXml`을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="1a9a9-247">이 모드에서 serialize되는 개체는 null일 수 없으며 다형적으로 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="1a9a9-248">또한 개체 그래프 유지를 활성화할 수 없고 `NetDataContractSerializer`를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
-   <span data-ttu-id="1a9a9-249">생성 시 루트 이름과 네임스페이스를 지정하지 않고 최상위 수준에서 요소 형식을 deserialize하는 경우 <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A>가 임의 요소의 시작 부분을 찾으면 `true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="1a9a9-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 매개 변수를 `verifyObjectName`로 설정한 `true`는 실제로 개체를 읽기 전에 `IsStartObject`와 같은 방식으로 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="1a9a9-251">그런 다음 `ReadObject`는 컨트롤을 `ReadXml` 메서드로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="1a9a9-252">요소 형식과 관련해서 내보낸 스키마는 스키마 공급자 메서드가 `XmlElement`에 다른 스키마를 추가할 수 있다는 점을 제외하고 이전 단원에서 설명한 대로 <xref:System.Xml.Schema.XmlSchemaSet> 형식에 대해 콘텐츠 형식과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="1a9a9-253">요소 형식에 `XmlRootAttribute` 특성을 사용할 수 없으며 이러한 형식에 대해 전역 요소 선언을 내보내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="1a9a9-254">XmlSerializer와의 차이점</span><span class="sxs-lookup"><span data-stu-id="1a9a9-254">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="1a9a9-255">`IXmlSerializable` 인터페이스와 `XmlSchemaProviderAttribute` 및 `XmlRootAttribute` 특성도 <xref:System.Xml.Serialization.XmlSerializer>에서 인식됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="1a9a9-256">그러나 데이터 계약 모델에서 처리되는 방법에 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="1a9a9-257">아래에 중요한 차이가 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-257">The important differences are summarized in the following:</span></span>  
  
-   <span data-ttu-id="1a9a9-258">`XmlSerializer`에서 사용할 수 있으려면 스키마 공급자 메서드가 public이어야 하지만 public이 아니어도 데이터 계약 모델에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
-   <span data-ttu-id="1a9a9-259">데이터 계약 모델에서 `IsAny`가 true일 때는 스키마 공급자 메서드가 호출되지만 `XmlSerializer`를 사용할 때는 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="1a9a9-260">콘텐츠 또는 레거시 데이터 집합 형식에 `XmlRootAttribute` 특성이 없으면 `XmlSerializer`는 빈 네임스페이스에 전역 요소 선언을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="1a9a9-261">데이터 계약 모델에서 사용되는 네임스페이스는 일반적으로 앞에서 설명한 데이터 계약 네임스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="1a9a9-262">두 가지 serialization 기술에서 모두 사용할 형식을 만드는 경우 이러한 차이에 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="1a9a9-263">IXmlSerializable 스키마 가져오기</span><span class="sxs-lookup"><span data-stu-id="1a9a9-263">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="1a9a9-264">`IXmlSerializable` 형식에서 생성된 스키마를 가져오는 경우 다음과 같은 몇 가지 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
-   <span data-ttu-id="1a9a9-265">생성된 된 스키마에 설명 된 대로 올바른 데이터 계약 스키마 수 [데이터 계약 스키마 참조](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="1a9a9-266">이 경우 스키마를 일반적인 방법으로 가져올 수 있으며 일반 데이터 계약 형식이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
-   <span data-ttu-id="1a9a9-267">생성된 스키마가 올바른 데이터 계약 스키마가 아닐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="1a9a9-268">예를 들어 스키마 공급자 메서드가 데이터 계약 모델에서 지원되지 않는 XML 특성과 관련된 스키마를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="1a9a9-269">이 경우 스키마를 `IXmlSerializable` 형식으로 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="1a9a9-270">이 가져오기 모드에 기본적으로 없지만 쉽게 설정할 수 있습니다-예를 들어는 `/importXmlTypes` 명령줄 스위치를는 [ServiceModel Metadata 유틸리티 도구 (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="1a9a9-271">자세히 설명 되어이 [스키마 클래스 생성를 가져와서](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-271">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="1a9a9-272">형식 인스턴스에 대한 XML로 직접 작업해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="1a9a9-273">보다 넓은 범위의 스키마를 지원하는 다른 serialization 기술을 사용할 수도 있습니다. `XmlSerializer` 사용에 대한 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="1a9a9-274">새 형식을 생성하는 대신 프록시의 기존 `IXmlSerializable` 형식을 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="1a9a9-275">이 경우 스키마를 가져와서 형식 생성 항목에서 설명하는 참조된 형식 기능을 사용하여 다시 사용할 형식을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="1a9a9-276">이를 사용 하 여 해당는 `/reference` 다시 사용할 형식이 포함 된 어셈블리를 지정 하는 svcutil.exe에 전환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="1a9a9-277">데이터 계약에 임의 XML 표현</span><span class="sxs-lookup"><span data-stu-id="1a9a9-277">Representing Arbitrary XML in Data Contracts</span></span>  
 <span data-ttu-id="1a9a9-278">`XmlElement`, `XmlNode` 배열 및 `IXmlSerializable` 형식을 사용하여 임의 XML을 데이터 계약 모델에 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="1a9a9-279">`DataContractSerializer` 및 `NetDataContractSerializer`는 프로세스에 간섭하지 않고 사용 중인 XML 작성기에 이 XML 콘텐츠를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="1a9a9-280">그러나 XML 작성기는 작성하는 XML에 특정 제한을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="1a9a9-281">특히 중요한 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-281">Specifically, here are some important examples:</span></span>  
  
-   <span data-ttu-id="1a9a9-282">XML 작성기는 XML 문서 선언 일반적으로 허용 하지 않습니다 (예를 들어 \<? xml 버전 ='1.0 '? >) 다른 문서를 작성 하는 중입니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="1a9a9-283">전체 XML 문서를 사용하여 `Array` 데이터 멤버의 `XmlNode`로 serialize할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="1a9a9-284">이렇게 하려면 문서 선언을 제거하거나 고유의 인코딩 체계를 사용하여 문서 선언을 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
-   <span data-ttu-id="1a9a9-285">WCF와 함께 제공 된 XML 작성기의 모든 거부 XML 처리 명령 (\<?</span><span class="sxs-lookup"><span data-stu-id="1a9a9-285">All of the XML writers supplied with WCF reject XML processing instructions (\<?</span></span> <span data-ttu-id="1a9a9-286">…</span><span class="sxs-lookup"><span data-stu-id="1a9a9-286">…</span></span> <span data-ttu-id="1a9a9-287">? >)과 문서 형식 정의 (\<!</span><span class="sxs-lookup"><span data-stu-id="1a9a9-287">?>) and document type definitions (\<!</span></span> <span data-ttu-id="1a9a9-288">…</span><span class="sxs-lookup"><span data-stu-id="1a9a9-288">…</span></span> <span data-ttu-id="1a9a9-289">>)를 거부합니다. 이들은 SOAP 메시지에서 허용되지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-289">>), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="1a9a9-290">자체 인코딩 메커니즘을 사용하여 이 제한을 해결할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-290">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="1a9a9-291">결과 XML에 이러한 요소를 포함해야 하는 경우 이를 지원하는 XML 작성기를 사용하는 사용자 지정 인코더를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-291">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
-   <span data-ttu-id="1a9a9-292">`WriteXml`을 구현할 때 XML 작성기에서 <xref:System.Xml.XmlWriter.WriteRaw%2A> 메서드를 호출하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-292">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> <span data-ttu-id="1a9a9-293">다양 한 XML 인코딩 (바이너리 포함)을 사용 하 여 WCF은 사용 하도록 매우 어렵거나 `WriteRaw` 결과 임의의 인코딩으로 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-293">WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
-   <span data-ttu-id="1a9a9-294">구현 하는 경우 `WriteXml`, 사용 하지 않도록는 <xref:System.Xml.XmlWriter.WriteEntityRef%2A> 및 <xref:System.Xml.XmlWriter.WriteNmToken%2A> WCF와 함께 제공 된 XML 작성기에서 지원 하지 않는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-294">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF.</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="1a9a9-295">DataSet, 형식화된 DataSet 및 DataTable 사용</span><span class="sxs-lookup"><span data-stu-id="1a9a9-295">Using DataSet, Typed DataSet and DataTable</span></span>  
 <span data-ttu-id="1a9a9-296">이러한 형식 사용은 데이터 계약 모델에서 완전히 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-296">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="1a9a9-297">이 형식을 사용할 때는 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-297">When using these types, consider the following points:</span></span>  
  
-   <span data-ttu-id="1a9a9-298">이러한 형식에 대 한 스키마 (특히 <xref:System.Data.DataSet> 및 해당 형식화 된 파생 클래스) 일부 비 WCF 플랫폼과 상호 운용 되지 않을 또는 이러한 플랫폼과 함께 사용할 때 유용성이 저하 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-298">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="1a9a9-299">또한 `DataSet` 형식을 사용하면 성능에 영향을 줄 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-299">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="1a9a9-300">마지막으로 이후에 응용 프로그램의 버전 관리가 더 어려워질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-300">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="1a9a9-301">계약에 `DataSet` 형식 대신 명시적으로 정의된 데이터 계약 형식을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-301">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
-   <span data-ttu-id="1a9a9-302">`DataSet` 또는 `DataTable` 스키마를 가져올 때는 이러한 형식을 참조하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-302">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="1a9a9-303">Svcutil.exe 명령줄 도구로이 위해서는 System.Data.dll 어셈블리 이름을 전달 하 여는 `/reference` 전환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-303">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="1a9a9-304">형식화된 데이터 집합 스키마를 가져오는 경우 형식화된 데이터 집합의 형식을 참조해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-304">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="1a9a9-305">Svcutil.exe를 전달 하는 형식화 된 데이터 집합의 어셈블리의 위치는 `/reference` 전환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-305">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> <span data-ttu-id="1a9a9-306">형식 참조 하는 방법에 대 한 자세한 내용은 참조는 [스키마 클래스 생성를 가져와서](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-306">For more information about referencing types, see the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="1a9a9-307">데이터 계약 모델에서 형식화된 데이터 집합에 대한 지원은 제한되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-307">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="1a9a9-308">형식화된 데이터 집합은 serialize 및 deserialize할 수 있으며 스키마를 내보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-308">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="1a9a9-309">하지만 데이터 계약 스키마 가져오기에서는 스키마로부터 형식화된 데이터 집합 형식을 새로 생성할 수 없고 기존 형식을 다시 사용할 수만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-309">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="1a9a9-310">Svcutil.exe에 `/r` 스위치를 사용하면 형식화된 기존 데이터 집합을 가리킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-310">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="1a9a9-311">형식화된 데이터 집합을 사용하는 서비스에서 `/r` 스위치 없이 Svcutil.exe를 사용하려 하면 대체 serializer(XmlSerializer)가 자동으로 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-311">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="1a9a9-312">DataContractSerializer를 사용해야 하며 스키마에서 데이터 집합을 생성해야 하는 경우에는 다음 절차를 사용할 수 있습니다. 서비스에서 `/d` 스위치와 함께 Xsd.exe 도구를 사용하여 형식화된 데이터 집합 형식을 생성한 다음 Svcutil.exe에서 `/r` 스위치를 사용하여 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="1a9a9-312">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1a9a9-313">참고 항목</span><span class="sxs-lookup"><span data-stu-id="1a9a9-313">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Xml.Serialization.IXmlSerializable>  
 [<span data-ttu-id="1a9a9-314">데이터 계약 사용</span><span class="sxs-lookup"><span data-stu-id="1a9a9-314">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)  
 [<span data-ttu-id="1a9a9-315">데이터 계약 직렬 변환기에서 지원하는 형식</span><span class="sxs-lookup"><span data-stu-id="1a9a9-315">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)

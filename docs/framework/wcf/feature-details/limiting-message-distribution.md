---
title: 메시지 분포 제한
ms.date: 03/30/2017
ms.assetid: 8b5ec4b8-1ce9-45ef-bb90-2c840456bcc1
ms.openlocfilehash: 006cfaffe02752bb91e9f7d780477aecbaeb9c9e
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33495817"
---
# <a name="limiting-message-distribution"></a><span data-ttu-id="567c3-102">메시지 분포 제한</span><span class="sxs-lookup"><span data-stu-id="567c3-102">Limiting Message Distribution</span></span>
<span data-ttu-id="567c3-103">피어 채널은 디자인상 브로드캐스트 메시입니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-103">Peer Channel is by design a broadcast mesh.</span></span> <span data-ttu-id="567c3-104">피어 채널의 기본 플러딩 모델에는 메시의 임의 멤버가 보낸 각 메시지를 해당 메시의 다른 모든 멤버에 배포하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-104">Its basic flooding model involves distributing each message sent by any member of a mesh to all other members of that mesh.</span></span> <span data-ttu-id="567c3-105">이는 멤버가 생성한 모든 메시지가 관련성을 지니며 다른 모든 멤버에 유용한 경우(예: 채트 방) 이상적입니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-105">This is ideal in situations where every message generated by a member is relevant and useful to all other members (for example, a chat room).</span></span> <span data-ttu-id="567c3-106">그러나 많은 응용 프로그램에서 메시지 배포를 제한해야 하는 경우가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-106">However, many applications have an occasional need for limiting message distribution.</span></span> <span data-ttu-id="567c3-107">예를 들어 새 멤버가 메시에 참가하여 메시를 통해 전송된 마지막 메시지를 검색하려고 할 경우 이 요청을 메시의 모든 멤버에 플러딩하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-107">For example, if a new member joins a mesh and wants to retrieve the last message sent through the mesh, this request does not need to be flooded to every member of the mesh.</span></span> <span data-ttu-id="567c3-108">이러한 요청을 인접한 환경으로 제한하거나 로컬로 생성된 메시지를 필터링하여 제외할 수 있습니다. 메시지를 메시의 개별 노드로 보낼 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-108">The request could be limited to near neighbors, or locally generated messages can be filtered out. Messages can also be sent to an individual node on the mesh.</span></span> <span data-ttu-id="567c3-109">이 항목에서는 홉 수, 메시지 전파 필터, 로컬 필터 또는 직접 연결을 사용하여 전체 메시에서 메시지가 전달되는 방법에 대해 설명하고 접근 방식을 선택하기 위한 일반적인 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-109">This topic discusses using Hop Count, a Message Propagation Filter, a local filter, or a direct connection to control how messages are forwarded throughout the mesh, and provides general guidelines for choosing an approach.</span></span>  
  
## <a name="hop-counts"></a><span data-ttu-id="567c3-110">홉 수</span><span class="sxs-lookup"><span data-stu-id="567c3-110">Hop Counts</span></span>  
 <span data-ttu-id="567c3-111">`PeerHopCount`의 개념은 IP 프로토콜에 사용되는 TTL(Time-To-Live)과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-111">The concept of `PeerHopCount` is similar to TTL (Time-To-Live) used in IP protocol.</span></span> <span data-ttu-id="567c3-112">`PeerHopCount`의 값은 메시지 인스턴스에 연결되며 메시지가 삭제되기 전에 전달되어야 하는 횟수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-112">The value of `PeerHopCount` is tied to a message instance, and it specifies how many times a message should be forwarded before being dropped.</span></span> <span data-ttu-id="567c3-113">피어 채널 클라이언트에 메시지가 수신될 때마다 이 클라이언트에서는 `PeerHopCount`가 지정되어 있는지 여부를 확인하기 위해 해당 메시지를 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-113">Each time a message is received by a Peer Channel client, the client examines the message to see if `PeerHopCount` is specified.</span></span> <span data-ttu-id="567c3-114">해당 값이 지정되어 있으면 메시지를 인접한 노드로 전달하기 전에 클라이언트에서 홉 수 값을 1만큼 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-114">If it is specified, then the client decrements the hop count value by one before forwarding the message to neighboring nodes.</span></span> <span data-ttu-id="567c3-115">클라이언트에 홉 수 값이 0인 메시지가 수신되면 클라이언트에서 해당 메시지를 처리하지만 인접한 환경으로 전달하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-115">When a client receives a message with a hop count value of zero, the client processes the message, but does not forward the message to neighbors.</span></span>  
  
 <span data-ttu-id="567c3-116">메시지 클래스 구현 시 적용 가능한 속성이나 필드에 `PeerHopCount`를 특성으로 추가하여 메시지에 홉 수를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-116">Hop count may be added to a message by adding `PeerHopCount` as an attribute to the applicable property or field in the implementation of the message class.</span></span> <span data-ttu-id="567c3-117">메시지를 메시에 보내기 전에 이 홉 수를 특정 값으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-117">You can set this to a specific value before sending the message to the mesh.</span></span> <span data-ttu-id="567c3-118">이런 방식으로 홉 수를 사용하여 필요한 경우 전체 메시에서 메시지 배포를 제한하면 불필요한 메시지 복제를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-118">In this manner, you can use hop count to limit distribution of messages throughout the mesh when necessary, potentially avoiding unnecessary message duplication.</span></span> <span data-ttu-id="567c3-119">이 방법은 메시에 중복 데이터가 아주 많은 경우 또는 바로 인접한 환경이나 홉 수가 많이 차이 나지 않는 환경으로 메시지를 보내는 경우 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-119">This is useful in cases where the mesh contains a high amount of redundant data, or for sending a message to immediate neighbors, or neighbors within a few hops.</span></span>  
  
-   <span data-ttu-id="567c3-120">코드 조각 및 관련된 정보에 대 한 참조는 [피어 채널 블로그](http://go.microsoft.com/fwlink/?LinkID=114531) (http://go.microsoft.com/fwlink/?LinkID=114531)합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-120">For code snippets and related information, see the [Peer Channel blog](http://go.microsoft.com/fwlink/?LinkID=114531) (http://go.microsoft.com/fwlink/?LinkID=114531).</span></span>  
  
## <a name="message-propagation-filter"></a><span data-ttu-id="567c3-121">메시지 전파 필터</span><span class="sxs-lookup"><span data-stu-id="567c3-121">Message Propagation Filter</span></span>  
 <span data-ttu-id="567c3-122">`MessagePropagationFilter`는 특히 메시지 내용 또는 다른 특정 시나리오에 따라 전파 여부가 결정되는 경우 메시지 플러딩을 사용자 지정 방식으로 제어하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-122">`MessagePropagationFilter` can be used for customized control of message flooding, especially when the content of the message or other specific scenarios determine propagation.</span></span> <span data-ttu-id="567c3-123">이 필터를 사용하면 노드를 통해 전달되는 모든 메시지에 대해 전파 여부를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-123">The filter makes propagation decisions for every message that passes through the node.</span></span> <span data-ttu-id="567c3-124">이는 메시의 기타 위치에서 발생하여 노드에 수신된 메시지뿐만 아니라 응용 프로그램에서 생성된 메시지에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-124">This is true for messages that originated elsewhere in the mesh that your node has received as well as messages created by your application.</span></span> <span data-ttu-id="567c3-125">이 필터는 메시지와 해당 메시지의 발생 위치에 모두 액세스할 수 있으므로 사용 가능한 전체 정보에 따라 메시지 전달 또는 삭제 여부를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-125">The filter has access to both the message and its origination, so decisions about forwarding or dropping the message can be based on the full information available.</span></span>  
  
 <span data-ttu-id="567c3-126"><xref:System.ServiceModel.PeerMessagePropagationFilter>는 단일 함수 <xref:System.ServiceModel.PeerMessagePropagationFilter.ShouldMessagePropagate%2A>가 있는 기본 추상 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-126"><xref:System.ServiceModel.PeerMessagePropagationFilter> is a base abstract class with a single function, <xref:System.ServiceModel.PeerMessagePropagationFilter.ShouldMessagePropagate%2A>.</span></span> <span data-ttu-id="567c3-127">메서드 호출의 첫 번째 인수는 메시지의 전체 복사본을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-127">The first argument of the method call passes in a full copy of the message.</span></span> <span data-ttu-id="567c3-128">메시지를 변경해도 실제 메시지는 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-128">Any changes made to the message do not affect the actual message.</span></span> <span data-ttu-id="567c3-129">메서드 호출의 마지막 인수는 메시지의 발생 위치(`PeerMessageOrigination.Local` 또는 `PeerMessageOrigination.Remote`)를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-129">The last argument of the method call identifies the origin of the message (`PeerMessageOrigination.Local` or `PeerMessageOrigination.Remote`).</span></span> <span data-ttu-id="567c3-130">이 메서드를 구체적으로 구현하면 메시지를 로컬 응용 프로그램으로 전달하거나(<xref:System.ServiceModel.PeerMessagePropagation>), 원격 클라이언트로 전달하거나(`Local`), 두 위치 모두로 전달하거나(`Remote`), 두 위치 모두로 전달하지 않음(`LocalAndRemote`)을 나타내는 상수를 `None` 열거형에서 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-130">Concrete implementations of this method must return a constant from the <xref:System.ServiceModel.PeerMessagePropagation> enumeration indicating that the message is to be forwarded to the local application (`Local`), forwarded to remote clients (`Remote`), both (`LocalAndRemote`), or neither (`None`).</span></span> <span data-ttu-id="567c3-131">해당 `PeerNode` 개체에 액세스하고 `PeerNode.MessagePropagationFilter` 속성에 파생된 전파 필터 클래스의 인스턴스를 지정하여 이 필터를 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-131">This filter can be applied by accessing the corresponding `PeerNode` object and specifying an instance of the derived propagation filter class in the `PeerNode.MessagePropagationFilter` property.</span></span> <span data-ttu-id="567c3-132">피어 채널을 열기 전에 전파 필터가 연결되어 있는지 확인하십시오.</span><span class="sxs-lookup"><span data-stu-id="567c3-132">Ensure that the propagation filter is attached before opening the Peer Channel.</span></span>  
  
-   <span data-ttu-id="567c3-133">코드 조각 및 관련된 정보에 대 한 참조는 [피어 채널 블로그](http://go.microsoft.com/fwlink/?LinkID=114532) (http://go.microsoft.com/fwlink/?LinkID=114532)합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-133">For code snippets and related information, see the [Peer Channel blog](http://go.microsoft.com/fwlink/?LinkID=114532) (http://go.microsoft.com/fwlink/?LinkID=114532).</span></span>  
  
## <a name="contacting-an-individual-node-in-the-mesh"></a><span data-ttu-id="567c3-134">메시의 개별 노드에 연결</span><span class="sxs-lookup"><span data-stu-id="567c3-134">Contacting an Individual Node in the Mesh</span></span>  
 <span data-ttu-id="567c3-135">로컬 필터를 설정하거나 직접 연결을 설정하여 메시의 개별 노드에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-135">An individual node in a mesh can be contacted by setting up a local filter, or by setting up a direct connection.</span></span>  
  
 <span data-ttu-id="567c3-136">메시의 각 노드에 개별 ID가 있는 경우 메시지 구현 시 대상 ID를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-136">If the nodes in a mesh each have an individual ID, a destination ID can be specified in the implementation of your message.</span></span> <span data-ttu-id="567c3-137">메시지 계약에 함수를 작성하여 로컬 필터를 설정할 수 있습니다. 이 필터는 노드 ID가 사용자 지정 대상 ID와 일치하는 경우에만 현재 노드에 메시지를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-137">A local filter can be set up by writing a function in your message contract that will only display the message to the current node if its ID matches the destination ID you specified.</span></span> <span data-ttu-id="567c3-138">메시가 메시지를 전송하므로 새 연결을 설정할 때 발생하는 오버헤드를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-138">The mesh transports the message, so the overhead of setting up a new connection does not have to be incurred.</span></span> <span data-ttu-id="567c3-139">그러나 메시지가 전체 메시에서 여러 번 전송되므로 효율성은 저하됩니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-139">However, there is a loss of efficiency since the message is sent many times throughout the mesh.</span></span> <span data-ttu-id="567c3-140">이 방법은 메시지가 너무 크거나 너무 자주 전송되지 않는 한 메시의 개별 멤버에 메시지를 보내는 데 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-140">This works well for sending messages to individual members of a mesh as long as the messages are neither too big nor too frequent.</span></span>  
  
 <span data-ttu-id="567c3-141">오래 지속되는 고대역폭 연결의 경우 직접 연결을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-141">For long-lasting, high-bandwidth connections, direct connections are preferable.</span></span> <span data-ttu-id="567c3-142">메시를 통해 연결 정보를 보낸 다음 원하는 직접 연결을 설정하여 메시지를 주고 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-142">You can send connection information over the mesh, and then set up a direct connection of your choosing to send/receive messages.</span></span>  
  
## <a name="choosing-an-approach-for-limiting-message-distribution"></a><span data-ttu-id="567c3-143">메시지 배포 제한 방식 선택</span><span class="sxs-lookup"><span data-stu-id="567c3-143">Choosing an Approach for Limiting Message Distribution</span></span>  
 <span data-ttu-id="567c3-144">메시지 배포를 제한해야 하는 시나리오가 발생할 경우 다음 사항을 고려해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="567c3-144">When you discover a scenario in which you need to limit message distribution, ask yourself the following questions:</span></span>  
  
-   <span data-ttu-id="567c3-145">**가** 메시지를 수신 해야?</span><span class="sxs-lookup"><span data-stu-id="567c3-145">**Who** needs to receive the message?</span></span> <span data-ttu-id="567c3-146">하나의 노드,</span><span class="sxs-lookup"><span data-stu-id="567c3-146">Just one neighbor node?</span></span> <span data-ttu-id="567c3-147">메시의 기타 위치에 있는 노드,</span><span class="sxs-lookup"><span data-stu-id="567c3-147">A node somewhere else in the mesh?</span></span> <span data-ttu-id="567c3-148">메시 절반)</span><span class="sxs-lookup"><span data-stu-id="567c3-148">Half the mesh?</span></span>  
  
-   <span data-ttu-id="567c3-149">**얼마나 자주** 이 메시지를 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-149">**How often** will this message be sent?</span></span>  
  
-   <span data-ttu-id="567c3-150">어떤 종류의 **대역폭** 이 메시지에 사용할?</span><span class="sxs-lookup"><span data-stu-id="567c3-150">What kind of **bandwidth** will this message use?</span></span>  
  
 <span data-ttu-id="567c3-151">이러한 사항에 대해 생각해 보면 홉 수, 메시지 전파 필터, 로컬 필터, 직접 연결 중 어느 것을 사용할지 결정하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-151">The answers to these questions can help you determine whether to use Hop Count, a Message Propagation Filter, a local filter, or a direct connection.</span></span> <span data-ttu-id="567c3-152">다음과 같은 일반적인 지침을 고려해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="567c3-152">Consider the following general guidelines:</span></span>  
  
-   <span data-ttu-id="567c3-153">**가**</span><span class="sxs-lookup"><span data-stu-id="567c3-153">**Who**</span></span>  
  
    -   <span data-ttu-id="567c3-154">*개별 노드*: 로컬 필터 또는 직접 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-154">*Individual node*:  Local filter or direct connection.</span></span>  
  
    -   <span data-ttu-id="567c3-155">*인접 한*: PeerHopCount 합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-155">*Neighbors within a certain vicinity*:  PeerHopCount.</span></span>  
  
    -   <span data-ttu-id="567c3-156">*메시의 복잡 한 하위 집합*: MessagePropagationFilter 합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-156">*Complex subset of the mesh*:  MessagePropagationFilter.</span></span>  
  
-   <span data-ttu-id="567c3-157">**얼마나 자주**</span><span class="sxs-lookup"><span data-stu-id="567c3-157">**How often**</span></span>  
  
    -   <span data-ttu-id="567c3-158">*매우 짧은*: 직접 연결, PeerHopCount, MessagePropagationFilter 합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-158">*Very frequent*:  Direct connection, PeerHopCount, MessagePropagationFilter.</span></span>  
  
    -   <span data-ttu-id="567c3-159">*필요에 따른*: 로컬 필터입니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-159">*Occasional*:  Local filter.</span></span>  
  
-   <span data-ttu-id="567c3-160">**대역폭 사용**</span><span class="sxs-lookup"><span data-stu-id="567c3-160">**Bandwidth use**</span></span>  
  
    -   <span data-ttu-id="567c3-161">*높은*: 직접 연결, MessagePropagationFilter 또는 로컬 필터를 사용 하는 작은 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-161">*High*:  Direct connection, less advisable to use MessagePropagationFilter or local filter.</span></span>  
  
    -   <span data-ttu-id="567c3-162">*낮은*: 필요 하지 않을 수 있는 경우 직접 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="567c3-162">*Low*:  Any, direct connection probably not needed.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="567c3-163">참고 항목</span><span class="sxs-lookup"><span data-stu-id="567c3-163">See Also</span></span>  
 [<span data-ttu-id="567c3-164">피어 채널 응용 프로그램 빌드</span><span class="sxs-lookup"><span data-stu-id="567c3-164">Building a Peer Channel Application</span></span>](../../../../docs/framework/wcf/feature-details/building-a-peer-channel-application.md)

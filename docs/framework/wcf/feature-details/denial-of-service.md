---
title: "서비스 거부"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: denial of service [WCF]
ms.assetid: dfb150f3-d598-4697-a5e6-6779e4f9b600
caps.latest.revision: "12"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 5d5f67790abad5dcf6311de1817b4ea093e703d9
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/22/2017
---
# <a name="denial-of-service"></a><span data-ttu-id="3a7d3-102">서비스 거부</span><span class="sxs-lookup"><span data-stu-id="3a7d3-102">Denial of Service</span></span>
<span data-ttu-id="3a7d3-103">서비스 거부는 시스템을 가득 채워 메시지를 처리할 수 없거나 메시지가 매우 느리게 처리되는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-103">Denial of service occurs when a system is overwhelmed in such a way that messages cannot be processed, or they are processed extremely slowly.</span></span>  
  
## <a name="excess-memory-consumption"></a><span data-ttu-id="3a7d3-104">과도한 메모리 사용</span><span class="sxs-lookup"><span data-stu-id="3a7d3-104">Excess Memory Consumption</span></span>  
 <span data-ttu-id="3a7d3-105">고유 로컬 이름, 네임스페이스 또는 접두사를 많이 포함하는 XML 문서를 읽을 때 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-105">A problem can occur when reading an XML document with a large number of unique local names, namespaces, or prefixes.</span></span> <span data-ttu-id="3a7d3-106"><xref:System.Xml.XmlReader>에서 파생되는 클래스를 사용할 경우 각 항목에 대해 <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A> 또는 <xref:System.Xml.XmlReader.NamespaceURI%2A> 속성을 호출하면 반환된 문자열이 <xref:System.Xml.NameTable>에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-106">If you are using a class that derives from <xref:System.Xml.XmlReader>, and you call either the <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A> or <xref:System.Xml.XmlReader.NamespaceURI%2A> property for each item, the returned string is added to a <xref:System.Xml.NameTable>.</span></span> <span data-ttu-id="3a7d3-107"><xref:System.Xml.NameTable>에 포함된 컬렉션은 크기가 줄지 않아 문자열 핸들의 가상 "메모리 누수"를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-107">The collection held by the <xref:System.Xml.NameTable> never decreases in size, creating a virtual "memory leak" of the string handles.</span></span>  
  
 <span data-ttu-id="3a7d3-108">완화 방안은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-108">Mitigations include:</span></span>  
  
-   <span data-ttu-id="3a7d3-109"><xref:System.Xml.NameTable> 클래스에서 파생되고 최대 크기 할당량을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-109">Derive from the <xref:System.Xml.NameTable> class and enforce a maximum size quota.</span></span> <span data-ttu-id="3a7d3-110">가득 찼을 때 <xref:System.Xml.NameTable> 사용을 금지하거나 <xref:System.Xml.NameTable>을 전환할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-110">(You cannot prevent the use of a <xref:System.Xml.NameTable> or switch the <xref:System.Xml.NameTable> when it is full.)</span></span>  
  
-   <span data-ttu-id="3a7d3-111">가능한 경우 위에서 설명한 속성 대신 <xref:System.Xml.XmlReader.MoveToAttribute%2A> 메서드와 함께 <xref:System.Xml.XmlReader.IsStartElement%2A> 메서드를 사용합니다. 이러한 메서드는 문자열을 반환하지 않으므로 <xref:System.Xml.NameTable> 컬렉션이 과도하게 채워지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-111">Avoid using the properties mentioned and instead use the <xref:System.Xml.XmlReader.MoveToAttribute%2A> method with the <xref:System.Xml.XmlReader.IsStartElement%2A> method where possible; those methods do not return strings and thus avoid the problem of overfilling the <xref:System.Xml.NameTable> collection.</span></span>  
  
## <a name="malicious-client-sends-excessive-license-requests-to-service"></a><span data-ttu-id="3a7d3-112">악의적인 클라이언트가 과도한 라이선스 요청을 서비스로 전송</span><span class="sxs-lookup"><span data-stu-id="3a7d3-112">Malicious Client Sends Excessive License Requests to Service</span></span>  
 <span data-ttu-id="3a7d3-113">악의적인 클라이언트가 과도한 라이선스 요청으로 서비스를 채우면 서버가 메모리를 지나치게 많이 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-113">If a malicious client bombards a service with excessive license requests, it can cause the server to use excessive memory.</span></span>  
  
 <span data-ttu-id="3a7d3-114">완화 방법: <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> 클래스의 다음 속성을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-114">Mitigation: Use the following properties of the <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> class:</span></span>  
  
-   <span data-ttu-id="3a7d3-115"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxCachedCookies%2A>: `SecurityContextToken` 또는 `SPNego` 협상 후에 서버에서 캐시하는 시간이 제한된 `SSL`의 최대 개수를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-115"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxCachedCookies%2A>: controls the maximum number of time-bounded `SecurityContextToken`s that the server caches after `SPNego` or `SSL` negotiation.</span></span>  
  
-   <span data-ttu-id="3a7d3-116"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.IssuedCookieLifetime%2A>: `SecurityContextTokens` 또는 `SPNego` 협상 후에 서버에서 발급하는 `SSL`의 수명을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-116"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.IssuedCookieLifetime%2A>: controls the lifetime of the `SecurityContextTokens` that the server issues following `SPNego` or `SSL` negotiation.</span></span> <span data-ttu-id="3a7d3-117">서버는 이 기간 동안 `SecurityContextToken`을 캐시합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-117">The server caches the `SecurityContextToken`s for this period of time.</span></span>  
  
-   <span data-ttu-id="3a7d3-118"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxPendingSessions%2A>: 서버에서 설정되었지만 응용 프로그램 메시지가 처리되지 않은 보안 대화의 최대 개수를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-118"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxPendingSessions%2A>: controls the maximum number of secure conversations that are established at the server but for which no application messages have been processed.</span></span> <span data-ttu-id="3a7d3-119">이 할당량은 클라이언트가 서비스에서 보안 대화를 설정할 수 없도록 하여 서비스가 클라이언트별 상태를 유지 관리하게 하지만 사용하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-119">This quota prevents clients from establishing secure conversations at the service, thereby causing the service to maintain state per client, but never using them.</span></span>  
  
-   <span data-ttu-id="3a7d3-120"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.InactivityTimeout%2A>: 서비스가 대화를 위해 클라이언트로부터 응용 프로그램 메시지를 받지 않고 보안 대화를 활성 상태로 유지하는 최대 시간을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-120"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.InactivityTimeout%2A>:  controls the maximum time the service keeps a secure conversation alive without receiving an application message from the client for the conversation.</span></span> <span data-ttu-id="3a7d3-121">이 할당량은 클라이언트가 서비스에서 보안 대화를 설정할 수 없도록 하여 서비스가 클라이언트별 상태를 유지 관리하게 하지만 사용하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-121">This quota prevents clients from establishing secure conversations at the service, thereby causing the service to maintain state per client, but never using them.</span></span>  
  
## <a name="wsdualhttpbinding-or-dual-custom-bindings-require-client-authentication"></a><span data-ttu-id="3a7d3-122">WSDualHttpBinding 또는 이중 사용자 지정 바인딩에 클라이언트 인증이 필요함</span><span class="sxs-lookup"><span data-stu-id="3a7d3-122">WSDualHttpBinding or Dual Custom Bindings Require Client Authentication</span></span>  
 <span data-ttu-id="3a7d3-123">기본적으로 <xref:System.ServiceModel.WSDualHttpBinding>은 보안을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-123">By default, the <xref:System.ServiceModel.WSDualHttpBinding> has security enabled.</span></span> <span data-ttu-id="3a7d3-124">그러나 <xref:System.ServiceModel.MessageSecurityOverHttp.ClientCredentialType%2A> 속성을 <xref:System.ServiceModel.MessageCredentialType.None>으로 설정하여 클라이언트 인증을 비활성화한 경우 악의적인 사용자가 제 3의 서비스에 대해 서비스 거부 공격을 발생시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-124">It is possible, however, that if the client authentication is disabled by setting the <xref:System.ServiceModel.MessageSecurityOverHttp.ClientCredentialType%2A> property to <xref:System.ServiceModel.MessageCredentialType.None>, a malicious user can cause a denial of service attack on a third service.</span></span> <span data-ttu-id="3a7d3-125">이는 악의적인 클라이언트가 메시지 스트림을 제 3의 서비스로 보내도록 서비스에 지시할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-125">This can occur because a malicious client can direct the service to send a stream of messages to a third service.</span></span>  
  
 <span data-ttu-id="3a7d3-126">이 문제를 완화하려면 속성을 `None`으로 설정하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-126">To mitigate this, do not set the property to `None`.</span></span> <span data-ttu-id="3a7d3-127">또한 이중 메시지 패턴이 있는 사용자 지정 바인딩을 만들 때 이러한 가능성에 주의합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-127">Also be aware of this possibility when creating a custom binding that has a dual message pattern.</span></span>  
  
## <a name="auditing-event-log-can-be-filled"></a><span data-ttu-id="3a7d3-128">감사 이벤트 로그가 채워질 수 있음</span><span class="sxs-lookup"><span data-stu-id="3a7d3-128">Auditing Event Log Can Be Filled</span></span>  
 <span data-ttu-id="3a7d3-129">악의적인 사용자가 감사가 설정된 사실을 알고 있다면 잘못된 메시지를 보내 감사 항목이 기록되게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-129">If a malicious user understands that auditing is enabled, that attacker can send invalid messages that cause audit entries to be written.</span></span> <span data-ttu-id="3a7d3-130">이런 식으로 감사 로그가 채워지면 감사 시스템이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-130">If the audit log is filled in this manner, the auditing system fails.</span></span>  
  
 <span data-ttu-id="3a7d3-131">이 문제를 완화하려면 <xref:System.ServiceModel.Description.ServiceSecurityAuditBehavior.SuppressAuditFailure%2A> 속성을 `true`로 설정하고 이벤트 뷰어의 속성을 사용하여 감사 동작을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-131">To mitigate this, set the <xref:System.ServiceModel.Description.ServiceSecurityAuditBehavior.SuppressAuditFailure%2A> property to `true` and use the properties of the Event Viewer to control the auditing behavior.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="3a7d3-132">참조를 보고 하 여 이벤트 로그 관리 이벤트 뷰어를 사용 하 여 [이벤트 뷰어](http://go.microsoft.com/fwlink/?LinkId=186123)합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-132"> using the Event Viewer to view and manage event logs, see [Event Viewer](http://go.microsoft.com/fwlink/?LinkId=186123).</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="3a7d3-133">[감사](../../../../docs/framework/wcf/feature-details/auditing-security-events.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-133"> [Auditing](../../../../docs/framework/wcf/feature-details/auditing-security-events.md).</span></span>  
  
## <a name="invalid-implementations-of-iauthorizationpolicy-can-cause-service-hangs"></a><span data-ttu-id="3a7d3-134">IAuthorizationPolicy의 잘못된 구현으로 인해 서비스가 중단될 수 있음</span><span class="sxs-lookup"><span data-stu-id="3a7d3-134">Invalid Implementations of IAuthorizationPolicy Can Cause Service Hangs</span></span>  
 <span data-ttu-id="3a7d3-135"><xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%2A> 인터페이스의 잘못된 구현에서 <xref:System.IdentityModel.Policy.IAuthorizationPolicy> 메서드를 호출하면 서비스가 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-135">Calling the <xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%2A> method on a faulty implementation of the <xref:System.IdentityModel.Policy.IAuthorizationPolicy> interface can cause the service to hang.</span></span>  
  
 <span data-ttu-id="3a7d3-136">완화 방법: 신뢰할 수 있는 코드만 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-136">Mitigation: Use only trusted code.</span></span> <span data-ttu-id="3a7d3-137">즉, 직접 작성하고 테스트한 코드나 신뢰할 수 있는 공급자가 제공한 코드만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-137">That is, use only code that you have written and tested, or that comes from a trusted provider.</span></span> <span data-ttu-id="3a7d3-138">신뢰할 수 없는 <xref:System.IdentityModel.Policy.IAuthorizationPolicy> 확장이 적절한 고려 없이 코드에 연결할 수 없도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-138">Do not allow untrusted extensions of <xref:System.IdentityModel.Policy.IAuthorizationPolicy> to be plugged into your code without due consideration.</span></span> <span data-ttu-id="3a7d3-139">이 내용은 서비스 구현에 사용되는 모든 확장에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-139">This applies to all extensions used in a service implementation.</span></span> [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="3a7d3-140">는 확장성 지점을 사용하여 연결된 응용 프로그램 코드와 외부 코드를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-140"> does not make any distinction between application code and foreign code that is plugged in using extensibility points.</span></span>  
  
## <a name="kerberos-maximum-token-size-may-need-resizing"></a><span data-ttu-id="3a7d3-141">Kerberos 최대 토큰 크기를 조정해야 할 수 있음</span><span class="sxs-lookup"><span data-stu-id="3a7d3-141">Kerberos Maximum Token Size May Need Resizing</span></span>  
 <span data-ttu-id="3a7d3-142">클라이언트는 다수의 그룹(실제 개수는 그룹에 따라 다를 수 있지만 대략 900개)에 속해 있지만 메시지 헤더의 블록이 64KB를 초과할 때 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-142">If a client belongs to a large number of groups (approximately 900, although the actual number varies depending on the groups), a problem may occur when a message header's block exceeds 64 kilobytes.</span></span> <span data-ttu-id="3a7d3-143">이 경우 Microsoft 지원 문서에 설명 된 대로 최대 Kerberos 토큰 크기를 늘릴 수 있습니다 "[IIS에 연결할 버퍼가 부족 하 여 Internet Explorer Kerberos 인증이 작동 하지 않는다](http://go.microsoft.com/fwlink/?LinkId=89176)."</span><span class="sxs-lookup"><span data-stu-id="3a7d3-143">In that case, you can increase the maximum Kerberos token size, as described in the Microsoft Support article "[Internet Explorer Kerberos authentication does not work because of an insufficient buffer connecting to IIS](http://go.microsoft.com/fwlink/?LinkId=89176)."</span></span> <span data-ttu-id="3a7d3-144">보다 큰 Kerberos 토큰을 수용하기 위해 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 메시지 크기를 늘려야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-144">You may also need to increase the maximum [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message size to accommodate the larger Kerberos token.</span></span>  
  
## <a name="autoenrollment-results-in-multiple-certificates-with-same-subject-name-for-machine"></a><span data-ttu-id="3a7d3-145">자동 등록으로 인해 한 컴퓨터에 대해 동일한 주체 이름을 가진 여러 인증서가 발생함</span><span class="sxs-lookup"><span data-stu-id="3a7d3-145">Autoenrollment Results in Multiple Certificates with Same Subject Name for Machine</span></span>  
 <span data-ttu-id="3a7d3-146">*자동 등록* 는의 기능 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 사용자 및 컴퓨터 인증서에 대 한 자동으로 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-146">*Autoenrollment* is the capability of [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] to automatically enroll users and computers for certificates.</span></span> <span data-ttu-id="3a7d3-147">이 기능을 사용하는 도메인에 컴퓨터가 있으면 새 컴퓨터가 네트워크에 참가할 때마다 용도가 클라이언트 인증인 X.509 인증서가 자동으로 만들어지고 로컬 컴퓨터의 개인 인증서 저장소에 삽입됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-147">When a machine is on a domain with the feature enabled, an X.509 certificate with the intended purpose of client authentication is automatically created and inserted into the local computer's Personal certificates store whenever a new machine is joined to the network.</span></span> <span data-ttu-id="3a7d3-148">그러나 자동 등록은 캐시에 만드는 모든 인증서에 대해 동일한 주체 이름을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-148">However, autoenrollment uses the same subject name for all certificates it creates in the cache.</span></span>  
  
 <span data-ttu-id="3a7d3-149">이로 인해 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 서비스가 자동 등록을 사용하는 도메인에서 열리지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-149">The impact is that [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services may fail to open on domains with autoenrollment.</span></span> <span data-ttu-id="3a7d3-150">이 문제는 컴퓨터의 정규화된 DNS(Domain Name System) 이름을 포함하는 여러 인증서가 있어서 기본 서비스 X.509 자격 증명 검색 조건이 모호할 수 있기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-150">This occurs because the default service X.509 credential search criteria might be ambiguous because multiple certificates with the machine's fully qualified Domain Name System (DNS) name exist.</span></span> <span data-ttu-id="3a7d3-151">한 인증서는 자동 등록에서 시작되고 다른 인증서는 자체 서명된 인증서일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-151">One certificate originates from autoenrollment; the other might be a self-issued certificate.</span></span>  
  
 <span data-ttu-id="3a7d3-152">이 완화 하려면 보다 정확 하 게 검색 조건에 사용 하 여 사용할 인증서를 정확히 참조는 [ \<serviceCredentials >](../../../../docs/framework/configure-apps/file-schema/wcf/servicecredentials.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-152">To mitigate this, reference the exact certificate to use by using a more precise search criterion on the [\<serviceCredentials>](../../../../docs/framework/configure-apps/file-schema/wcf/servicecredentials.md).</span></span> <span data-ttu-id="3a7d3-153">예를 들어 <xref:System.Security.Cryptography.X509Certificates.X509FindType.FindByThumbprint> 옵션을 사용하고 고유한 지문(해시)으로 인증서를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-153">For example, use the <xref:System.Security.Cryptography.X509Certificates.X509FindType.FindByThumbprint> option, and specify the certificate by its unique thumbprint (hash).</span></span>  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="3a7d3-154">자동 등록 기능 참조 [Windows Server 2003의 인증서 자동 등록](http://go.microsoft.com/fwlink/?LinkId=95166)합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-154"> the autoenrollment feature, see [Certificate Autoenrollment in Windows Server 2003](http://go.microsoft.com/fwlink/?LinkId=95166).</span></span>  
  
## <a name="last-of-multiple-alternative-subject-names-used-for-authorization"></a><span data-ttu-id="3a7d3-155">권한 부여에 사용되는 여러 개의 대체 주체 이름 중 마지막</span><span class="sxs-lookup"><span data-stu-id="3a7d3-155">Last of Multiple Alternative Subject Names Used for Authorization</span></span>  
 <span data-ttu-id="3a7d3-156">드물지만 X.509 인증서에 여러 개의 대체 주체 이름이 포함된 경우 대체 주체 이름을 사용하여 권한을 부여하면 권한 부여가 실패할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-156">In the rare case when an X.509 certificate contains multiple alternative subject names, and you authorize using the alternative subject name, authorization may fail.</span></span>  
  
## <a name="protect-configuration-files-with-acls"></a><span data-ttu-id="3a7d3-157">ACL을 사용하여 구성 파일 보호</span><span class="sxs-lookup"><span data-stu-id="3a7d3-157">Protect Configuration Files with ACLs</span></span>  
 <span data-ttu-id="3a7d3-158">[!INCLUDE[infocard](../../../../includes/infocard-md.md)]에서 발급된 토큰에 대해 코드와 구성 파일에서 필수 및 선택적 클레임을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-158">You can specify required and optional claims in code and configuration files for [!INCLUDE[infocard](../../../../includes/infocard-md.md)] issued tokens.</span></span> <span data-ttu-id="3a7d3-159">이로 인해 보안 토큰 서비스로 전송되는 `RequestSecurityToken` 메시지에 해당 요소가 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-159">This results in corresponding elements being emitted in `RequestSecurityToken` messages that are sent to the security token service.</span></span> <span data-ttu-id="3a7d3-160">공격자는 코드나 구성을 수정하여 필수 또는 선택적 클레임을 제거하고 보안 토큰 서비스가 대상 서비스에 대한 액세스를 허용하지 않는 토큰을 발급하게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-160">An attacker can modify code or configuration to remove required or optional claims, potentially getting the security token service to issue a token that does not allow access to the target service.</span></span>  
  
 <span data-ttu-id="3a7d3-161">완화 방법: 구성 파일을 수정하려면 컴퓨터에 대한 액세스 권한이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-161">To mitigate: Require access to the computer to modify the configuration file.</span></span> <span data-ttu-id="3a7d3-162">파일 ACL(액세스 제어 목록)을 사용하여 구성 파일에 보안을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-162">Use file access control lists (ACLs) to secure configuration files.</span></span> [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="3a7d3-163">를 사용하는 경우 코드가 응용 프로그램 디렉터리나 전역 어셈블리 캐시에 있어야만 해당 코드를 구성에서 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-163"> requires that code be in the application directory or the global assembly cache before it will allow such code to be loaded from configuration.</span></span> <span data-ttu-id="3a7d3-164">디렉터리 ACL을 사용하여 디렉터리에 보안을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-164">Use directory ACLs to secure directories.</span></span>  
  
## <a name="maximum-number-of-secure-sessions-for-a-service-is-reached"></a><span data-ttu-id="3a7d3-165">서비스에 허용되는 보안 세션의 최대 개수</span><span class="sxs-lookup"><span data-stu-id="3a7d3-165">Maximum Number of Secure Sessions for a Service Is Reached</span></span>  
 <span data-ttu-id="3a7d3-166">서비스에서 성공적으로 클라이언트를 인증하고 서비스와의 보안 세션이 설정된 경우 서비스는 클라이언트가 세션을 취소하거나 세션이 만료될 때까지 세션을 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-166">When a client is successfully authenticated by a service and a secure session is established with the service, the service keeps track of the session until the client cancels it or the session expires.</span></span> <span data-ttu-id="3a7d3-167">설정된 각 세션은 서비스에 대해 허용되는 동시 활성 세션의 최대 개수 제한에 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-167">Every established session counts against the limit for the maximum number of active simultaneous sessions with a service.</span></span> <span data-ttu-id="3a7d3-168">이 제한에 도달하면 하나 이상의 활성 세션이 만료되거나 클라이언트에 의해 취소될 때까지 해당 서비스와 새 세션을 만들려고 시도하는 클라이언트가 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-168">When this limit is reached, clients that attempt to create a new session with that service are rejected until one or more active sessions expire or are canceled by a client.</span></span> <span data-ttu-id="3a7d3-169">클라이언트는 서비스와 여러 세션을 만들 수 있으며, 이러한 세션의 각각이 제한에 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-169">A client can have multiple sessions with a service, and each one of those sessions counts toward the limit.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a7d3-170">상태 저장 세션을 사용하는 경우 이전 단락의 내용이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-170">When you use stateful sessions, the previous paragraph does not apply.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="3a7d3-171">상태 저장 세션 참조 [하는 방법: 보안 세션에 대 한 보안 컨텍스트 토큰 만들기](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-171"> stateful sessions, see [How to: Create a Security Context Token for a Secure Session](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md).</span></span>  
  
 <span data-ttu-id="3a7d3-172">이 문제를 완화하려면 <xref:System.ServiceModel.Channels.SecurityBindingElement> 클래스의 <xref:System.ServiceModel.Channels.SecurityBindingElement> 속성을 설정하여 활성 세션의 최대 개수와 세션의 최대 수명에 대해 제한을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3a7d3-172">To mitigate this, set the limit for the maximum number of active sessions and the maximum lifetime for a session by setting the <xref:System.ServiceModel.Channels.SecurityBindingElement> property of the <xref:System.ServiceModel.Channels.SecurityBindingElement> class.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3a7d3-173">참고 항목</span><span class="sxs-lookup"><span data-stu-id="3a7d3-173">See Also</span></span>  
 [<span data-ttu-id="3a7d3-174">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="3a7d3-174">Security Considerations</span></span>](../../../../docs/framework/wcf/feature-details/security-considerations-in-wcf.md)  
 [<span data-ttu-id="3a7d3-175">정보 공개</span><span class="sxs-lookup"><span data-stu-id="3a7d3-175">Information Disclosure</span></span>](../../../../docs/framework/wcf/feature-details/information-disclosure.md)  
 [<span data-ttu-id="3a7d3-176">권한 상승</span><span class="sxs-lookup"><span data-stu-id="3a7d3-176">Elevation of Privilege</span></span>](../../../../docs/framework/wcf/feature-details/elevation-of-privilege.md)  
 [<span data-ttu-id="3a7d3-177">서비스 거부</span><span class="sxs-lookup"><span data-stu-id="3a7d3-177">Denial of Service</span></span>](../../../../docs/framework/wcf/feature-details/denial-of-service.md)  
 [<span data-ttu-id="3a7d3-178">재생 공격</span><span class="sxs-lookup"><span data-stu-id="3a7d3-178">Replay Attacks</span></span>](../../../../docs/framework/wcf/feature-details/replay-attacks.md)  
 [<span data-ttu-id="3a7d3-179">변조</span><span class="sxs-lookup"><span data-stu-id="3a7d3-179">Tampering</span></span>](../../../../docs/framework/wcf/feature-details/tampering.md)  
 [<span data-ttu-id="3a7d3-180">지원되지 않는 시나리오</span><span class="sxs-lookup"><span data-stu-id="3a7d3-180">Unsupported Scenarios</span></span>](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md)

---
title: 큰 데이터 및 스트리밍
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: f58e61ef76173030db49d4911875cc40200e53d5
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33496564"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="83476-102">큰 데이터 및 스트리밍</span><span class="sxs-lookup"><span data-stu-id="83476-102">Large Data and Streaming</span></span>
<span data-ttu-id="83476-103">Windows Communication Foundation (WCF) XML 기반 통신 인프라입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-103">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="83476-104">XML 데이터에 정의 된 표준 텍스트 형식으로 인코딩되어 일반적으로 하기 때문에 [XML 1.0 사양](http://go.microsoft.com/fwlink/?LinkId=94838)관계, 설계자 및 시스템 개발자가 일반적으로 염려 하는 전송 된 메시지의 통신 사용 공간 (또는 크기)에서 네트워크 및 XML의 텍스트 기반 인코딩과 이진 데이터의 효율적인 전송을 위한 특별히 고려해 야 할 제기 됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-104">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](http://go.microsoft.com/fwlink/?LinkId=94838), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="83476-105">기본 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83476-105">Basic Considerations</span></span>  
 <span data-ttu-id="83476-106">WCF에 대 한 다음 정보에 대 한 배경 정보를 제공 하려면이 섹션에서는 몇 가지 일반적인 문제 및 인코딩, 이진 데이터에 대 한 고려 사항 및 연결 된 시스템 인프라에 적용 하는 일반적으로 스트리밍.</span><span class="sxs-lookup"><span data-stu-id="83476-106">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="83476-107">인코딩 데이터: 텍스트와 이항</span><span class="sxs-lookup"><span data-stu-id="83476-107">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="83476-108">개발자가 일반적으로 말하는 고려 사항에는 XML에 시작 태그와 끝 태그가 반복된다는 점 때문에 이진 형식에 비해 오버헤드가 크다는 점, 숫자 값의 인코딩이 텍스트 값으로 표현되기 때문에 너무 크다는 점, 이진 데이터를 텍스트 형식으로 포함하려면 특수 인코딩이 필요하기 때문에 효과적인 표현이 어렵다는 점 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-108">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="83476-109">이러한 종류의 고려 사항 중에는 유용한 것도 많지만, XML 웹 서비스 환경의 XML 텍스트 인코딩 메시지와 레거시 RPC(원격 프로시저 호출) 환경의 이진 인코딩 메시지 사이의 실질적인 차이는 초기 고려 사항에서 제안하는 것만큼 심각하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-109">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="83476-110">XML 텍스트 인코딩 메시지는 투명하며, "사람이 인식할 수 있는" 형태로 되어 있지만, 이진 메시지는 그보다 모호해서 도구가 없이는 해독하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-110">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="83476-111">이러한 가독성의 차이 때문에 이진 메시지 역시 페이로드 내에 인라인 메타데이터가 포함되어 XML 텍스트 메시지와 마찬가지로 오버헤드를 가중시키는 일이 많다는 것을 간과하기가 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-111">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="83476-112">느슨한 결합 및 동적 호출 기능을 제공할 목적으로 사용되는 이진 형식의 경우 특히 그러합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-112">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="83476-113">이진 형식 역시 뒤에 있는 데이터 레코드의 데이터 레이아웃을 선언하는 그러한 설명 메타데이터 정보를 "헤더"에 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-113">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="83476-114">그러면 이 공용 메타데이터 블록 선언 뒤에 페이로드가 오며 추가 오버헤드를 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-114">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="83476-115">한편, XML은 요소 또는 특성에 있는 각 데이터 항목을 기호로 묶어 serialize되는 각 페이로드 개체에 묶는 메타데이터를 반복적으로 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-115">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="83476-116">따라서 텍스트와 이진 표현 모두에서 몇 가지 설명적인 메타데이터를 나타내야 하기 때문에 serialize된 단일 페이로드 개체의 크기가 매우 비슷하지만, 전송되는 각각의 추가 페이로드 개체가 있는 경우 이진 형식은 공유 메타데이터 설명을 활용할 때 전체적인 오버헤드가 낮아진다는 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-116">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="83476-117">하지만 숫자와 같은 특정 데이터 형식의 경우 일반 텍스트 대신 128비트 10진수 형식을 사용하는 등 고정된 크기의 이진 숫자 표현을 사용하는 것이 불리할 수도 있습니다. 일반 텍스트 표현이 몇 바이트라도 더 작을 수가 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-117">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="83476-118">일부 이진 형식이 기본적으로 16비트 또는 32비트 유니코드를 사용하는 반면, 일반적으로 XML 텍스트 인코딩 선택은 더 유연하기 때문에 텍스트 데이터에도 크기 상의 이점이 있을 수 있습니다. 하지만 .NET 이진 XML 형식에는 이 사항이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-118">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="83476-119">따라서 텍스트와 이진 사이에서 선택할 때 이진 메시지가 항상 XML 텍스트 메시지보다 작을 것이라고 쉽게 가정할 수가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-119">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="83476-120">XML 텍스트 메시지의 분명한 이점은 표준 기반이며 넓은 상호 운용성 옵션 및 플랫폼 지원을 제공한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-120">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="83476-121">자세한 내용은이 항목의 뒷부분에 나오는 "인코딩" 섹션을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="83476-121">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="83476-122">이진 콘텐츠</span><span class="sxs-lookup"><span data-stu-id="83476-122">Binary Content</span></span>  
 <span data-ttu-id="83476-123">결과 메시지의 크기 면에서 이진 인코딩이 텍스트 기반 인코딩보다 우수한 영역은 그림, 비디오, 사운드 클립 또는 서비스와 소비자 사이에서 교환해야 하는 기타 형식의 불투명한 이진 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-123">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="83476-124">이러한 형식의 데이터를 XML 텍스트에 넣기 위해 일반적으로 사용하는 방법은 Base64 인코딩을 사용하여 인코딩하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-124">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="83476-125">Base64 인코딩된 문자열에서 각 문자는 원래 8비트 데이터 중 6비트를 나타내며, 따라서 규칙에 따라 일반적으로 추가되는 추가 형식 문자(캐리지 리턴/줄 바꿈)를 제외하고 Base64에서 인코딩 오버헤드 비율은 4:3이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-125">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="83476-126">XML과 이진 인코딩 사이의 차이가 갖는 심각도는 일반적으로 시나리오에 따라 결정되지만, 500MB의 페이로드를 전송하면서 크기가 33% 이상 증가한다면 보통은 적절하지 못한 것으로 봅니다.</span><span class="sxs-lookup"><span data-stu-id="83476-126">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="83476-127">이 인코딩 오버헤드를 방지하기 위해 MTOM(Message Transmission Optimization Mechanism) 표준에서는 메시지에 포함된 큰 데이터 요소를 구체화하여 특별한 인코딩 없이도 메시지와 함께 이진 데이터로서 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-127">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="83476-128">Mtom에서는 메시지는 첨부 파일이 나 포함 된 콘텐츠 (그림 및 기타 포함 된 콘텐츠;)가 있는 SMTP Simple Mail Transfer Protocol () 전자 메일 메시지와 비슷한 방식 MTOM 메시지는 루트 부분이 실제 SOAP 메시지에 다중 파트/관련 MIME 시퀀스로 패키지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-128">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="83476-129">MTOM SOAP 메시지는 해당 MIME 부분을 참조하는 특수 요소 태그가 이진 데이터를 포함하는 메시지에서 원래 요소의 자리를 차지하도록 인코딩되지 않은 버전에서 수정됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-129">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="83476-130">따라서 SOAP 메시지는 함께 전송되는 MIME을 가리키는 방식으로 이진 콘텐츠를 참조하고, 그 외의 경우에는 XML 텍스트 데이터만 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-130">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="83476-131">이 모델이 잘 구성된 SMTP 모델과 매우 가깝기 때문에 MTOM 메시지의 인코딩 및 디코딩 도구를 폭 넓게 지원하여 상호 운용성을 극대화하는 플랫폼도 많습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-131">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="83476-132">하지만 Base64와 마찬가지로, MTOM 역시 MIME 형식에 필요한 몇 가지 오버헤드를 동반하기 때문에 MTOM을 사용하는 경우의 장점은 이진 데이터 요소의 크기가 약 1KB를 넘는 경우에만 실감할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-132">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="83476-133">이진 페이로드가 이 임계값 아래로만 유지되는 경우에는 오버헤드로 인해 MTOM 인코딩 메시지가 이진 데이터에 Base64 인코딩을 사용하는 메시지보다 커질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-133">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="83476-134">자세한 내용은이 항목의 뒷부분에 나오는 "인코딩" 섹션을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="83476-134">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="83476-135">큰 데이터 콘텐츠</span><span class="sxs-lookup"><span data-stu-id="83476-135">Large Data Content</span></span>  
 <span data-ttu-id="83476-136">와이어 크기를 고려하지 않더라도, 앞에서 언급한 500MB 페이로드는 서비스 및 클라이언트에 큰 로컬 과제를 남깁니다.</span><span class="sxs-lookup"><span data-stu-id="83476-136">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="83476-137">기본적으로 WCF에 메시지를 처리 *버퍼링된 모드*합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-137">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="83476-138">즉, 메시지의 전체 콘텐츠가 보내기 전과 받은 후에 메모리에 보관됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-138">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="83476-139">대부분의 시나리오에서는 좋은 전략이며, 디지털 서명 및 안정적인 배달 등의 메시징 기능에 필수적인 방법이지만, 큰 메시지를 전달하는 경우에는 시스템 리소스가 빠른 속도로 소모될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-139">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="83476-140">큰 페이로드를 처리하는 전략은 스트리밍입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-140">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="83476-141">메시지, 특히 XML로 표현되는 메시지는 일반적으로 비교적 압축된 데이터 패키지로 인식되지만, 메시지의 크기가 여러 기가바이트에 달할 수도 있으며, 데이터 패키지보다는 연속적인 데이터 스트림과 비슷한 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-141">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="83476-142">버퍼링 모드 대신 스트리밍 모드를 사용하여 데이터를 전송하면 보내는 사람은 메시지 본문의 콘텐츠를 스트림의 형태로 받는 사람이 사용할 수 있게 만들고, 메시지 인프라에서는 데이터를 사용할 수 있게 되는대로 보내는 사람에게서 받는 사람에게로 계속 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-142">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="83476-143">그러한 큰 데이터 콘텐츠의 전송이 이루어지는 가장 흔한 시나리오는 다음과 같은 이진 데이터 개체를 전송하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-143">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
-   <span data-ttu-id="83476-144">메시지 시퀀스로 쉽게 분해할 수 없음</span><span class="sxs-lookup"><span data-stu-id="83476-144">Cannot be easily broken up into a message sequence.</span></span>  
  
-   <span data-ttu-id="83476-145">시기 적절하게 배달되어야 함</span><span class="sxs-lookup"><span data-stu-id="83476-145">Must be delivered in a timely manner.</span></span>  
  
-   <span data-ttu-id="83476-146">전송을 시작할 때 전체를 사용할 수 없는 데이터.</span><span class="sxs-lookup"><span data-stu-id="83476-146">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="83476-147">이러한 제약이 없는 데이터의 경우에는 보통 큰 메시지 하나보다 세션 범위 내의 메시지 시퀀스로 보내는 것이 더 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-147">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="83476-148">자세한 내용은이 항목의 뒷부분에 나오는 "스트리밍 데이터" 섹션을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-148">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="83476-149">많은 양의 데이터를 보낼 때 설정 해야 합니다는 `maxAllowedContentLength` IIS 설정 (자세한 내용은 참조 [IIS 요청 제한 구성](http://go.microsoft.com/fwlink/?LinkId=253165)) 및 `maxReceivedMessageSize` 바인딩 설정을 (예를 들어 [ System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) 또는 <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span><span class="sxs-lookup"><span data-stu-id="83476-149">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](http://go.microsoft.com/fwlink/?LinkId=253165)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="83476-150">`maxAllowedContentLength` 28.6 M 속성의 기본값 및 `maxReceivedMessageSize` 64KB 속성의 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-150">The `maxAllowedContentLength` property defaults to 28.6 M and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="83476-151">인코딩</span><span class="sxs-lookup"><span data-stu-id="83476-151">Encodings</span></span>  
 <span data-ttu-id="83476-152">*인코딩* 통신 중에 메시지를 표시 하는 방법에 대 한 규칙의 집합을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-152">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="83476-153">*인코더* 그러한 인코딩을 구현 하 고는, 보낸 사람 쪽에서는 <xref:System.ServiceModel.Channels.Message> 바이트 스트림 또는 바이트 버퍼 네트워크를 통해 보낼 수 있는 메모리 내 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-153">An *encoder* implements such an encoding and is responsible, on the sender side, for turning a <xref:System.ServiceModel.Channels.Message> in-memory message into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="83476-154">받는 쪽에서는 인코더가 바이트 시퀀스를 메모리 내 메시지로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-154">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="83476-155">WCF는 세 명의 인코더가 및 필요에 따라 작성 하 여 사용자가 직접 인코더에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-155">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="83476-156">각각의 표준 바인딩에는 미리 구성된 인코더가 포함되며, Net\* 접두사가 있는 바인딩에서는 이진 인코더를 사용하고(<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> 클래스를 포함하는 방법으로) <xref:System.ServiceModel.BasicHttpBinding> 및 <xref:System.ServiceModel.WSHttpBinding> 클래스에서는 기본적으로 텍스트 메시지 인코더(<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> 클래스 사용)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-156">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="83476-157">인코더 바인딩 요소</span><span class="sxs-lookup"><span data-stu-id="83476-157">Encoder binding element</span></span>|<span data-ttu-id="83476-158">설명</span><span class="sxs-lookup"><span data-stu-id="83476-158">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="83476-159">텍스트 메시지 인코더는 모든 HTTP 기반 바인딩의 기본 인코더이며 상호 운용성이 중요한 모든 사용자 지정 바인딩에 적절합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-159">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="83476-160">이 인코더에서는 이진 데이터를 특수 처리하지 않는 표준 SOAP 1.1/SOAP 1.2 텍스트 메시지를 읽고 씁니다.</span><span class="sxs-lookup"><span data-stu-id="83476-160">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="83476-161">메시지의 <xref:System.ServiceModel.Channels.MessageVersion>이 `None`으로 설정되어 있으면 SOAP 봉투 래퍼가 출력에서 생략되고 메시지 본문 콘텐츠만 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-161">If the <xref:System.ServiceModel.Channels.MessageVersion> of a message is set to `None`, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="83476-162">MTOM 메시지 인코더는 이진 데이터의 특수 처리를 구현하는 텍스트 인코더이며, 엄격한 경우별 최적화 유틸리티이기 때문에 표준 바인딩에서는 전혀 기본으로 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-162">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="83476-163">MTOM 인코딩이 장점을 제공하는 임계값을 초과하는 이진 데이터가 메시지에 포함되어 있으면, 데이터가 메시지 봉투 뒤의 MIME 부분에 구체화됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-163">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="83476-164">이 단원의 뒷부분에 있는 MTOM 활성화를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="83476-164">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="83476-165">이진 메시지 인코더는 Net \* 바인딩 및 적합 한 선택 항목에 대 한 기본 인코더 통신 당사자 양쪽 모두가 WCF를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-165">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="83476-166">이진 메시지 인코더에서는 .NET 이진 XML 형식을 사용합니다. 이 형식은 일반적으로 동급 XML 1.0 표현보다 크기가 작으며 이진 데이터를 바이트 스트림으로 인코딩하는 XML Infoset을 나타내는 Microsoft만의 이진 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-166">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="83476-167">텍스트 메시지 인코딩은 보통 상호 운용성이 필요한 모든 통신 경로에 적합하고, 이진 메시지 인코딩은 다른 모든 통신 경로에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-167">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="83476-168">이진 메시지 인코딩은 보통 단일 메시지의 텍스트보다 메시지 크기가 작으며, 통신 세션이 진행될수록 점점 더 메시지 크기가 작아집니다.</span><span class="sxs-lookup"><span data-stu-id="83476-168">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="83476-169">텍스트 인코딩과 달리, 이진 인코딩에서는 Base64 사용과 같은 특수 이진 데이터 처리를 수행할 필요가 없으며 바이트를 바이트로 표현합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-169">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="83476-170">솔루션에 상호 운용성이 필요 없지만 여전히 HTTP 전송을 사용하려는 경우에는 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>를 <xref:System.ServiceModel.Channels.HttpTransportBindingElement> 클래스를 전송에 사용하는 사용자 지정 바인딩에 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-170">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="83476-171">서비스에 상호 운용성이 필요한 클라이언트가 많은 경우에는 활성화된 클라이언트에 각각에 적절한 전송 및 인코딩 선택 항목이 있는 병렬 끝점을 노출하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-171">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="83476-172">MTOM 활성화</span><span class="sxs-lookup"><span data-stu-id="83476-172">Enabling MTOM</span></span>  
 <span data-ttu-id="83476-173">상호 운용성이 필요하며 큰 이진 데이터를 전송해야 하는 경우 MTOM 메시지 인코딩은 표준 <xref:System.ServiceModel.BasicHttpBinding> 또는 <xref:System.ServiceModel.WSHttpBinding> 바인딩에서 해당 `MessageEncoding` 속성을 <xref:System.ServiceModel.WSMessageEncoding.Mtom>으로 설정하거나 <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>를 <xref:System.ServiceModel.Channels.CustomBinding>에 작성하여 활성화할 수 있는 대체 인코딩 전략입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-173">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="83476-174">추출 된 다음 예제 코드는 [MTOM 인코딩](../../../../docs/framework/wcf/samples/mtom-encoding.md) 샘플 구성에 MTOM을 활성화 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="83476-174">The following example code, extracted from the [MTOM Encoding](../../../../docs/framework/wcf/samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="83476-175">앞에서 언급한 것과 같이, MTOM 인코딩의 사용 결정 사항은 보내는 데이터의 볼륨에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="83476-175">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="83476-176">또한 MTOM이 바인딩 수준에서 활성화되기 때문에 MTOM을 활성화하면 지정된 끝점의 모든 작업에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="83476-176">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="83476-177">MTOM 인코더가 이진 데이터의 구체화 여부에 관계없이 항상 MTOM 인코딩 MIME/multipart 메시지를 내보내는 것과 상관없이 일반적으로 이진 데이터가 1KB 이상 포함된 메시지를 교환하는 끝점의 MTOM만 활성화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-177">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="83476-178">또한 MTOM이 활성화된 끝점에 사용하도록 디자인된 서비스 계약은 가능한 경우 그러한 데이터 전송 작업을 지정하는 범위로 제한되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-178">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="83476-179">관련 제어 기능은 별도의 계약에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-179">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="83476-180">이 "MTOM 전용" 규칙은 MTOM이 활성화된 끝점을 통해 전송되는 메시지에만 적용됩니다. MTOM 인코더에서는 들어오는 MTOM 외의 메시지도 디코딩하고 구문 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-180">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="83476-181">MTOM 인코더를 사용 하 여 다른 모든 WCF 기능와 준수 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-181">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="83476-182">세션 지원이 필요한 경우와 같이 이 규칙을 따를 수 없는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-182">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="83476-183">프로그래밍 모델</span><span class="sxs-lookup"><span data-stu-id="83476-183">Programming Model</span></span>  
 <span data-ttu-id="83476-184">응용 프로그램에서 세 개의 기본 제공 인코더 중 어느 것을 사용해도, 이진 데이터 전송에 대한 프로그래밍 경험은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-184">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="83476-185">WCF 데이터 형식에 따라 데이터를 처리 하는 방법을 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="83476-185">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```  
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}   
```  
  
 <span data-ttu-id="83476-186">MTOM의 경우 앞의 데이터 계약이 다음 규칙에 따라 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-186">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
-   <span data-ttu-id="83476-187">`binaryBuffer`가 `null`이 아니며 각각 Base64 인코딩에 비해 MTOM 구체화 오버헤드를 정당화하기에 충분한 데이터를 포함한 경우(MIME 헤더 등) 데이터는 구체화되어 메시지와 함께 이진 MIME 부분으로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-187">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="83476-188">임계값을 초과하지 않은 경우 데이터는 Base64로 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-188">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
-   <span data-ttu-id="83476-189">문자열과 이진이 아닌 다른 모든 형식은 크기에 관계없이 항상 메시지 본문 내의 문자열로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-189">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="83476-190">앞의 예처럼 명시적인 데이터 계약을 사용하는 경우나, 작업에서 매개 변수 목록을 사용하는 경우나, 중첩된 데이터 계약이 있는 경우나, 컬렉션 내에 데이터 계약 개체를 전송하는 경우나 MTOM 인코딩에 대한 영향은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-190">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="83476-191">바이트 배열은 항상 최적화 후보이며 최적화 임계값을 충족하면 최적화됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-191">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="83476-192">데이터 계약 내에서는 <xref:System.IO.Stream?displayProperty=nameWithType> 파생 형식을 사용하지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-192">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="83476-193">스트림 데이터는 다음 "스트리밍 데이터" 단원에 설명된 대로 스트리밍 모델을 사용하여 통신해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-193">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="83476-194">스트리밍 데이터</span><span class="sxs-lookup"><span data-stu-id="83476-194">Streaming Data</span></span>  
 <span data-ttu-id="83476-195">많은 양의 데이터를 전송 하는 경우 WCF의 스트리밍 전송 모드는 대신 버퍼링 하 고 전체적으로 메모리에 메시지 처리의 기본 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-195">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="83476-196">앞에서 언급한 것과 같이, 데이터를 세그먼트로 나눌 수 없거나, 메시지를 시기 적절하게 배달해야 하거나, 전송을 시작했을 때 데이터 전체를 사용할 수 없는 경우에 텍스트 또는 이진 콘텐츠가 있는 큰 메시지에 대해서만 스트리밍 활성화를 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-196">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="83476-197">제한</span><span class="sxs-lookup"><span data-stu-id="83476-197">Restrictions</span></span>  
 <span data-ttu-id="83476-198">스트리밍이 활성화 되어 있으면 WCF 기능 중 상당수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-198">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
-   <span data-ttu-id="83476-199">메시지 본문의 디지털 서명은 메시지 콘텐츠 전체의 해시 계산을 필요로 하기 때문에 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-199">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="83476-200">스트리밍을 사용하면 메시지 헤더를 생성하여 보낼 때 콘텐츠를 전부 사용할 수 없기 때문에 디지털 서명을 계산할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-200">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
-   <span data-ttu-id="83476-201">암호화에서는 디지털 서명에 의존하여 데이터가 올바르게 생성되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-201">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
-   <span data-ttu-id="83476-202">신뢰할 수 있는 세션에서는 전송 중에 메시지가 손실된 경우 다시 배달할 수 있도록 클라이언트에 보낸 메시지를 버퍼링하고, 메시지를 서비스 구현으로 전달하기 전에 서비스에 보관하여 메시지가 시퀀스에 맞지 않게 수신된 경우 메시지 시퀀스를 보존합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-202">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="83476-203">이러한 기능적 제약 때문에 스트리밍에는 전송 수준 보안 옵션만 사용할 수 있으며 신뢰할 수 있는 세션을 켤 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-203">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="83476-204">스트리밍은 다음 시스템 정의 바인딩에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-204">Streaming is only available with the following system-defined bindings:</span></span>  
  
-   <xref:System.ServiceModel.BasicHttpBinding>  
  
-   <xref:System.ServiceModel.NetTcpBinding>  
  
-   <xref:System.ServiceModel.NetNamedPipeBinding>  
  
-   <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="83476-205"><xref:System.ServiceModel.NetTcpBinding> 및 <xref:System.ServiceModel.NetNamedPipeBinding>의 기본 전송에는 신뢰할 수 있는 고유한 배달 및 연결 기반 세션 지원이 있기 때문에 HTTP와 달리 이 두 바인딩은 실제로 이러한 제약 조건에 의해 최소한의 영향만 받습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-205">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="83476-206">스트리밍은 MSMQ(메시지 큐) 전송에서 사용할 수 없기 때문에 <xref:System.ServiceModel.NetMsmqBinding> 또는 <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> 클래스에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-206">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="83476-207">다른 모든 전송에서는 대부분의 시나리오에 대해 실제 메시지 크기 제한이 없는 반면, 메시지 큐 전송에서는 메시지 크기가 제한된 버퍼링 데이터 전송만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-207">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="83476-208">스트리밍은 피어 채널 전송을 사용할 때 사용할 수 없기 때문에 <xref:System.ServiceModel.NetPeerTcpBinding>에서 사용할 수도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-208">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="83476-209">스트리밍 및 세션</span><span class="sxs-lookup"><span data-stu-id="83476-209">Streaming and Sessions</span></span>  
 <span data-ttu-id="83476-210">세션 기반 바인딩을 통해 스트리밍 호출이 수행될 경우 예기치 못한 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="83476-211">모든 스트리밍 호출은 사용 중인 바인딩이 세션을 사용하도록 구성된 경우에도 세션을 지원하지 않는 하나의 채널(데이터그램 채널)을 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="83476-212">여러 클라이언트에서 세션 기반 바인딩을 통해 동일한 서비스 개체에 대한 스트리밍 호출을 수행하고, 서비스 개체의 동시성 모드가 단일 모드로 설정되고, 서비스 개체의 인스턴스 컨텍스트 모드가 PerSession으로 설정된 경우, 모든 호출은 데이터그램 채널을 통해 수행되므로 한 번에 하나의 호출만 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-212">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="83476-213">하나 이상의 클라이언트의 제한 시간이 초과될 수 있습니다. 이 문제는 서비스 개체의 인스턴스 컨텍스트 모드를 PerCall로 설정하거나 동시성 모드를 다중 모드로 설정하여 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-213">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="83476-214">이 경우 사용할 수 있는 "세션"이 하나이기 때문에 MaxConcurrentSessions에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-214">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="83476-215">스트리밍 활성화</span><span class="sxs-lookup"><span data-stu-id="83476-215">Enabling Streaming</span></span>  
 <span data-ttu-id="83476-216">다음 방법을 사용하여 스트리밍을 활성화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-216">You can enable streaming in the following ways:</span></span>  
  
-   <span data-ttu-id="83476-217">스트리밍 모드에서 요청을 보내기 및 승인, 버퍼링 모드에서 응답 승인 및 반환(<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span><span class="sxs-lookup"><span data-stu-id="83476-217">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
-   <span data-ttu-id="83476-218">버퍼링 모드에서 요청을 보내기 및 승인, 스트리밍 모드에서 응답 승인 및 반환(<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span><span class="sxs-lookup"><span data-stu-id="83476-218">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
-   <span data-ttu-id="83476-219">스트리밍 모드에서 양방향으로 요청 및 응답을 보내고 받기.</span><span class="sxs-lookup"><span data-stu-id="83476-219">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="83476-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="83476-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="83476-221">전송 모드를 모든 바인딩의 기본 설정인 <xref:System.ServiceModel.TransferMode.Buffered>로 설정하면 스트리밍을 비활성화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-221">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="83476-222">다음 코드에서는 구성에 전송 모드를 설정하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="83476-222">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streaming"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="83476-223">바인딩을 코드에 인스턴스화하는 경우에는 바인딩의 해당 `TransferMode` 속성(또는 사용자 지정 바인딩을 작성하는 경우 전송 바인딩 요소)을 앞에서 언급한 값 중 하나로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-223">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="83476-224">요청 및 응답의 스트리밍을 켜거나 양방향 모두에 대해 통신 참가자 중 어느 쪽에서나 기능에 영향을 주지 않고 독립적으로 스트리밍을 켤 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-224">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="83476-225">하지만 전송 데이터 크기가 너무 커서 통신 링크의 양 끝점 모두에서 스트리밍을 활성화하는 것이 적합하다고 항상 가정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-225">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="83476-226">여기서 끝점 중 하나가 구현 되지 않은 WCF를 사용한 플랫폼 간 통신에 스트리밍을 사용 하는 기능 플랫폼의 스트리밍 기능에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="83476-226">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="83476-227">다른 흔치 않은 예외로는 클라이언트 또는 서비스에서 작업 집합을 최소화해야 하며 작은 버퍼 크기만 사용할 수 있는 메모리 소비 구동 시나리오가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-227">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="83476-228">비동기 스트리밍 사용</span><span class="sxs-lookup"><span data-stu-id="83476-228">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="83476-229">비동기 스트리밍을 사용하려면 <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> 끝점 동작을 서비스 호스트에 추가하고 <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> 속성을 `true`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-229">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="83476-230">또한 전송 측에 진정한 의미의 비동기 스트리밍 기능을 추가했습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-230">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="83476-231">이에 따라 메시지를 복수 클라이언트로 스트리밍하고 그 중 일부는 네트워크 혼잡으로 인해 읽는 속도가 느리거나 전혀 읽고 있지 않은 시나리오에서 서비스 확장성이 향상되었습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-231">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="83476-232">이러한 시나리오에서는 이제 클라이언트당 서비스에서 개별 스레드를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-232">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="83476-233">그러므로 서비스가 훨씬 더 많은 클라이언트를 처리해서 서비스 확장성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-233">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="83476-234">스트리밍 전송의 프로그래밍 모델</span><span class="sxs-lookup"><span data-stu-id="83476-234">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="83476-235">스트리밍의 프로그래밍 모델은 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-235">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="83476-236">스트리밍 데이터를 받으려면 단일 <xref:System.IO.Stream> 형식 입력 매개 변수가 있는 작업 계약을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-236">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="83476-237">스트리밍 데이터를 반환하려면 <xref:System.IO.Stream> 참조를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-237">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```  
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="83476-238">위 예의 `Echo` 작업에서는 스트림을 받아서 반환하기 때문에 <xref:System.ServiceModel.TransferMode.Streamed>의 바인딩에서 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-238">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="83476-239">`RequestInfo` 작업의 경우 <xref:System.ServiceModel.TransferMode.StreamedResponse>가 <xref:System.IO.Stream>만 반환하기 때문에 가장 적절합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-239">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="83476-240">단방향 작업은 <xref:System.ServiceModel.TransferMode.StreamedRequest>에 가장 적절합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-240">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="83476-241">다음 `Echo` 또는 `ProvideInfo` 작업에 두 번째 매개 변수를 추가하면 서비스 모델이 버퍼링 전략으로 돌아가며 스트림의 런타임 serialization 표현을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-241">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="83476-242">입력 스트림 매개 변수가 하나인 작업만을 종단 간 요청 스트리밍에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-242">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="83476-243">이 규칙은 메시지 계약에도 비슷하게 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-243">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="83476-244">다음 메시지 계약에 표시되어 있는 것과 같이, 스트림에 해당되는 메시지 계약에는 본문 멤버가 하나만 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-244">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="83476-245">스트리밍으로 추가 정보를 전달하려는 경우 이 정보는 메시지 헤더에 포함되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-245">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="83476-246">메시지 본문은 스트림 콘텐츠용으로 단독으로 예약되었습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-246">The message body is exclusively reserved for the stream content.</span></span>  
  
```  
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}   
```  
  
 <span data-ttu-id="83476-247">스트림이 EOF(파일의 끝)에 도달하면 스트리밍 전송이 끝나고 메시지가 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="83476-247">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="83476-248">메시지를 보낼 때 (값 반환 또는 작업 호출)를 전달할 수 있습니다는 <xref:System.IO.FileStream> WCF 인프라 스트림을 완전히 읽고 EOF에 도달할 때까지 해당 스트림에서 모든 데이터 이후에 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-248">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="83476-249">그러한 기본 제공되는 <xref:System.IO.Stream> 파생 클래스가 없는 소스에 스트리밍 데이터를 전달하려면 그러한 클래스를 생성하고, 스트림 소스 위에 해당 클래스를 오버레이하고, 그 결과를 인수 또는 반환 값으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-249">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="83476-250">Base64 인코딩 메시지 본문 내용 (또는 MTOM을 사용 하는 경우 해당 MIME 부분)를 통해 WCF 스트림을 생성 메시지를 받을 때와 콘텐츠를 읽고 나면 스트림이 EOF에 도달 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-250">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="83476-251">전송 수준 스트리밍은 다른 메시지 계약 형식(매개 변수 목록, 데이터 계약 인수 및 명시적 메시지 계약)에도 적용되지만 그러한 메시지 형식의 serialization 및 deserialization에는 serializer의 버퍼링이 필요하기 때문에, 그러한 계약 variant는 좋지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-251">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="83476-252">큰 데이터의 특수 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83476-252">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="83476-253">모든 바인딩에서는 들어오는 메시지의 크기를 제한하여 서비스 거부 공격을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-253">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="83476-254"><xref:System.ServiceModel.BasicHttpBinding>, 예를 들어 노출 한 [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) 액세스 하는 메모리의 최대 크기를 제한 하는 들어오는 메시지의 크기를 제한 하는 속성 메시지를 처리할 때.</span><span class="sxs-lookup"><span data-stu-id="83476-254">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="83476-255">이 단위는 바이트로 설정되며 기본값은 65,536바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-255">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="83476-256">큰 데이터 스트리밍 시나리오에 해당되는 보안 위험은 수신기에서 스트리밍을 예상할 때 데이터를 버퍼링하게 만들어 서비스 거부를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="83476-256">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="83476-257">예를 들어 WCF 메시지의 SOAP 헤더를 항상 버퍼링 및 되므로 공격자가 데이터를 버퍼링 시킬 헤더로 구성 된 큰 용량의 악의적인 메시지를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-257">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="83476-258">스트리밍이 활성화되면 수신기에서 전체 메시지가 한 번에 메시지에 버퍼링될 것이라고 예상하지 않기 때문에 `MaxReceivedMessageSize`를 매우 큰 값으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-258">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="83476-259">WCF 메시지를 버퍼링 해야 하는 경우 메모리 오버플로가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-259">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="83476-260">따라서 이 경우에는 들어오는 메시지 크기를 제한하는 것만으로는 부족합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-260">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="83476-261">`MaxBufferSize` 속성은 WCF 버퍼링 할 메모리를 제한 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-261">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="83476-262">스트리밍을 수행할 때 이 값을 안전한 값으로 설정하거나 기본값으로 유지하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-262">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="83476-263">예를 들어, 서비스에서 크기 4GB까지의 파일을 받아 로컬 디스크에 저장해야 하는 경우를 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-263">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="83476-264">한 번에 64KB까지의 데이터만 버퍼링할 수 있는 방법으로 메모리가 제한된 경우도 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-264">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="83476-265">그러면 `MaxReceivedMessageSize`는 4GB로 설정하고 `MaxBufferSize`는 64KB로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-265">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="83476-266">또한 서비스 구현에서 64KB 청크의 들어오는 스트림에서만 읽으며 이전 부분이 디스크에 기록된 후 메모리에서 폐기되기 전에는 다음 청크를 읽지 않는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-266">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="83476-267">이 할당량만 제한 WCF에서 수행 하는 버퍼링을 이해 해야 하 고 고유한 서비스 또는 클라이언트 구현에서 수행 하는 버퍼링 으로부터 보호할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-267">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="83476-268">추가 보안 고려 사항에 대 한 자세한 내용은 참조 [데이터에 대 한 보안 고려 사항](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-268">For more information about additional security considerations, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="83476-269">버퍼링 또는 스트리밍 전송 중 어느 것을 사용할 것인지를 결정하는 것은 끝점의 로컬 결정입니다.</span><span class="sxs-lookup"><span data-stu-id="83476-269">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="83476-270">HTTP 전송의 경우 전송 모드는 연결 전체 또는 프록시 서버 및 다른 매개로 전파되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-270">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="83476-271">서비스 인터페이스의 설명에 전송 모드 설정이 반영되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="83476-271">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="83476-272">WCF 클라이언트를 서비스를 생성 한 후 스트리밍 전송 모드를 설정 하려면 사용 하도록 서비스에 대 한 구성 파일을 편집 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83476-272">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="83476-273">TCP 및 명명된 파이프 전송의 경우에는 전송 모드가 정책 어설션으로 전파됩니다.</span><span class="sxs-lookup"><span data-stu-id="83476-273">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="83476-274">참고 항목</span><span class="sxs-lookup"><span data-stu-id="83476-274">See Also</span></span>  
 [<span data-ttu-id="83476-275">방법: 스트리밍 사용</span><span class="sxs-lookup"><span data-stu-id="83476-275">How to: Enable Streaming</span></span>](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)

---
title: "최선의 방법: 데이터 계약 버전 관리"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- data contracts
- service contracts
- best practices [WCF], data contract versioning
- Windows Communication Foundation, data contracts
ms.assetid: bf0ab338-4d36-4e12-8002-8ebfdeb346cb
caps.latest.revision: "24"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: b5d6c5cb24b2a8395399eb6a4d76024e2efacee0
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="best-practices-data-contract-versioning"></a><span data-ttu-id="2d49a-102">최선의 방법: 데이터 계약 버전 관리</span><span class="sxs-lookup"><span data-stu-id="2d49a-102">Best Practices: Data Contract Versioning</span></span>
<span data-ttu-id="2d49a-103">이 항목에서는 시간 경과에 따라 쉽게 발전할 수 있는 데이터 계약을 만드는 최선의 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-103">This topic lists the best practices for creating data contracts that can evolve easily over time.</span></span> [!INCLUDE[crabout](../../../includes/crabout-md.md)]<span data-ttu-id="2d49a-104">항목을 참조 하는 데이터 계약 [를 사용 하 여 데이터 계약](../../../docs/framework/wcf/feature-details/using-data-contracts.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-104"> data contracts, see the topics in [Using Data Contracts](../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
## <a name="note-on-schema-validation"></a><span data-ttu-id="2d49a-105">스키마 유효성 검사에 대한 참고</span><span class="sxs-lookup"><span data-stu-id="2d49a-105">Note on Schema Validation</span></span>  
 <span data-ttu-id="2d49a-106">데이터 계약 버전 관리를 설명할 때는 기본적으로 요소가 옵션으로 표시된다는 사실을 제외하고 [!INCLUDE[indigo1](../../../includes/indigo1-md.md)]에서 내보낸 데이터 계약 스키마에 버전 관리 지원이 없음을 확인하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-106">In discussing data contract versioning, it is important to note that the data contract schema exported by [!INCLUDE[indigo1](../../../includes/indigo1-md.md)] does not have any versioning support, other than the fact that elements are marked as optional by default.</span></span>  
  
 <span data-ttu-id="2d49a-107">이는 새 데이터 멤버 추가 같은 가장 일반적인 버전 관리 시나리오도 지정된 스키마와 관련해서 매끄럽게 구현할 수 없음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-107">This means that even the most common versioning scenario, such as adding a new data member, cannot be implemented in a way that is seamless with regard to a given schema.</span></span> <span data-ttu-id="2d49a-108">예를 들어 새 데이터 멤버가 있는 최신 버전의 데이터 계약은 이전 스키마를 사용하여 유효성이 검사되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-108">The newer versions of a data contract (with a new data member, for example) do not validate using the old schema.</span></span>  
  
 <span data-ttu-id="2d49a-109">그러나 엄격한 스키마 준수가 필요하지 않은 많은 시나리오가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-109">However, there are many scenarios in which strict schema compliance is not required.</span></span> <span data-ttu-id="2d49a-110">[!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 및 ASP.NET을 사용하여 만든 XML 웹 서비스 등 많은 웹 서비스 플랫폼은 기본적으로 스키마 유효성 검사를 수행하지 않으므로 스키마에서 설명하지 않는 추가 요소를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-110">Many Web services platforms, including [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] and XML Web services created using ASP.NET, do not perform schema validation by default and therefore tolerate extra elements that are not described by the schema.</span></span> <span data-ttu-id="2d49a-111">이러한 플랫폼에서 작업할 때는 많은 버전 관리 시나리오를 보다 쉽게 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-111">When working with such platforms, many versioning scenarios are easier to implement.</span></span>  
  
 <span data-ttu-id="2d49a-112">따라서 데이터 계약 버전 관리 지침에는 엄격한 스키마 유효성이 중요한 시나리오에 대한 집합과 중요하지 않은 시나리오에 대한 집합의 두 가지 집합이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-112">Thus, there are two sets of data contract versioning guidelines: one set for scenarios where strict schema validity is important, and another set for scenarios when it is not.</span></span>  
  
## <a name="versioning-when-schema-validation-is-required"></a><span data-ttu-id="2d49a-113">스키마 유효성 검사가 필요한 경우의 버전 관리</span><span class="sxs-lookup"><span data-stu-id="2d49a-113">Versioning When Schema Validation Is Required</span></span>  
 <span data-ttu-id="2d49a-114">엄격한 스키마 유효성이 모든 방향(새 버전에서 이전 버전으로 및 이전 버전에서 새 버전으로)에서 필요한 경우 데이터 계약을 변경 불가능한 것으로 간주해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-114">If strict schema validity is required in all directions (new-to-old and old-to-new), data contracts should be considered immutable.</span></span> <span data-ttu-id="2d49a-115">버전 관리가 필요하면 다른 이름이나 네임스페이스로 새 데이터 계약을 만들어야 하며, 해당 데이터 형식을 사용한 서비스 계약의 버전을 적절하게 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-115">If versioning is required, a new data contract should be created, with a different name or namespace, and the service contract using the data type should be versioned accordingly.</span></span>  
  
 <span data-ttu-id="2d49a-116">예를 들어 `PoProcessing` 데이터 계약을 준수하는 매개 변수를 사용하는 `PostPurchaseOrder` 작업으로 `PurchaseOrder`이라는 구매 주문 처리 서비스 계약을 가정해 보세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-116">For example, a purchase order processing service contract named `PoProcessing` with a `PostPurchaseOrder` operation takes a parameter that conforms to a `PurchaseOrder` data contract.</span></span> <span data-ttu-id="2d49a-117">`PurchaseOrder` 계약을 변경해야 하는 경우 변경 내용을 포함하는 새 데이터 계약 `PurchaseOrder2`를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-117">If the `PurchaseOrder` contract has to change, you must create a new data contract, that is, `PurchaseOrder2`, which includes the changes.</span></span> <span data-ttu-id="2d49a-118">그런 다음 서비스 계약 수준에서 버전 관리를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-118">You must then handle the versioning at the service contract level.</span></span> <span data-ttu-id="2d49a-119">예를 들어 `PostPurchaseOrder2` 매개 변수를 사용하는 `PurchaseOrder2` 작업을 만들거나 `PoProcessing2` 작업이 `PostPurchaseOrder` 데이터 계약을 사용하는 `PurchaseOrder2` 서비스 계약을 만들어 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-119">For example, by creating a `PostPurchaseOrder2` operation that takes the `PurchaseOrder2` parameter, or by creating a `PoProcessing2` service contract where the `PostPurchaseOrder` operation takes a `PurchaseOrder2` data contract.</span></span>  
  
 <span data-ttu-id="2d49a-120">다른 데이터 계약에서 참조하는 데이터 계약의 변경 내용도 서비스 모델 계층으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-120">Note that changes in data contracts that are referenced by other data contracts also extend to the service model layer.</span></span> <span data-ttu-id="2d49a-121">예를 들어 이전 시나리오에서 `PurchaseOrder` 데이터 계약을 변경할 필요가 없다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-121">For example, in the previous scenario the `PurchaseOrder` data contract does not need to change.</span></span> <span data-ttu-id="2d49a-122">그러나 이 데이터 계약에 `Customer` 데이터 계약의 데이터 멤버가 포함되어 있고, 여기에는 변경해야 하는 `Address` 데이터 계약의 데이터 멤버가 들어 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-122">However, it contains a data member of a `Customer` data contract, which in turn contained a data member of the `Address` data contract, which does need to be changed.</span></span> <span data-ttu-id="2d49a-123">이 경우 필요한 변경 내용이 포함된 `Address2` 데이터 계약, `Customer2` 데이터 멤버가 포함된 `Address2` 데이터 계약, `PurchaseOrder2` 데이터 멤버가 포함된 `Customer2` 데이터 계약을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-123">In that case, you would need to create an `Address2` data contract with the required changes, a `Customer2` data contract that contains the `Address2` data member, and a `PurchaseOrder2` data contract that contains a `Customer2` data member.</span></span> <span data-ttu-id="2d49a-124">이전 경우와 같이 서비스 계약의 버전을 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-124">As in the previous case, the service contract would have to be versioned as well.</span></span>  
  
 <span data-ttu-id="2d49a-125">이러한 예제에서는 "2"를 추가하여 이름이 변경되지만 버전 번호나 날짜가 포함된 새 네임스페이스를 추가하여 이름 대신 네임스페이스를 변경하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-125">Although in these examples names are changed (by appending a "2"), the recommendation is to change namespaces instead of names by appending new namespaces with a version number or a date.</span></span> <span data-ttu-id="2d49a-126">예를 들어 `http://schemas.contoso.com/2005/05/21/PurchaseOrder` 데이터 계약은 `http://schemas.contoso.com/2005/10/14/PurchaseOrder` 데이터 계약으로 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-126">For example, the `http://schemas.contoso.com/2005/05/21/PurchaseOrder` data contract would change to the `http://schemas.contoso.com/2005/10/14/PurchaseOrder` data contract.</span></span>  
  
 [!INCLUDE[crdefault](../../../includes/crdefault-md.md)]<span data-ttu-id="2d49a-127">최선의 구현 방법: [서비스 버전 관리](../../../docs/framework/wcf/service-versioning.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-127"> Best Practices: [Service Versioning](../../../docs/framework/wcf/service-versioning.md).</span></span>  
  
 <span data-ttu-id="2d49a-128">경우에 따라 응용 프로그램이 보낸 메시지에서 엄격한 스키마 준수를 보장해야 하지만 들어오는 메시지가 엄격하게 스키마를 준수한다고 확신할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-128">Occasionally, you must guarantee strict schema compliance for messages sent by your application, but cannot rely on the incoming messages to be strictly schema-compliant.</span></span> <span data-ttu-id="2d49a-129">이 경우 들어오는 메시지에 잘못 사용된 데이터가 포함될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-129">In this case, there is a danger that an incoming message might contain extraneous data.</span></span> <span data-ttu-id="2d49a-130">잘못 사용된 값이 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)]에서 저장되고 및 반환되므로 스키마에 맞지 않는 메시지가 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-130">The extraneous values are stored and returned by [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] and thus results in schema-invalid messages being sent.</span></span> <span data-ttu-id="2d49a-131">이 문제를 방지하려면 왕복 기능을 해제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-131">To avoid this problem, the round-tripping feature should be turned off.</span></span> <span data-ttu-id="2d49a-132">이렇게 하는 데는 두 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-132">There are two ways to do this.</span></span>  
  
-   <span data-ttu-id="2d49a-133">아무 형식에도 <xref:System.Runtime.Serialization.IExtensibleDataObject> 인터페이스를 구현하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-133">Do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface on any of your types.</span></span>  
  
-   <span data-ttu-id="2d49a-134"><xref:System.ServiceModel.ServiceBehaviorAttribute> 속성을 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A>로 설정하여 `true` 특성을 서비스 계약에 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-134">Apply a <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute to your service contract with the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property set to `true`.</span></span>  
  
 [!INCLUDE[crabout](../../../includes/crabout-md.md)]<span data-ttu-id="2d49a-135">라운드트립에, 참조 [이후 버전과 호환 데이터 계약](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-135"> round-tripping, see [Forward-Compatible Data Contracts](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span>  
  
## <a name="versioning-when-schema-validation-is-not-required"></a><span data-ttu-id="2d49a-136">스키마 유효성 검사가 필요하지 않은 경우의 버전 관리</span><span class="sxs-lookup"><span data-stu-id="2d49a-136">Versioning When Schema Validation Is Not Required</span></span>  
 <span data-ttu-id="2d49a-137">엄격한 스키마 준수는 거의 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-137">Strict schema compliance is rarely required.</span></span> <span data-ttu-id="2d49a-138">많은 플랫폼에서 스키마가 설명하지 않는 추가 요소를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-138">Many platforms tolerate extra elements not described by a schema.</span></span> <span data-ttu-id="2d49a-139">기능의 전체 집합에 설명 된이 허용할 것인지,으로 [데이터 계약 버전 관리](../../../docs/framework/wcf/feature-details/data-contract-versioning.md) 및 [이후 버전과 호환 데이터 계약](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-139">As long as this is tolerated, the full set of features described in [Data Contract Versioning](../../../docs/framework/wcf/feature-details/data-contract-versioning.md) and [Forward-Compatible Data Contracts](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) can be used.</span></span> <span data-ttu-id="2d49a-140">다음 지침을 따르는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-140">The following guidelines are recommended.</span></span>  
  
 <span data-ttu-id="2d49a-141">이전 버전이 필요한 경우에 새 버전의 형식을 보내거나 새 버전이 필요한 경우에 이전 버전의 형식을 보내려면 일부 지침을 정확하게 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-141">Some of the guidelines must be followed exactly in order to send new versions of a type where an older one is expected or send an old one where the new one is expected.</span></span> <span data-ttu-id="2d49a-142">다른 지침은 엄격하게 따르지 않아도 되지만 이후 스키마 버전 관리에서 영향을 받을 수 있으므로 여기에 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-142">Other guidelines are not strictly required, but are listed here because they may be affected by the future of schema versioning.</span></span>  
  
1.  <span data-ttu-id="2d49a-143">형식 상속으로 데이터 계약의 버전을 관리하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-143">Do not attempt to version data contracts by type inheritance.</span></span> <span data-ttu-id="2d49a-144">이후 버전을 만들려면 기존 형식의 데이터 계약을 변경하거나 관련 없는 새 형식을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-144">To create later versions, either change the data contract on an existing type or create a new unrelated type.</span></span>  
  
2.  <span data-ttu-id="2d49a-145">상속이 버전 관리 메커니즘으로 사용되지 않으며 특정 규칙을 따르는 경우 데이터 계약에 상속을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-145">The use of inheritance together with data contracts is allowed, provided that inheritance is not used as a versioning mechanism and that certain rules are followed.</span></span> <span data-ttu-id="2d49a-146">형식이 특정 기본 형식에서 파생되는 경우 동일한 데이터 계약이 없으면 이후 버전에서 해당 형식이 다른 기본 형식에서 파생되게 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-146">If a type derives from a certain base type, do not make it derive from a different base type in a future version (unless it has the same data contract).</span></span> <span data-ttu-id="2d49a-147">단, 한 가지 예외가 있습니다. 데이터 계약 형식과 기본 형식 간의 계층 구조에 형식을 삽입할 수 있지만 계층 구조에 있는 가능한 모든 다른 형식 버전의 다른 멤버와 동일한 이름을 가진 데이터 멤버가 포함되지 않은 경우에만 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-147">There is one exception to this: you can insert a type into the hierarchy between a data contract type and its base type, but only if it does not contain data members with the same names as other members in any possible versions of the other types in the hierarchy.</span></span> <span data-ttu-id="2d49a-148">일반적으로 동일한 상속 계층 구조의 여러 수준에서 동일한 이름을 가진 데이터 멤버를 사용하면 심각한 버전 관리 문제가 발생할 수 있으므로 사용하지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-148">In general, using data members with the same names at different levels of the same inheritance hierarchy can lead to serious versioning problems and should be avoided.</span></span>  
  
3.  <span data-ttu-id="2d49a-149">데이터 계약의 첫 번째 버전부터 시작하여 항상 <xref:System.Runtime.Serialization.IExtensibleDataObject>를 구현하여 라운드트립을 활성화합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-149">Starting with the first version of a data contract, always implement <xref:System.Runtime.Serialization.IExtensibleDataObject> to enable round-tripping.</span></span> [!INCLUDE[crdefault](../../../includes/crdefault-md.md)]<span data-ttu-id="2d49a-150">[이후 버전과 호환 데이터 계약](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-150"> [Forward-Compatible Data Contracts](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="2d49a-151">이 인터페이스를 구현하지 않고 형식의 버전을 하나 이상 해제한 경우 형식의 다음 버전에서 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-151">If you have released one or more versions of a type without implementing this interface, implement it in the next version of the type.</span></span>  
  
4.  <span data-ttu-id="2d49a-152">이후 버전에서 데이터 계약 이름이나 네임스페이스를 변경하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-152">In later versions, do not change the data contract name or namespace.</span></span> <span data-ttu-id="2d49a-153">데이터 계약의 원본으로 사용되는 형식의 이름이나 네임스페이스를 변경하는 경우 <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>의 <xref:System.Runtime.Serialization.DataContractAttribute> 속성 같은 적절한 메커니즘을 사용하여 데이터 계약 이름과 네임스페이스를 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-153">If changing the name or namespace of the type underlying the data contract, be sure to preserve the data contract name and namespace by using the appropriate mechanisms, such as the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataContractAttribute>.</span></span> [!INCLUDE[crabout](../../../includes/crabout-md.md)]<span data-ttu-id="2d49a-154">참조 이름을 지정 [데이터 계약 이름을](../../../docs/framework/wcf/feature-details/data-contract-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-154"> naming, see [Data Contract Names](../../../docs/framework/wcf/feature-details/data-contract-names.md).</span></span>  
  
5.  <span data-ttu-id="2d49a-155">이후 버전에서 데이터 멤버의 이름을 변경하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-155">In later versions, do not change the names of any data members.</span></span> <span data-ttu-id="2d49a-156">데이터 멤버의 원본으로 사용되는 필드, 속성 또는 이벤트의 이름을 변경하는 경우 `Name`의 <xref:System.Runtime.Serialization.DataMemberAttribute> 속성을 사용하여 기존 데이터 멤버 이름을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-156">If changing the name of the field, property, or event underlying the data member, use the `Name` property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to preserve the existing data member name.</span></span>  
  
6.  <span data-ttu-id="2d49a-157">이후 버전에서 데이터 멤버의 원본으로 사용되는 필드, 속성 또는 이벤트의 형식을 변경하지 마세요. 해당 데이터 멤버의 결과 데이터 계약이 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-157">In later versions, do not change the type of any field, property, or event underlying a data member such that the resulting data contract for that data member changes.</span></span> <span data-ttu-id="2d49a-158">필요한 데이터 계약을 확인하려면 인터페이스 형식이 <xref:System.Object>와 같다는 것에 주의합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-158">Keep in mind that interface types are equivalent to <xref:System.Object> for the purposes of determining the expected data contract.</span></span>  
  
7.  <span data-ttu-id="2d49a-159">이후 버전에서 <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> 특성의 <xref:System.Runtime.Serialization.DataMemberAttribute> 속성을 조정하여 기존 데이터 멤버의 순서를 변경하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-159">In later versions, do not change the order of the existing data members by adjusting the <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute.</span></span>  
  
8.  <span data-ttu-id="2d49a-160">이후 버전에서 새 데이터 멤버를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-160">In later versions, new data members can be added.</span></span> <span data-ttu-id="2d49a-161">항상 다음 규칙을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-161">They should always follow these rules:</span></span>  
  
    1.  <span data-ttu-id="2d49a-162"><xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> 속성은 항상 기본값 `false`로 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-162">The <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property should always be left at its default value of `false`.</span></span>  
  
    2.  <span data-ttu-id="2d49a-163">멤버에 대해 기본값 `null` 또는 0을 허용할 수 없는 경우 <xref:System.Runtime.Serialization.OnDeserializingAttribute>로 콜백 메서드를 제공하여 들어오는 스트림에 멤버가 없는 경우 적절한 기본값을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-163">If a default value of `null` or zero for the member is unacceptable, a callback method should be provided using the <xref:System.Runtime.Serialization.OnDeserializingAttribute> to provide a reasonable default in case the member is not present in the incoming stream.</span></span> [!INCLUDE[crabout](../../../includes/crabout-md.md)]<span data-ttu-id="2d49a-164">콜백 참조 [버전 독립적 Serialization 콜백](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-164"> the callback, see [Version-Tolerant Serialization Callbacks](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md).</span></span>  
  
    3.  <span data-ttu-id="2d49a-165">`Order`의 `DataMemberAttribute` 속성을 사용하여 새로 추가한 모든 데이터 멤버가 기존 데이터 멤버 뒤에 나타나도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-165">The `Order` property on the `DataMemberAttribute` should be used to make sure that all of the newly added data members appear after the existing data members.</span></span> <span data-ttu-id="2d49a-166">이렇게 하려면 데이터 계약의 첫 번째 버전에서 데이터 멤버의 `Order` 속성을 설정하지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-166">The recommended way of doing this is as follows: None of the data members in the first version of the data contract should have their `Order` property set.</span></span> <span data-ttu-id="2d49a-167">데이터 계약의 버전 2에서 추가된 모든 데이터 멤버의 `Order` 속성을 2로 설정해야 하며</span><span class="sxs-lookup"><span data-stu-id="2d49a-167">All of the data members added in version 2 of the data contract should have their `Order` property set to 2.</span></span> <span data-ttu-id="2d49a-168">데이터 계약의 버전 3에서 추가된 모든 데이터 멤버의 `Order` 속성을 3으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-168">All of the data members added in version 3 of the data contract should have their `Order` set to 3, and so on.</span></span> <span data-ttu-id="2d49a-169">둘 이상의 데이터 멤버를 동일한 `Order` 번호로 설정해도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-169">It is permissible to have more than one data member set to the same `Order` number.</span></span>  
  
9. <span data-ttu-id="2d49a-170">이전 버전에서 <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> 속성이 기본값 `false`로 설정된 경우에도 이후 버전에서 데이터 멤버를 제거하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-170">Do not remove data members in later versions, even if the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property was left at its default property of `false` in prior versions.</span></span>  
  
10. <span data-ttu-id="2d49a-171">기존 데이터 멤버의 `IsRequired` 속성을 버전 간에 변경하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-171">Do not change the `IsRequired` property on any existing data members from version to version.</span></span>  
  
11. <span data-ttu-id="2d49a-172">필수 데이터 멤버의 경우(`IsRequired`가 `true`인 경우) `EmitDefaultValue` 속성을 버전 간에 변경하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-172">For required data members (where `IsRequired` is `true`), do not change the `EmitDefaultValue` property from version to version.</span></span>  
  
12. <span data-ttu-id="2d49a-173">분기된 버전 관리 계층 구조를 만들지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-173">Do not attempt to create branched versioning hierarchies.</span></span> <span data-ttu-id="2d49a-174">즉, 이러한 지침에서 허용하는 변경 내용만 사용하여 특정 버전에서 다른 버전으로 적어도 한 방향의 경로가 항상 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-174">That is, there should always be a path in at least one direction from any version to any other version using only the changes permitted by these guidelines.</span></span>  
  
     <span data-ttu-id="2d49a-175">예를 들어 Person 데이터의 버전 1에 Name 데이터 멤버만 포함된 경우 Age 멤버만 추가하여 계약의 2a 버전과 Address 멤버만 추가하여 2b 버전을 만들면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-175">For example, if version 1 of a Person data contract contains only the Name data member, you should not create version 2a of the contract adding only the Age member and version 2b adding only the Address member.</span></span> <span data-ttu-id="2d49a-176">2a에서 2b로 이동하려면 Age를 제거하고 Address를 추가해야 하며, 반대 방향으로 이동하려면 Address를 제거하고 Age를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-176">Going from 2a to 2b would involve removing Age and adding Address; going in the other direction would entail removing Address and adding Age.</span></span> <span data-ttu-id="2d49a-177">멤버 제거는 이러한 지침에서 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-177">Removing members is not permitted by these guidelines.</span></span>  
  
13. <span data-ttu-id="2d49a-178">일반적으로 응용 프로그램의 새 버전에서 기존 데이터 계약 형식의 새 하위 형식을 만들면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-178">You should generally not create new subtypes of existing data contract types in a new version of your application.</span></span> <span data-ttu-id="2d49a-179">마찬가지로 Object 또는 인터페이스 형식으로 선언된 데이터 멤버 대신 사용할 새 데이터 계약을 만들면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-179">Likewise, you should not create new data contracts that are used in place of data members declared as Object or as interface types.</span></span> <span data-ttu-id="2d49a-180">이전 응용 프로그램의 모든 인스턴스의 알려진 형식 목록에 새 형식을 추가할 수 있는 경우에만 이러한 새 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-180">Creating these new classes is allowed only when you know that you can add the new types to the known types list of all instances of your old application.</span></span> <span data-ttu-id="2d49a-181">예를 들어 응용 프로그램의 버전 1에서는 Book 및 Newspaper 데이터 계약 하위 형식이 포함된 LibraryItem 데이터 계약 형식이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-181">For example, in version 1 of your application, you may have the LibraryItem data contract type with the Book and Newspaper data contract subtypes.</span></span> <span data-ttu-id="2d49a-182">LibraryItem은 Book 및 Newspaper를 포함하는 알려진 형식 목록을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-182">LibraryItem would then have a known types list that contains Book and Newspaper.</span></span> <span data-ttu-id="2d49a-183">이제 LibraryItem의 하위 형식인 Magazine 형식을 버전 2에 추가한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-183">Suppose you now add a Magazine type in version 2 which is a subtype of LibraryItem.</span></span> <span data-ttu-id="2d49a-184">Magazine 인스턴스를 버전 2에서 버전 1로 보내는 경우 Magazine 데이터 계약이 알려진 형식 목록에 없으며 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-184">If you send a Magazine instance from version 2 to version 1, the Magazine data contract is not found in the list of known types and an exception is thrown.</span></span>  
  
14. <span data-ttu-id="2d49a-185">버전 간에 열거형 멤버를 추가하거나 제거하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-185">You should not add or remove enumeration members between versions.</span></span> <span data-ttu-id="2d49a-186">또한 `EnumMemberAttribute` 특성의 Name 속성을 사용하여 데이터 계약 모델의 이름을 동일하게 유지하지 않는 한 열거형 멤버의 이름을 바꾸면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-186">You should also not rename enumeration members, unless you use the Name property on the `EnumMemberAttribute` attribute to keep their names in the data contract model the same.</span></span>  
  
15. <span data-ttu-id="2d49a-187">컬렉션은 데이터 계약 모델에 설명 된 대로 서로 전환이 가능 [데이터 계약의 컬렉션 형식](../../../docs/framework/wcf/feature-details/collection-types-in-data-contracts.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-187">Collections are interchangeable in the data contract model as described in [Collection Types in Data Contracts](../../../docs/framework/wcf/feature-details/collection-types-in-data-contracts.md).</span></span> <span data-ttu-id="2d49a-188">이 경우 유연성이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-188">This allows for a great degree of flexibility.</span></span> <span data-ttu-id="2d49a-189">그러나 버전 간에 상호 교환할 수 없는 방식으로 컬렉션 형식을 실수로 변경하지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-189">However, make sure that you do not inadvertently change a collection type in a non-interchangeable way from version to version.</span></span> <span data-ttu-id="2d49a-190">예를 들어 사용자 지정되지 않은 컬렉션(즉, `CollectionDataContractAttribute` 특성이 없는 컬렉션)에서 사용자 지정 컬렉션으로 변경하거나 그 반대로 변경하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-190">For example, do not change from a non-customized collection (that is, without the `CollectionDataContractAttribute` attribute) to a customized one or a customized collection to a non-customized one.</span></span> <span data-ttu-id="2d49a-191">또한 버전 간에 `CollectionDataContractAttribute`의 속성을 변경하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2d49a-191">Also, do not change the properties on the `CollectionDataContractAttribute` from version to version.</span></span> <span data-ttu-id="2d49a-192">허용되는 유일한 변경은 내장 컬렉션 형식의 이름 또는 네임스페이스가 변경되었으며 데이터 계약 이름과 네임스페이스를 이전 버전과 동일하게 만들어야 하는 경우의 Name 또는 Namespace 속성 추가입니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-192">The only allowed change is adding a Name or Namespace property if the underlying collection type's name or namespace has changed and you need to make its data contract name and namespace the same as in a previous version.</span></span>  
  
 <span data-ttu-id="2d49a-193">특별한 경우 여기에 나열된 일부 지침을 무시해도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-193">Some of the guidelines listed here can be safely ignored when special circumstances apply.</span></span> <span data-ttu-id="2d49a-194">지침을 벗어나기 전에 관련된 serialization, deserialization 및 스키마 메커니즘을 완전히 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d49a-194">Make sure you fully understand the serialization, deserialization, and schema mechanisms involved before deviating from the guidelines.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2d49a-195">참고 항목</span><span class="sxs-lookup"><span data-stu-id="2d49a-195">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>  
 <xref:System.Runtime.Serialization.DataContractAttribute>  
 <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>  
 <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>  
 <xref:System.Runtime.Serialization.IExtensibleDataObject>  
 <xref:System.ServiceModel.ServiceBehaviorAttribute>  
 <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>  
 <xref:System.Runtime.Serialization.ExtensionDataObject>  
 <xref:System.Runtime.Serialization.OnDeserializingAttribute>  
 [<span data-ttu-id="2d49a-196">데이터 계약 사용</span><span class="sxs-lookup"><span data-stu-id="2d49a-196">Using Data Contracts</span></span>](../../../docs/framework/wcf/feature-details/using-data-contracts.md)  
 [<span data-ttu-id="2d49a-197">데이터 계약 버전 관리</span><span class="sxs-lookup"><span data-stu-id="2d49a-197">Data Contract Versioning</span></span>](../../../docs/framework/wcf/feature-details/data-contract-versioning.md)  
 [<span data-ttu-id="2d49a-198">데이터 계약 이름</span><span class="sxs-lookup"><span data-stu-id="2d49a-198">Data Contract Names</span></span>](../../../docs/framework/wcf/feature-details/data-contract-names.md)  
 [<span data-ttu-id="2d49a-199">이후 버전과 호환 데이터 계약</span><span class="sxs-lookup"><span data-stu-id="2d49a-199">Forward-Compatible Data Contracts</span></span>](../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)  
 [<span data-ttu-id="2d49a-200">버전 독립적 Serialization 콜백</span><span class="sxs-lookup"><span data-stu-id="2d49a-200">Version-Tolerant Serialization Callbacks</span></span>](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)

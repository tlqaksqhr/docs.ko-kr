---
title: 리소스 사용 제어 및 성능 향상
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 9a829669-5f76-4c88-80ec-92d0c62c0660
caps.latest.revision: 18
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: 6e864e0a90dbb46f440e2eba2b676413c72e0da9
ms.sourcegitcommit: 94d33cadc5ff81d2ac389bf5f26422c227832052
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/30/2018
---
# <a name="controlling-resource-consumption-and-improving-performance"></a><span data-ttu-id="8422c-102">리소스 사용 제어 및 성능 향상</span><span class="sxs-lookup"><span data-stu-id="8422c-102">Controlling Resource Consumption and Improving Performance</span></span>
<span data-ttu-id="8422c-103">이 항목에서는 리소스 사용을 제어하고 성능 메트릭에 영향을 주는 [!INCLUDE[indigo1](../../../includes/indigo1-md.md)] 아키텍처의 다른 영역에 있는 여러 속성에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-103">This topic describes various properties in different areas of the [!INCLUDE[indigo1](../../../includes/indigo1-md.md)] architecture that work to control resource consumption and affect performance metrics.</span></span>  
  
## <a name="properties-that-constrain-resource-consumption-in-wcf"></a><span data-ttu-id="8422c-104">WCF에서 리소스 사용을 제한하는 속성</span><span class="sxs-lookup"><span data-stu-id="8422c-104">Properties that Constrain Resource Consumption in WCF</span></span>  
 [!INCLUDE[indigo1](../../../includes/indigo1-md.md)]<span data-ttu-id="8422c-105">에서는 보안이나 성능 향상을 위해 특정 유형의 프로세스에 제약 조건을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-105"> applies constraints on certain types of processes for either security or performance purposes.</span></span> <span data-ttu-id="8422c-106">이러한 제약 조건은 할당량이나 스로틀 같은 두 가지 기본 형태로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-106">These constraints come in two main forms, either quotas and throttles.</span></span> <span data-ttu-id="8422c-107">*할당량* 은 도달 또는 초과 시 시스템의 일부 지점에서 즉각적인 예외를 발생 시키는 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-107">*Quotas* are limits that when reached or exceeded trigger an immediate exception at some point in the system.</span></span> <span data-ttu-id="8422c-108">*스로틀* 제한이 즉시 발생 시키는 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-108">*Throttles* are limits that do not immediately cause an exception to be thrown.</span></span> <span data-ttu-id="8422c-109">대신 스로틀 한계에 도달하면 프로세스는 해당 스로틀 값으로 설정된 한계 내에서만 계속 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-109">Instead, when a throttle limit is reached, processing continues but within the limits set by that throttle value.</span></span> <span data-ttu-id="8422c-110">이러한 제한된 처리로 다른 위치에 예외가 트리거될 수 있지만, 응용 프로그램에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-110">This limited processing might trigger an exception elsewhere, but this depends upon the application.</span></span>  
  
 <span data-ttu-id="8422c-111">할당량과 스로틀 간의 차이 외에도 제약 속성 중 일부는 serialization 수준에, 일부는 전송 수준에, 일부는 응용 프로그램 수준에 있는 등 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-111">In addition to the distinction between quotas and throttles, some constraining properties are located at the serialization level, some at the transport level, and some at the application level.</span></span> <span data-ttu-id="8422c-112">예를 들어, 모든 시스템 제공 전송 바인딩 요소에 의해 구현되는 할당량인 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A?displayProperty=nameWithType>는 악의적인 클라이언트가 메모리를 과도하게 사용하여 서비스에 대한 서비스 거부 공격을 하지 못하도록 기본적으로 65,536바이트로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-112">For example, the quota <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A?displayProperty=nameWithType>, which is implemented by all system-supplied transport binding elements, is set to 65,536 bytes by default to hinder malicious clients from engaging in denial-of-service attacks against a service by causing excessive memory consumption.</span></span> <span data-ttu-id="8422c-113">일반적으로 이 값을 낮추면 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-113">(Typically, you can increase performance by lowering this value.)</span></span>  
  
 <span data-ttu-id="8422c-114">serialization 할당량의 예로는 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> 속성이 있으며, 이 속성은 serializer가 단일 <xref:System.Runtime.Serialization.DataContractSerializer.ReadObject%2A> 메서드 호출에서 serialize하거나 deserialize하는 최대 개체 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-114">An example of a serialization quota is the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> property, which specifies the maximum number of objects that the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.DataContractSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="8422c-115">응용 프로그램 수준 스로틀의 예로는 <xref:System.ServiceModel.Dispatcher.ServiceThrottle.MaxConcurrentSessions%2A?displayProperty=nameWithType> 속성이 있으며, 기본적으로 이 속성은 동시 세션 채널 연결의 수를 10으로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-115">An example of an application-level throttle is the <xref:System.ServiceModel.Dispatcher.ServiceThrottle.MaxConcurrentSessions%2A?displayProperty=nameWithType> property, which by default restricts the number of concurrent sessionful channel connections to 10.</span></span> <span data-ttu-id="8422c-116">할당량과 달리 스로틀 값에 도달하면 응용 프로그램에서는 처리를 계속 수행하지만 새 세션 채널을 허용하지는 않습니다. 따라서 다른 세션 채널 중 하나가 종료될 때까지 새 클라이언트에 연결되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-116">(Unlike the quotas, if this throttle value is reached, the application continues processing but accepts no new sessionful channels, which means that new clients cannot connect until one of the other sessionful channels is ended.)</span></span>  
  
 <span data-ttu-id="8422c-117">이러한 제어는 특정 유형의 공격에 대해 즉각적인 완화를 제공하거나 메모리 사용 공간, 시작 시간 등과 같은 성능 메트릭을 향상하기 위해 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-117">These controls are designed to provide an out-of-the-box mitigation against certain types of attacks or to improve performance metrics such as memory footprint, start-up time, and so on.</span></span> <span data-ttu-id="8422c-118">그러나 응용 프로그램에 따라 이러한 제어로 인해 서비스 응용 프로그램 성능이 저하되거나 응용 프로그램이 전혀 작동하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-118">However, depending on the application, these controls can impede service application performance or prevent the application from working at all.</span></span> <span data-ttu-id="8422c-119">예를 들어, 비디오 스트리밍을 위해 개발된 응용 프로그램은 기본 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A?displayProperty=nameWithType> 속성을 쉽게 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-119">For example, an application designed to stream video can easily exceed the default <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8422c-120">이 항목에서는 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)]의 모든 수준에서 응용 프로그램에 적용되는 여러 제어에 대해 간략하게 설명하며, 설정으로 인해 응용 프로그램의 성능이 저하되는지 여부에 대한 자세한 정보를 가져오는 다양한 방법 및 여러 문제를 해결하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-120">This topic provides an overview of the various controls applied to applications at all levels of [!INCLUDE[indigo2](../../../includes/indigo2-md.md)], describes various ways to obtain more information about whether a setting is hindering your application, and describes ways to correct various problems.</span></span> <span data-ttu-id="8422c-121">기본 속성이 serialization이나 전송 제약 조건이더라도 응용 프로그램 수준에서 대부분의 스로틀 및 일부 할당량을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-121">Most throttles and some quotas are available at the application level, even when the base property is a serialization or transport constraint.</span></span> <span data-ttu-id="8422c-122">예를 들어, 서비스 클래스의 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> 속성을 사용하여 <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-122">For example, you can set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> property using the <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> property on the service class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8422c-123">먼저 읽어야 하는 경우 특정 문제를가 [WCF 문제 해결 퀵 스타트](../../../docs/framework/wcf/wcf-troubleshooting-quickstart.md) 문제 (및 솔루션)을 있습니다 나열 되어 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-123">If you have a particular problem, you should first read the [WCF Troubleshooting Quickstart](../../../docs/framework/wcf/wcf-troubleshooting-quickstart.md) to see whether your problem (and a solution) is listed there.</span></span>  
  
 <span data-ttu-id="8422c-124">Serialization 프로세스를 제한 하는 속성은 나열 [데이터에 대 한 보안 고려 사항](../../../docs/framework/wcf/feature-details/security-considerations-for-data.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-124">Properties that restrict serialization processes are listed in [Security Considerations for Data](../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span> <span data-ttu-id="8422c-125">전송에 관련 된 리소스 사용을 제한 하는 속성에 나열 된 [전송 할당량](../../../docs/framework/wcf/feature-details/transport-quotas.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-125">Properties that restrict the consumption of resources related to transports are listed in [Transport Quotas](../../../docs/framework/wcf/feature-details/transport-quotas.md).</span></span> <span data-ttu-id="8422c-126">응용 프로그램 계층에서 리소스 사용을 제한하는 속성은 <xref:System.ServiceModel.Dispatcher.ServiceThrottle> 클래스의 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-126">Properties that restrict the consumption of resources at the application layer are the members of the <xref:System.ServiceModel.Dispatcher.ServiceThrottle> class.</span></span>  
  
## <a name="detecting-application-and-performance-issues-related-to-quota-settings"></a><span data-ttu-id="8422c-127">할당량 설정과 관련된 응용 프로그램 및 성능 문제 검색</span><span class="sxs-lookup"><span data-stu-id="8422c-127">Detecting Application and Performance Issues Related to Quota Settings</span></span>  
 <span data-ttu-id="8422c-128">일반적인 보안 문제에 대해 기본 보호를 제공하면서 다양한 종류의 응용 프로그램에서 기본 응용 프로그램 기능을 사용할 수 있도록 이전 기본값이 선택되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-128">The defaults of the preceding values have been chosen to enable basic application functionality across a wide range of application types while providing basic protection against common security issues.</span></span> <span data-ttu-id="8422c-129">그러나 응용 프로그램이 안전하고 개발된 대로 작동하더라도 다른 응용 프로그램 디자인에서 하나 이상의 스로틀 설정을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-129">However, different application designs might exceed one or more throttle settings although the application otherwise is secure and would work as designed.</span></span> <span data-ttu-id="8422c-130">이러한 경우 어떤 수준에서 어떤 스로틀 값이 초과되었는지 식별하여 응용 프로그램 처리량을 늘리기 위해 수행할 적합한 작업을 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-130">In these cases, you must identify which throttle values are being exceeded and at what level, and decide on the appropriate course of action to increase application throughput.</span></span>  
  
 <span data-ttu-id="8422c-131">일반적으로 응용 프로그램을 작성하고 이를 디버깅할 때 구성 파일에서 또는 프로그래밍 방식으로 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 속성을 `true`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-131">Typically, when writing the application and debugging it, you set the <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property to `true` in the configuration file or programmatically.</span></span> <span data-ttu-id="8422c-132">그러면 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)]에서 서비스 예외 스택 추적을 볼 수 있도록 클라이언트 응용 프로그램에 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-132">This instructs [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] to return service exception stack traces to the client application for viewing.</span></span> <span data-ttu-id="8422c-133">이 기능은 관련이 있을 수 있는 할당량 설정을 표시하는 방식으로(이 설정이 문제인 경우) 대부분의 응용 프로그램 수준 예외를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-133">This feature reports most application-level exceptions in such a way as to display which quota settings might be involved, if that is the problem.</span></span>  
  
 <span data-ttu-id="8422c-134">일부 예외는 런타임에 응용 프로그램 계층의 표시 범위 아래에서 발생하고, 이 메커니즘을 사용하여 반환되지 않으며, 사용자 지정 <xref:System.ServiceModel.Dispatcher.IErrorHandler?displayProperty=nameWithType> 구현에 의해 처리될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-134">Some exceptions happen at run time below the visibility of the application layer and are not returned using this mechanism, and they might not be handled by a custom <xref:System.ServiceModel.Dispatcher.IErrorHandler?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="8422c-135">Microsoft Visual Studio와 같은 개발 환경을 사용하는 경우 이러한 예외의 대부분이 자동으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-135">If you are in a development environment like Microsoft Visual Studio, most of these exceptions are displayed automatically.</span></span> <span data-ttu-id="8422c-136">그러나와 같은 개발 환경 설정에 따라 몇 가지 예외를 마스크 될 수 있습니다는 [내 코드만](http://go.microsoft.com/fwlink/?LinkId=82174) Visual Studio 2005에서 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-136">However, some exceptions can be masked by development environment settings such as the [Just My Code](http://go.microsoft.com/fwlink/?LinkId=82174) settings in Visual Studio 2005.</span></span>  
  
 <span data-ttu-id="8422c-137">개발 환경의 기능과 관계없이 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] 추적 및 메시지 로깅 기능을 사용하여 모든 예외를 디버깅하고 응용 프로그램의 성능을 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-137">Regardless of the capabilities of your development environment, you can use capabilities of [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] tracing and message logging to debug all exceptions and tune the performance of your applications.</span></span> <span data-ttu-id="8422c-138">자세한 내용은 참조 [응용 프로그램 문제를 해결 하려면 추적 사용 하 여](../../../docs/framework/wcf/diagnostics/tracing/using-tracing-to-troubleshoot-your-application.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-138">For more information, see [Using Tracing to Troubleshoot Your Application](../../../docs/framework/wcf/diagnostics/tracing/using-tracing-to-troubleshoot-your-application.md).</span></span>  
  
## <a name="performance-issues-and-xmlserializer"></a><span data-ttu-id="8422c-139">성능 문제 및 XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="8422c-139">Performance Issues and XmlSerializer</span></span>  
 <span data-ttu-id="8422c-140"><xref:System.Xml.Serialization.XmlSerializer>를 사용하여 serialize할 수 있는 데이터 형식을 사용하는 서비스 및 클라이언트 응용 프로그램은 런타임에 해당 데이터 형식에 대한 serialization 코드를 생성하고 컴파일합니다. 이로 인해 시작 시 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-140">Services and client applications that use data types that are serializable using the <xref:System.Xml.Serialization.XmlSerializer> generate and compile serialization code for those data types at run time, which can result in slow start-up performance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8422c-141">미리 생성된 serialization 코드는 서비스가 아닌 클라이언트 응용 프로그램에서만 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-141">Pre-generated serialization code can be used only in client applications and not in services.</span></span>  
  
 <span data-ttu-id="8422c-142">[ServiceModel Metadata 유틸리티 도구 (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) 응용 프로그램에 대해 컴파일된 어셈블리에서 필요한 serialization 코드를 생성 하 여 이러한 응용 프로그램의 시작 성능을 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-142">The [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) can improve start-up performance for these applications by generating the necessary serialization code from the compiled assemblies for the application.</span></span> <span data-ttu-id="8422c-143">자세한 내용은 참조 [하는 방법: 시작 시간의 WCF 클라이언트 응용 프로그램 XmlSerializer를 사용 하 여 개선](../../../docs/framework/wcf/feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-143">For more information, see [How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer](../../../docs/framework/wcf/feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md).</span></span>  
  
## <a name="performance-issues-when-hosting-wcf-services-under-aspnet"></a><span data-ttu-id="8422c-144">WCF 서비스를 ASP.NET 호스팅할 때의 성능 문제</span><span class="sxs-lookup"><span data-stu-id="8422c-144">Performance Issues When Hosting WCF Services Under ASP.NET</span></span>  
 <span data-ttu-id="8422c-145">WCF 서비스를 IIS 및 ASP.NET에 호스팅하는 경우 IIS 및 ASP.NET의 구성 설정이 WCF 서비스의 처리량 및 메모리 사용 공간에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-145">When a WCF service is hosted under IIS and ASP.NET, the configuration settings of IIS and ASP.NET can affect the throughput and memory footprint of the WCF service.</span></span>  <span data-ttu-id="8422c-146">ASP.NET 성능에 대 한 자세한 내용은 참조 [ASP.NET 성능 향상](http://go.microsoft.com/fwlink/?LinkId=186462)합니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-146">For more information about ASP.NET performance, see [Improving ASP.NET Performance](http://go.microsoft.com/fwlink/?LinkId=186462).</span></span>  <span data-ttu-id="8422c-147">예상치 않은 결과를 일으킬 수 있는 설정 중 하나는 <xref:System.Web.Configuration.ProcessModelSection.MinWorkerThreads%2A>의 속성인 <xref:System.Web.Configuration.ProcessModelSection>입니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-147">One setting that might have unintended consequences is <xref:System.Web.Configuration.ProcessModelSection.MinWorkerThreads%2A>, which is a property of the <xref:System.Web.Configuration.ProcessModelSection>.</span></span> <span data-ttu-id="8422c-148">응용 프로그램의 클라이언트 수가 고정되어 있거나 적은 경우 <xref:System.Web.Configuration.ProcessModelSection.MinWorkerThreads%2A>를 2로 설정하면 다중 프로세서 컴퓨터에서 처리량이 크게 높아져 CPU 사용률이 100%에 가깝게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-148">If your application has a fixed or small number of clients, setting <xref:System.Web.Configuration.ProcessModelSection.MinWorkerThreads%2A> to 2 might provide a throughput boost on a multiprocessor machine that has a CPU utilization close to 100%.</span></span> <span data-ttu-id="8422c-149">이러한 성능 증가는 비용을 초래합니다. 또한 메모리 사용량도 증가하여 확장성이 저하됩니다.</span><span class="sxs-lookup"><span data-stu-id="8422c-149">This increase in performance comes with a cost: it will also cause an increase in memory usage, which could reduce scalability.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8422c-150">참고 항목</span><span class="sxs-lookup"><span data-stu-id="8422c-150">See Also</span></span>  
 [<span data-ttu-id="8422c-151">관리 및 진단</span><span class="sxs-lookup"><span data-stu-id="8422c-151">Administration and Diagnostics</span></span>](../../../docs/framework/wcf/diagnostics/index.md)  
 [<span data-ttu-id="8422c-152">큰 데이터 및 스트리밍</span><span class="sxs-lookup"><span data-stu-id="8422c-152">Large Data and Streaming</span></span>](../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)

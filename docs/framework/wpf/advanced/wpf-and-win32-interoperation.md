---
title: "WPF 및 Win32 상호 운용성"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- hosting WPF content in Win32 window [WPF]
- HWND interop [WPF]
- Win32 code [WPF], WPF interoperation
- interoperability [WPF], Win32
ms.assetid: 0ffbde0d-701d-45a3-a6fa-dd71f4d9772e
caps.latest.revision: "26"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 6ff6e008c95844388930a505caacbaf6d407edd1
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="wpf-and-win32-interoperation"></a><span data-ttu-id="31606-102">WPF 및 Win32 상호 운용성</span><span class="sxs-lookup"><span data-stu-id="31606-102">WPF and Win32 Interoperation</span></span>
<span data-ttu-id="31606-103">이 항목에서는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 및 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 코드를 상호 운용하는 방법을 개괄적으로 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-103">This topic provides an overview of how to interoperate [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] code.</span></span> [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="31606-104">에서는 응용 프로그램을 만들기 위한 다양한 환경을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-104"> provides a rich environment for creating applications.</span></span> <span data-ttu-id="31606-105">그러나 [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] 코드에 상당한 투자를 한 경우 해당 코드 중 일부를 재사용하는 것이 더욱 효과적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-105">However, when you have a substantial investment in [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] code, it might be more effective to reuse some of that code.</span></span>  
  

  
<a name="basics"></a>   
## <a name="wpf-and-win32-interoperation-basics"></a><span data-ttu-id="31606-106">WPF 및 Win32 상호 운용성 기본 사항</span><span class="sxs-lookup"><span data-stu-id="31606-106">WPF and Win32 Interoperation Basics</span></span>  
 <span data-ttu-id="31606-107">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]와 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 코드 간에는 상호 운용성에 대한 두 가지 기본 기법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-107">There are two basic techniques for interoperation between [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] code.</span></span>  
  
-   <span data-ttu-id="31606-108">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 창에서 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠를 호스팅합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-108">Host [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content in a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window.</span></span> <span data-ttu-id="31606-109">이 기법을 사용하면 표준 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 창 및 응용 프로그램의 프레임워크 내에서 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]의 고급 그래픽 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-109">With this technique, you can use the advanced graphics capabilities of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] within the framework of a standard [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window and application.</span></span>  
  
-   <span data-ttu-id="31606-110">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠에서 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 창을 호스트합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-110">Host a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content.</span></span> <span data-ttu-id="31606-111">이 기법을 사용하면 다른 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠의 컨텍스트에서 기존 사용자 지정 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 컨트롤을 사용하고 경계 간에 데이터를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-111">With this technique, you can use an existing custom [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] control in the context of other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content, and pass data across the boundaries.</span></span>  
  
 <span data-ttu-id="31606-112">이 항목에서는 이러한 각 기법을 개념적인 측면에서 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-112">Each of these techniques is conceptually introduced in this topic.</span></span> <span data-ttu-id="31606-113">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]에서 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]를 호스트하는 작업에 대한 자세한 코드 기반 설명은 [연습: Win32에서 WPF 콘텐츠 호스팅](../../../../docs/framework/wpf/advanced/walkthrough-hosting-wpf-content-in-win32.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="31606-113">For a more code-oriented illustration of hosting [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] in [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)], see [Walkthrough: Hosting WPF Content in Win32](../../../../docs/framework/wpf/advanced/walkthrough-hosting-wpf-content-in-win32.md).</span></span> <span data-ttu-id="31606-114">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에서 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]를 호스트하는 자세한 코드 중심 그림은 [연습: WPF에서 Win32 컨트롤 호스팅](../../../../docs/framework/wpf/advanced/walkthrough-hosting-a-win32-control-in-wpf.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="31606-114">For a more code-oriented illustration of hosting [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [Walkthrough: Hosting a Win32 Control in WPF](../../../../docs/framework/wpf/advanced/walkthrough-hosting-a-win32-control-in-wpf.md).</span></span>  
  
<a name="projects"></a>   
## <a name="wpf-interoperation-projects"></a><span data-ttu-id="31606-115">WPF 상호 운용 프로젝트</span><span class="sxs-lookup"><span data-stu-id="31606-115">WPF Interoperation Projects</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="31606-116"> [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]는 관리 코드이지만, 대부분의 기존 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 프로그램은 관리되지 않는 [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)]로 작성됩니다.</span><span class="sxs-lookup"><span data-stu-id="31606-116"> [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] are managed code, but most existing [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] programs are written in unmanaged [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)].</span></span>  <span data-ttu-id="31606-117">완전히 관리되지 않는 프로그램에서는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]를 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-117">You cannot call [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] from a true unmanaged program.</span></span> <span data-ttu-id="31606-118">그러나 `/clr` 옵션을 [!INCLUDE[TLA#tla_visualcpp](../../../../includes/tlasharptla-visualcpp-md.md)] 컴파일러와 함께 사용하면 혼합 관리-비관리 프로그램을 만들 수 있습니다. 이 프로그램에서는 관리 및 비관리 [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] 호출을 원활하게 혼합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-118">However, by using the `/clr` option with the [!INCLUDE[TLA#tla_visualcpp](../../../../includes/tlasharptla-visualcpp-md.md)] compiler, you can create a mixed managed-unmanaged program where you can seamlessly mix managed and unmanaged [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] calls.</span></span>  
  
 <span data-ttu-id="31606-119">이 경우 프로젝트 수준에서 한 가지 문제가 발생하는데, 바로 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] 파일을 [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)] 프로젝트로 컴파일할 수 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-119">One project-level complication is that you cannot compile [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] files into a [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)] project.</span></span>  <span data-ttu-id="31606-120">이 문제는 다음과 같은 몇 가지 프로젝트 분할 기법을 통해 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-120">There are several project division techniques to compensate for this.</span></span>  
  
-   <span data-ttu-id="31606-121">모든 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 페이지를 포함하는 [!INCLUDE[TLA2#tla_cshrp](../../../../includes/tla2sharptla-cshrp-md.md)] DLL을 컴파일된 어셈블리로 만든 다음 [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)] 실행 파일에 해당 [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)]을 참조로 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-121">Create a [!INCLUDE[TLA2#tla_cshrp](../../../../includes/tla2sharptla-cshrp-md.md)] DLL that contains all your [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] pages as a compiled assembly, and then have your [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)] executable include that [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)] as a reference.</span></span>  
  
-   <span data-ttu-id="31606-122">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠의 [!INCLUDE[TLA2#tla_cshrp](../../../../includes/tla2sharptla-cshrp-md.md)] 실행 파일을 만들고 이 파일에서 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 콘텐츠를 포함하는 [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)] [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)]를 참조하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-122">Create a [!INCLUDE[TLA2#tla_cshrp](../../../../includes/tla2sharptla-cshrp-md.md)] executable for the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content, and have it reference a [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)] [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)] that contains the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] content.</span></span>  
  
-   <span data-ttu-id="31606-123">사용 하 여 <xref:System.Windows.Markup.XamlReader.Load%2A> 로드할 모든 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 컴파일하는 대신 런타임 시 프로그램 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-123">Use <xref:System.Windows.Markup.XamlReader.Load%2A> to load any [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] at run time, instead of compiling your [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>  
  
-   <span data-ttu-id="31606-124">사용 하지 마십시오 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] , 모든 프로그램 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 에서 요소 트리를 작성 하는 코드에서 <xref:System.Windows.Application>합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-124">Do not use [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] at all, and write all your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] in code, building up the element tree from <xref:System.Windows.Application>.</span></span>  
  
 <span data-ttu-id="31606-125">가장 적합한 방법을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="31606-125">Use whatever approach works best for you.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31606-126">전에 [!INCLUDE[TLA#tla_cppcli](../../../../includes/tlasharptla-cppcli-md.md)]를 사용한 적이 없는 경우 상호 운용 코드 예에 `gcnew` 및 `nullptr`과 같은 “새” 키워드가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="31606-126">If you have not used [!INCLUDE[TLA#tla_cppcli](../../../../includes/tlasharptla-cppcli-md.md)] before, you might notice some "new" keywords such as `gcnew` and `nullptr` in the interoperation code examples.</span></span> <span data-ttu-id="31606-127">이러한 키워드는 밑줄이 두 개인 이전 구문(`__gc`)을 대체하고 [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)]의 관리 코드에 대해 좀 더 자연스러운 구문을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-127">These keywords supersede the older double-underscore syntax (`__gc`) and provide a more natural syntax for managed code in [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)].</span></span>  <span data-ttu-id="31606-128">[!INCLUDE[TLA#tla_cppcli](../../../../includes/tlasharptla-cppcli-md.md)] 관리 기능에 대해 자세히 알아보려면 [런타임 플랫폼의 구성 요소 확장](/cpp/windows/component-extensions-for-runtime-platforms) 및 [Hello, C++/CLI](http://go.microsoft.com/fwlink/?LinkId=98739)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="31606-128">To learn more about the [!INCLUDE[TLA#tla_cppcli](../../../../includes/tlasharptla-cppcli-md.md)] managed features, see [Component Extensions for Runtime Platforms](/cpp/windows/component-extensions-for-runtime-platforms) and [Hello, C++/CLI](http://go.microsoft.com/fwlink/?LinkId=98739).</span></span>  
  
<a name="hwnds"></a>   
## <a name="how-wpf-uses-hwnds"></a><span data-ttu-id="31606-129">WPF에서 HWND를 사용하는 방법</span><span class="sxs-lookup"><span data-stu-id="31606-129">How WPF Uses Hwnds</span></span>  
 <span data-ttu-id="31606-130">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] "HWND interop"를 최대한 활용하려면 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에서 HWND를 사용하는 방법을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-130">To make the most of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] "HWND interop", you need to understand how [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses HWNDs.</span></span> <span data-ttu-id="31606-131">어떠한 HWND의 경우에도 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 렌더링과 [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] 렌더링 또는 [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] / [!INCLUDE[TLA2#tla_gdiplus](../../../../includes/tla2sharptla-gdiplus-md.md)] 렌더링을 혼합할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-131">For any HWND, you cannot mix [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] rendering with [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] rendering or [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] / [!INCLUDE[TLA2#tla_gdiplus](../../../../includes/tla2sharptla-gdiplus-md.md)] rendering.</span></span> <span data-ttu-id="31606-132">여기에는 여러 가지 의미가 내포되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-132">This has a number of implications.</span></span> <span data-ttu-id="31606-133">기본적으로 이러한 렌더링 모델을 혼합하려면 상호 운용 솔루션을 만들고, 사용하도록 선택하는 각 렌더링 모델에 지정된 상호 운용 세그먼트를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-133">Primarily, in order to mix these rendering models at all, you must create an interoperation solution, and use designated segments of interoperation for each rendering model that you choose to use.</span></span> <span data-ttu-id="31606-134">또한, 렌더링 동작은 상호 운용 솔루션에서 수행할 수 있는 작업에 대한 “에어스페이스” 제한 사항도 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="31606-134">Also, the rendering behavior creates an "airspace" restriction for what your interoperation solution can accomplish.</span></span> <span data-ttu-id="31606-135">“에어스페이스” 개념은 [기술 영역 개요](../../../../docs/framework/wpf/advanced/technology-regions-overview.md) 항목에 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-135">The "airspace" concept is explained in greater detail in the topic [Technology Regions Overview](../../../../docs/framework/wpf/advanced/technology-regions-overview.md).</span></span>  
  
 <span data-ttu-id="31606-136">화면의 모든 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 요소는 궁극적으로 HWND를 통해 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="31606-136">All [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] elements on the screen are ultimately backed by a HWND.</span></span> <span data-ttu-id="31606-137">만들 때는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Window>, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 최상위 HWND를 만들고 사용 하는 <xref:System.Windows.Interop.HwndSource> 배치 하는 <xref:System.Windows.Window> 및 해당 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] HWND 내부 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-137">When you create a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Window>, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] creates a top-level HWND, and uses an <xref:System.Windows.Interop.HwndSource> to put the <xref:System.Windows.Window> and its [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content inside the HWND.</span></span>  <span data-ttu-id="31606-138">응용 프로그램의 나머지 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠에서 이 단일 HWND를 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-138">The rest of your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content in the application shares that singular HWND.</span></span> <span data-ttu-id="31606-139">예외는 메뉴, 콤보 상자 드롭다운 및 기타 팝업입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-139">An exception is menus, combo box drop downs, and other pop-ups.</span></span> <span data-ttu-id="31606-140">이러한 요소는 고유한 최상위 창을 만듭니다. 따라서 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 메뉴가 포함된 창 HWND의 가장자리를 넘어 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-140">These elements create their own top-level window, which is why a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] menu can potentially go past the edge of the window HWND that contains it.</span></span> <span data-ttu-id="31606-141">사용 하는 경우 <xref:System.Windows.Interop.HwndHost> 내 HWND를 넣을 수 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 알립니다 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 에 새 자식 HWND 상대 위치를 지정 하는 방법의 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Window> HWND입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-141">When you use <xref:System.Windows.Interop.HwndHost> to put an HWND inside [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] informs [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] how to position the new child HWND relative to the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Window> HWND.</span></span>  
  
 <span data-ttu-id="31606-142">HWND와 관련된 개념은 각 HWND 내에서, 그리고 각 HWND 간에 투명합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-142">A related concept to HWND is transparency within and between each HWND.</span></span> <span data-ttu-id="31606-143">이 내용도 [기술 영역 개요](../../../../docs/framework/wpf/advanced/technology-regions-overview.md) 항목에서 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-143">This is also discussed in the topic [Technology Regions Overview](../../../../docs/framework/wpf/advanced/technology-regions-overview.md).</span></span>  
  
<a name="hosting_a_wpf_page"></a>   
## <a name="hosting-wpf-content-in-a-microsoft-win32-window"></a><span data-ttu-id="31606-144">Microsoft Win32 창에서 WPF 콘텐츠 호스팅</span><span class="sxs-lookup"><span data-stu-id="31606-144">Hosting WPF Content in a Microsoft Win32 Window</span></span>  
 <span data-ttu-id="31606-145">호스팅하는 데 핵심적인은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 에 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 창이 <xref:System.Windows.Interop.HwndSource> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-145">The key to hosting a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] on a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window is the <xref:System.Windows.Interop.HwndSource> class.</span></span> <span data-ttu-id="31606-146">이 클래스는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠를 자식 창으로 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]에 통합할 수 있도록 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 창에 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠를 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-146">This class wraps the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content in a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window, so that the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content can be incorporated into your [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] as a child window.</span></span> <span data-ttu-id="31606-147">다음 접근 방식은 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 및 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]를 단일 응용 프로그램에 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-147">The following approach combines the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] in a single application.</span></span>  
  
1.  <span data-ttu-id="31606-148">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠(콘텐츠 루트 요소)를 관리 클래스로 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-148">Implement your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content (the content root element) as a managed class.</span></span> <span data-ttu-id="31606-149">여러 자식 요소를 포함할 수 및/또는 같은 루트 요소로 사용 하는 클래스 중 하나에서 클래스 상속 되는 일반적으로 <xref:System.Windows.Controls.DockPanel> 또는 <xref:System.Windows.Controls.Page>합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-149">Typically, the class inherits from one of the classes that can contain multiple child elements and/or used as a root element, such as <xref:System.Windows.Controls.DockPanel> or <xref:System.Windows.Controls.Page>.</span></span> <span data-ttu-id="31606-150">후속 단계에서는 이 클래스를 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠 클래스라고 하며, 클래스 인스턴스는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠 개체라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-150">In subsequent steps, this class is referred to as the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content class, and instances of the class are referred to as [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content objects.</span></span>  
  
2.  <span data-ttu-id="31606-151">
          [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]를 사용하여 [!INCLUDE[TLA2#tla_cppcli](../../../../includes/tla2sharptla-cppcli-md.md)] 응용 프로그램을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-151">Implement a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] application with [!INCLUDE[TLA2#tla_cppcli](../../../../includes/tla2sharptla-cppcli-md.md)].</span></span> <span data-ttu-id="31606-152">기존의 관리되지 않는 [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)] 응용 프로그램으로 시작하는 경우, 일반적으로 `/clr` 컴파일러 플래그를 포함하도록 프로젝트 설정을 변경하여 이 응용 프로그램에서 관리 코드를 호출할 수 있습니다. 이 항목에서는 `/clr` 컴파일을 지원하는 데 필요한 작업에 대해 자세히 다루지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-152">If you are starting with an existing unmanaged [!INCLUDE[TLA2#tla_cpp](../../../../includes/tla2sharptla-cpp-md.md)] application, you can usually enable it to call managed code by changing your project settings to include the `/clr` compiler flag (the full scope of what might be necessary to support `/clr` compilation is not described in this topic).</span></span>  
  
3.  <span data-ttu-id="31606-153">스레딩 모델을 STA(단일 스레드 아파트)로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-153">Set the threading model to Single Threaded Apartment (STA).</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="31606-154">에서는 이 스레딩 모델을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-154"> uses this threading model.</span></span>  
  
4.  <span data-ttu-id="31606-155">창 프로시저에서 WM_CREATE 알림을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-155">Handle the WM_CREATE notification in your window procedure.</span></span>  
  
5.  <span data-ttu-id="31606-156">처리기(또는 처리기에서 호출하는 함수)에서 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-156">Within the handler (or a function that the handler calls), do the following:</span></span>  
  
    1.  <span data-ttu-id="31606-157">새 <xref:System.Windows.Interop.HwndSource> 개체와 HWND 부모 창으로 해당 `parent` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-157">Create a new <xref:System.Windows.Interop.HwndSource> object with the parent window HWND as its `parent` parameter.</span></span>  
  
    2.  <span data-ttu-id="31606-158">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠 클래스의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="31606-158">Create an instance of your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content class.</span></span>  
  
    3.  <span data-ttu-id="31606-159">할당에 대 한 참조는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠 개체는 <xref:System.Windows.Interop.HwndSource> 개체 <xref:System.Windows.Interop.HwndSource.RootVisual%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-159">Assign a reference to the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content object to the <xref:System.Windows.Interop.HwndSource> object <xref:System.Windows.Interop.HwndSource.RootVisual%2A> property.</span></span>  
  
    4.  <span data-ttu-id="31606-160"><xref:System.Windows.Interop.HwndSource> 개체 <xref:System.Windows.Interop.HwndSource.Handle%2A> 속성 창 핸들 (HWND)을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-160">The <xref:System.Windows.Interop.HwndSource> object <xref:System.Windows.Interop.HwndSource.Handle%2A> property contains the window handle (HWND).</span></span> <span data-ttu-id="31606-161">응용 프로그램의 관리되지 않는 부분에서 사용할 수 있는 HWND를 가져오려면 `Handle.ToPointer()`를 HWND로 캐스팅합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-161">To get an HWND that you can use in the unmanaged part of your application, cast `Handle.ToPointer()` to an HWND.</span></span>  
  
6.  <span data-ttu-id="31606-162">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠 개체에 대한 참조를 보유하는 정적 필드가 포함된 관리 클래스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-162">Implement a managed class that contains a static field that holds a reference to your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content object.</span></span> <span data-ttu-id="31606-163">이 클래스에 대 한 참조를 가져올 수 있습니다는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠 개체 프로그램 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 더 중요 한 것을 방지 하지만 코드를 프로그램 <xref:System.Windows.Interop.HwndSource> 실수로 가비지 수집 되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-163">This class allows you to get a reference to the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content object from your [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] code, but more importantly it prevents your <xref:System.Windows.Interop.HwndSource> from being inadvertently garbage collected.</span></span>  
  
7.  <span data-ttu-id="31606-164">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠 개체 이벤트 중 하나 이상에 처리기를 연결하여 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠 개체에서 알림을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-164">Receive notifications from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content object by attaching a handler to one or more of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content object events.</span></span>  
  
8.  <span data-ttu-id="31606-165">속성, 호출 메서드 등을 설정하기 위해 정적 필드에 저장한 참조를 사용하여 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠 개체와 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-165">Communicate with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content object by using the reference that you stored in the static field to set properties, call methods, etc.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31606-166">별도의 어셈블리를 생성한 다음 이를 참조하는 경우 콘텐츠 클래스의 기본 부분 클래스를 사용하여 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]에서 1단계용 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠 클래스 정의 중 일부 또는 모두를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-166">You can do some or all of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content class definition for Step One in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] using the default partial class of the content class, if you produce a separate assembly and then reference it.</span></span> <span data-ttu-id="31606-167">일반적으로 포함 되지만 <xref:System.Windows.Application> 개체 컴파일하는 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 를 어셈블리로 있습니다 끝나지 않는 사용 하는 <xref:System.Windows.Application> 상호 운용성의 일환으로, 하면 방금 사용에 대 한 루트 클래스 중 하나 이상을 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 참조 된 파일 응용 프로그램에서 해당 partial 클래스를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-167">Although you typically include an <xref:System.Windows.Application> object as part of compiling the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] into an assembly, you do not end up using that <xref:System.Windows.Application> as part of the interoperation, you just use one or more of the root classes for [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] files referred to by the application and reference their partial classes.</span></span> <span data-ttu-id="31606-168">프로시저의 나머지 부분은 기본적으로 위에서 설명한 것과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-168">The remainder of the procedure is essentially similar to that outlined above.</span></span>  
>   
>  <span data-ttu-id="31606-169">이러한 각 단계는 [연습: Win32에서 WPF 콘텐츠 호스팅](../../../../docs/framework/wpf/advanced/walkthrough-hosting-wpf-content-in-win32.md) 항목에서 코드를 통해 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-169">Each of these steps is illustrated through code in the topic [Walkthrough: Hosting WPF Content in Win32](../../../../docs/framework/wpf/advanced/walkthrough-hosting-wpf-content-in-win32.md).</span></span>  
  
<a name="hosting_an_hwnd"></a>   
## <a name="hosting-a-microsoft-win32-window-in-wpf"></a><span data-ttu-id="31606-170">WPF에서 Microsoft Win32 창 호스팅</span><span class="sxs-lookup"><span data-stu-id="31606-170">Hosting a Microsoft Win32 Window in WPF</span></span>  
 <span data-ttu-id="31606-171">호스팅하는 데 핵심적인은 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 다른 창을 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠는는 <xref:System.Windows.Interop.HwndHost> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-171">The key to hosting a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window within other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content is the <xref:System.Windows.Interop.HwndHost> class.</span></span> <span data-ttu-id="31606-172">이 클래스는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 요소 트리에 추가될 수 있는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 요소에 창을 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-172">This class wraps the window in a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] element which can be added to a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] element tree.</span></span> <span data-ttu-id="31606-173"><xref:System.Windows.Interop.HwndHost>또한 지원 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] 수 있는 호스트 창에 대 한 메시지를 처리 하는 등의 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-173"><xref:System.Windows.Interop.HwndHost> also supports [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that allow you to do such tasks as process messages for the hosted window.</span></span> <span data-ttu-id="31606-174">기본 절차는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-174">The basic procedure is:</span></span>  
  
1.  <span data-ttu-id="31606-175">코드 또는 태그를 통해 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 응용 프로그램의 요소 트리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="31606-175">Create an element tree for a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application (can be through code or markup).</span></span> <span data-ttu-id="31606-176">요소 트리에서 허용 되 고 적절 한 지점을 검색 위치는 <xref:System.Windows.Interop.HwndHost> 구현 자식 요소로 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-176">Find an appropriate and permissible point in the element tree where the <xref:System.Windows.Interop.HwndHost> implementation can be added as a child element.</span></span> <span data-ttu-id="31606-177">이 단계의 나머지 부분에서는 이 요소를 예약 요소라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-177">In the remainder of these steps, this element is referred to as the reserving element.</span></span>  
  
2.  <span data-ttu-id="31606-178">파생 <xref:System.Windows.Interop.HwndHost> 를 보유 하는 개체를 만들려면 프로그램 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-178">Derive from <xref:System.Windows.Interop.HwndHost> to create an object that holds your [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] content.</span></span>  
  
3.  <span data-ttu-id="31606-179">해당 호스트 클래스에서 재정의 된 <xref:System.Windows.Interop.HwndHost> 메서드 <xref:System.Windows.Interop.HwndHost.BuildWindowCore%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-179">In that host class, override the <xref:System.Windows.Interop.HwndHost> method <xref:System.Windows.Interop.HwndHost.BuildWindowCore%2A>.</span></span> <span data-ttu-id="31606-180">호스팅된 창의 HWND를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-180">Return the HWND of the hosted window.</span></span> <span data-ttu-id="31606-181">실제 컨트롤을 반환된 창의 자식 창으로 래핑해야 할 수도 있습니다. 호스트 창에서 컨트롤을 래핑하면 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 콘텐츠가 간단한 방식으로 컨트롤에서 알림을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-181">You might want to wrap the actual control(s) as a child window of the returned window; wrapping the controls in a host window provides a simple way for your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content to receive notifications from the controls.</span></span> <span data-ttu-id="31606-182">이 기법을 사용하면 호스팅된 컨트롤 경계에서 메시지 처리에 관한 일부 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 문제를 정정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-182">This technique helps correct for some [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] issues regarding message handling at the hosted control boundary.</span></span>  
  
4.  <span data-ttu-id="31606-183">재정의 <xref:System.Windows.Interop.HwndHost> 메서드 <xref:System.Windows.Interop.HwndHost.DestroyWindowCore%2A> 및 <xref:System.Windows.Interop.HwndHost.WndProc%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-183">Override the <xref:System.Windows.Interop.HwndHost> methods <xref:System.Windows.Interop.HwndHost.DestroyWindowCore%2A> and <xref:System.Windows.Interop.HwndHost.WndProc%2A>.</span></span> <span data-ttu-id="31606-184">이렇게 하는 이유는 프로세스를 정리하고 호스팅된 콘텐츠에 대한 참조를 정리하기 위해서입니다. 특히 관리되지 않는 개체의 참조를 만든 경우에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-184">The intention here is to process cleanup and remove references to the hosted content, particularly if you created references to unmanaged objects.</span></span>  
  
5.  <span data-ttu-id="31606-185">코드 숨김 파일에서 컨트롤 호스팅 클래스의 인스턴스를 만들고 예약 요소의 하위로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-185">In your code-behind file, create an instance of the control hosting class and make it a child of the reserving element.</span></span> <span data-ttu-id="31606-186">일반적으로 사용 이벤트 처리기와 같은 <xref:System.Windows.FrameworkElement.Loaded>, 또는 partial 클래스 생성자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-186">Typically you would use an event handler such as <xref:System.Windows.FrameworkElement.Loaded>, or use the partial class constructor.</span></span> <span data-ttu-id="31606-187">런타임 동작을 통해 상호 운용 콘텐츠도 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-187">But you could also add the interoperation content through a runtime behavior.</span></span>  
  
6.  <span data-ttu-id="31606-188">컨트롤 알림과 같은 선택된 창 메시지를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-188">Process selected window messages, such as control notifications.</span></span> <span data-ttu-id="31606-189">다음과 같이 두 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-189">There are two approaches.</span></span> <span data-ttu-id="31606-190">두 방법 모두 메시지 스트림에 대해 동일한 액세스 권한을 제공하므로, 프로그래밍 편리성에 따라 선택하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="31606-190">Both provide identical access to the message stream, so your choice is largely a matter of programming convenience.</span></span>  
  
    -   <span data-ttu-id="31606-191">메시지의 재정의의 모든 메시지 (뿐 아니라 종료 메시지)에 대 한 처리를 구현은 <xref:System.Windows.Interop.HwndHost> 메서드 <xref:System.Windows.Interop.HwndHost.WndProc%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-191">Implement message processing for all messages (not just shutdown messages) in your override of the <xref:System.Windows.Interop.HwndHost> method <xref:System.Windows.Interop.HwndHost.WndProc%2A>.</span></span>  
  
    -   <span data-ttu-id="31606-192">호스팅 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 처리 하 여 메시지를 처리 하는 요소는 <xref:System.Windows.Interop.HwndHost.MessageHook> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-192">Have the hosting [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] element process the messages by handling the <xref:System.Windows.Interop.HwndHost.MessageHook> event.</span></span> <span data-ttu-id="31606-193">이 이벤트는 호스팅된 창의 기본 창 프로시저에 전송된 모든 메시지에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-193">This event is raised for every message that is sent to the main window procedure of the hosted window.</span></span>  
  
    -   <span data-ttu-id="31606-194">사용 하 여 프로세스를 벗어난 창 메시지를 처리할 수 없지만 <xref:System.Windows.Interop.HwndHost.WndProc%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-194">You cannot process messages from windows that are out of process using <xref:System.Windows.Interop.HwndHost.WndProc%2A>.</span></span>  
  
7.  <span data-ttu-id="31606-195">관리되지 않는 `SendMessage` 함수를 호출하는 플랫폼 호출을 사용하여 호스팅된 창과 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-195">Communicate with the hosted window by using platform invoke to call the unmanaged `SendMessage` function.</span></span>  
  
 <span data-ttu-id="31606-196">다음 단계에 따라 마우스 입력을 사용하는 응용 프로그램을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="31606-196">Following these steps creates an application that works with mouse input.</span></span> <span data-ttu-id="31606-197">구현 하 여 호스트 창에 대 한 이동 하 여 원하는 지원을 추가할 수 있습니다는 <xref:System.Windows.Interop.IKeyboardInputSink> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-197">You can add tabbing support for your hosted window by implementing the <xref:System.Windows.Interop.IKeyboardInputSink> interface.</span></span>  
  
 <span data-ttu-id="31606-198">이러한 각 단계는 [연습: WPF에서 Win32 컨트롤 호스팅](../../../../docs/framework/wpf/advanced/walkthrough-hosting-a-win32-control-in-wpf.md) 항목에서 코드를 통해 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-198">Each of these steps is illustrated through code in the topic [Walkthrough: Hosting a Win32 Control in WPF](../../../../docs/framework/wpf/advanced/walkthrough-hosting-a-win32-control-in-wpf.md).</span></span>  
  
### <a name="hwnds-inside-wpf"></a><span data-ttu-id="31606-199">WPF 내의 HWND</span><span class="sxs-lookup"><span data-stu-id="31606-199">Hwnds Inside WPF</span></span>  
 <span data-ttu-id="31606-200">생각할 수 있으며 <xref:System.Windows.Interop.HwndHost> 는 특수 컨트롤 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-200">You can think of <xref:System.Windows.Interop.HwndHost> as a special control.</span></span> <span data-ttu-id="31606-201">(기술적으로 <xref:System.Windows.Interop.HwndHost> 는 <xref:System.Windows.FrameworkElement> 파생 클래스가 아니라는 <xref:System.Windows.Controls.Control> 파생 클래스 이지만 상호 운용성의 목적을 위해 컨트롤 간주 될 수 있습니다.) <xref:System.Windows.Interop.HwndHost> 기본 추상화 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 호스팅된 콘텐츠의 특성 되도록의 나머지 부분에서는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 호스팅된 콘텐츠를 렌더링 하 고 입력을 처리 하는 다른 컨트롤 모양의 개체 수를 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-201">(Technically, <xref:System.Windows.Interop.HwndHost> is a <xref:System.Windows.FrameworkElement> derived class, not a <xref:System.Windows.Controls.Control> derived class, but it can be considered a control for purposes of interoperation.) <xref:System.Windows.Interop.HwndHost> abstracts the underlying [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] nature of the hosted content such that the remainder of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] considers the hosted content to be another control-like object, which should render and process input.</span></span> <span data-ttu-id="31606-202"><xref:System.Windows.Interop.HwndHost>일반적으로 다른 모든 메서드처럼 동작 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.FrameworkElement>출력 (그리기 및 그래픽) 주위 중요 한 차이점이 몇 가지 및 어떤 기본 Hwnd의 제한 사항에 따라 입력 (마우스 및 키보드) 지원할 수 있지만, 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-202"><xref:System.Windows.Interop.HwndHost> generally behaves like any other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.FrameworkElement>, although there are some important differences around output (drawing and graphics) and input (mouse and keyboard) based on limitations of what the underlying HWNDs can support.</span></span>  
  
#### <a name="notable-differences-in-output-behavior"></a><span data-ttu-id="31606-203">출력 동작의 주요 차이점</span><span class="sxs-lookup"><span data-stu-id="31606-203">Notable Differences in Output Behavior</span></span>  
  
-   <span data-ttu-id="31606-204"><xref:System.Windows.FrameworkElement>즉는 <xref:System.Windows.Interop.HwndHost> 기본 클래스, UI 변경 내재 된 많은 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-204"><xref:System.Windows.FrameworkElement>, which is the <xref:System.Windows.Interop.HwndHost> base class, has quite a few properties that imply changes to the UI.</span></span> <span data-ttu-id="31606-205">여기에 속성와 같은 <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>, 요소 내에 부모 요소의 레이아웃이 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-205">These include properties such as <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>, which changes the layout of elements within that element as a parent.</span></span> <span data-ttu-id="31606-206">그러나 이러한 속성의 대부분은 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]에 대응되는 속성이 있더라도 해당 속성에 매핑되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-206">However, most of these properties are not mapped to possible [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] equivalents, even if such equivalents might exist.</span></span> <span data-ttu-id="31606-207">이러한 속성 및 해당 의미는 렌더링 기술에 따라 많이 달라지므로 매핑이 실용적이지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="31606-207">Too many of these properties and their meanings are too rendering-technology specific for mappings to be practical.</span></span> <span data-ttu-id="31606-208">따라서 같은 속성을 설정 <xref:System.Windows.FrameworkElement.FlowDirection%2A> 에 <xref:System.Windows.Interop.HwndHost> 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-208">Therefore, setting properties such as <xref:System.Windows.FrameworkElement.FlowDirection%2A> on <xref:System.Windows.Interop.HwndHost> has no effect.</span></span>  
  
-   <span data-ttu-id="31606-209"><xref:System.Windows.Interop.HwndHost>해야 회전, 크기 조정 된, 왜곡 된, 또는 그렇지 않으면 변환에 의해 영향을 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-209"><xref:System.Windows.Interop.HwndHost> cannot be rotated, scaled, skewed, or otherwise affected by a Transform.</span></span>  
  
-   <span data-ttu-id="31606-210"><xref:System.Windows.Interop.HwndHost>지원 하지 않습니다는 <xref:System.Windows.UIElement.Opacity%2A> 속성 (알파 혼합).</span><span class="sxs-lookup"><span data-stu-id="31606-210"><xref:System.Windows.Interop.HwndHost> does not support the <xref:System.Windows.UIElement.Opacity%2A> property (alpha blending).</span></span> <span data-ttu-id="31606-211">내부 콘텐츠 인 경우는 <xref:System.Windows.Interop.HwndHost> 수행 <xref:System.Drawing> 없는 자체 위반, 알파 정보를 포함 하는 작업 이지만 <xref:System.Windows.Interop.HwndHost> = 1.0 (100%) 전체 불투명도만 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-211">If content inside the <xref:System.Windows.Interop.HwndHost> performs <xref:System.Drawing> operations that include alpha information, that is itself not a violation, but the <xref:System.Windows.Interop.HwndHost> as a whole only supports Opacity = 1.0 (100%).</span></span>  
  
-   <span data-ttu-id="31606-212"><xref:System.Windows.Interop.HwndHost>맨 위에 나타납니다 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 동일한 최상위 창에 있는 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="31606-212"><xref:System.Windows.Interop.HwndHost> will appear on top of other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] elements in the same top-level window.</span></span> <span data-ttu-id="31606-213">그러나 한 <xref:System.Windows.Controls.ToolTip> 또는 <xref:System.Windows.Controls.ContextMenu> 생성 된 메뉴는 별도 최상위 창 및 하므로와 함께 올바르게 동작 <xref:System.Windows.Interop.HwndHost>합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-213">However, a <xref:System.Windows.Controls.ToolTip> or <xref:System.Windows.Controls.ContextMenu> generated menu is a separate top-level window, and so will behave correctly with <xref:System.Windows.Interop.HwndHost>.</span></span>  
  
-   <span data-ttu-id="31606-214"><xref:System.Windows.Interop.HwndHost>부모의 클립 영역을 지키지 않습니다 <xref:System.Windows.UIElement>합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-214"><xref:System.Windows.Interop.HwndHost> does not respect the clipping region of its parent <xref:System.Windows.UIElement>.</span></span> <span data-ttu-id="31606-215">이 잠재적 문제는 배치 하려는 경우는 <xref:System.Windows.Interop.HwndHost> 스크롤 영역 내부에 클래스 또는 <xref:System.Windows.Controls.Canvas>합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-215">This is potentially an issue if you attempt to put an <xref:System.Windows.Interop.HwndHost> class inside a scrolling region or <xref:System.Windows.Controls.Canvas>.</span></span>  
  
#### <a name="notable-differences-in-input-behavior"></a><span data-ttu-id="31606-216">입력 동작의 주요 차이점</span><span class="sxs-lookup"><span data-stu-id="31606-216">Notable Differences in Input Behavior</span></span>  
  
-   <span data-ttu-id="31606-217">일반적으로 입력된 장치 내로 범위가 지정 되는 <xref:System.Windows.Interop.HwndHost> 호스팅된 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 영역 입력된 이벤트로 이동 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-217">In general, while input devices are scoped within the <xref:System.Windows.Interop.HwndHost> hosted [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] region, input events go directly to [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)].</span></span>  
  
-   <span data-ttu-id="31606-218">마우스가 동안는 <xref:System.Windows.Interop.HwndHost>, 응용 프로그램에서 수신 하지 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 의 값과 마우스 이벤트는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 속성 <xref:System.Windows.UIElement.IsMouseOver%2A> 됩니다 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-218">While the mouse is over the <xref:System.Windows.Interop.HwndHost>, your application does not receive [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] mouse events, and the value of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property <xref:System.Windows.UIElement.IsMouseOver%2A> will be `false`.</span></span>  
  
-   <span data-ttu-id="31606-219">동안는 <xref:System.Windows.Interop.HwndHost> 키보드 포커스가 응용 프로그램을 받지 것입니다 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 키보드 이벤트 및의 값은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 속성 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> 됩니다 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-219">While the <xref:System.Windows.Interop.HwndHost> has keyboard focus, your application will not receive [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] keyboard events and the value of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> will be `false`.</span></span>  
  
-   <span data-ttu-id="31606-220">포커스가 있는 경우에 <xref:System.Windows.Interop.HwndHost> 및 내의 다른 컨트롤에 대 한 변경의 <xref:System.Windows.Interop.HwndHost>, 응용 프로그램을 받지 것입니다는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 이벤트 <xref:System.Windows.UIElement.GotFocus> 또는 <xref:System.Windows.UIElement.LostFocus>합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-220">When focus is within the <xref:System.Windows.Interop.HwndHost> and changes to another control inside the <xref:System.Windows.Interop.HwndHost>, your application will not receive the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] events <xref:System.Windows.UIElement.GotFocus> or <xref:System.Windows.UIElement.LostFocus>.</span></span>  
  
-   <span data-ttu-id="31606-221">관련 스타일러스 속성 및 이벤트는 비슷합니다 및 위에 있는 동안 정보를 보고 하지 않는 <xref:System.Windows.Interop.HwndHost>합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-221">Related stylus properties and events are analogous, and do not report information while the stylus is over <xref:System.Windows.Interop.HwndHost>.</span></span>  
  
<a name="tabbing_mnemonics_accelerators"></a>   
## <a name="tabbing-mnemonics-and-accelerators"></a><span data-ttu-id="31606-222">탭 이동, 니모닉 및 액셀러레이터 키</span><span class="sxs-lookup"><span data-stu-id="31606-222">Tabbing, Mnemonics, and Accelerators</span></span>  
 <span data-ttu-id="31606-223"><xref:System.Windows.Interop.IKeyboardInputSink> 및 <xref:System.Windows.Interop.IKeyboardInputSite> 인터페이스를 사용 하면 혼합에 대 한 완벽 한 키보드 자유로이 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 및 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 응용 프로그램:</span><span class="sxs-lookup"><span data-stu-id="31606-223">The <xref:System.Windows.Interop.IKeyboardInputSink> and <xref:System.Windows.Interop.IKeyboardInputSite> interfaces allow you to create a seamless keyboard experience for mixed [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] applications:</span></span>  
  
-   <span data-ttu-id="31606-224">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]와 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 구성 요소 간 탭 이동</span><span class="sxs-lookup"><span data-stu-id="31606-224">Tabbing between [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] components</span></span>  
  
-   <span data-ttu-id="31606-225">포커스가 Win32 구성 요소 내에 있을 때와 WPF 구성 요소에 있을 때 모두 작동하는 니모닉 및 액셀러레이터 키.</span><span class="sxs-lookup"><span data-stu-id="31606-225">Mnemonics and accelerators that work both when focus is within a Win32 component and when it is within a WPF component.</span></span>  
  
 <span data-ttu-id="31606-226"><xref:System.Windows.Interop.HwndHost> 및 <xref:System.Windows.Interop.HwndSource> 클래스는 둘 다의 구현을 제공 <xref:System.Windows.Interop.IKeyboardInputSink>, 있지만 보다 고급 시나리오에 대해 원하는 모든 입력된 메시지를 처리 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="31606-226">The <xref:System.Windows.Interop.HwndHost> and <xref:System.Windows.Interop.HwndSource> classes both provide implementations of <xref:System.Windows.Interop.IKeyboardInputSink>, but they may not handle all the input messages that you want for more advanced scenarios.</span></span> <span data-ttu-id="31606-227">원하는 키보드 동작을 얻기 위해 적절한 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-227">Override the appropriate methods to get the keyboard behavior you want.</span></span>  
  
 <span data-ttu-id="31606-228">인터페이스는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]와 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 영역 간에 전환할 때 발생하는 작업에 대해서만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="31606-228">The interfaces only provide support for what happens on the transition between the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] regions.</span></span> <span data-ttu-id="31606-229">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] 영역 내에서의 탭 이동 동작은 전적으로 [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]에 구현된 탭 이동 논리를 통해서만 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="31606-229">Within the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] region, tabbing behavior is entirely controlled by the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] implemented logic for tabbing, if any.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="31606-230">참고 항목</span><span class="sxs-lookup"><span data-stu-id="31606-230">See Also</span></span>  
 <xref:System.Windows.Interop.HwndHost>  
 <xref:System.Windows.Interop.HwndSource>  
 <xref:System.Windows.Interop>  
 [<span data-ttu-id="31606-231">연습: WPF에서 Win32 컨트롤 호스팅</span><span class="sxs-lookup"><span data-stu-id="31606-231">Walkthrough: Hosting a Win32 Control in WPF</span></span>](../../../../docs/framework/wpf/advanced/walkthrough-hosting-a-win32-control-in-wpf.md)  
 [<span data-ttu-id="31606-232">연습: Win32에서 WPF 콘텐츠 호스팅</span><span class="sxs-lookup"><span data-stu-id="31606-232">Walkthrough: Hosting WPF Content in Win32</span></span>](../../../../docs/framework/wpf/advanced/walkthrough-hosting-wpf-content-in-win32.md)

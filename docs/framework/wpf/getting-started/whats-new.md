---
title: WPF 버전 4.5의 새로운 기능
ms.date: 03/30/2017
helpviewer_keywords:
- Windows Presentation Foundation [WPF], what's new
- WPF [WPF], what's new
ms.assetid: db086ae4-70bb-4862-95db-2eaca5216bc3
ms.openlocfilehash: 4e022f75808de36666e53d3e58a0806e4f6d15ad
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33558098"
---
# <a name="what39s-new-in-wpf-version-45"></a><span data-ttu-id="a9e97-102">WPF 버전 4.5의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="a9e97-102">What&#39;s New in WPF Version 4.5</span></span>
<a name="introduction"></a> <span data-ttu-id="a9e97-103">이 항목에서는 새로운 기능과 향상 된 기능에 대 한 정보 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 버전 4.5입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-103">This topic contains information about new and enhanced features in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] version 4.5.</span></span>  
  
 <span data-ttu-id="a9e97-104">이 항목에는 다음과 같은 단원이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-104">This topic contains the following sections:</span></span>  
  
-   [<span data-ttu-id="a9e97-105">리본 컨트롤</span><span class="sxs-lookup"><span data-stu-id="a9e97-105">Ribbon control</span></span>](#ribbon_control)  
  
-   [<span data-ttu-id="a9e97-106">그룹화된 큰 데이터 집합을 표시할 때의 성능 개선</span><span class="sxs-lookup"><span data-stu-id="a9e97-106">Improved performance when displaying large sets of grouped data</span></span>](#grouped_virtualization)  
  
-   [<span data-ttu-id="a9e97-107">VirtualizingPanel의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="a9e97-107">New features for the VirtualizingPanel</span></span>](#VirtualizingPanel)  
  
-   [<span data-ttu-id="a9e97-108">정적 속성에 바인딩</span><span class="sxs-lookup"><span data-stu-id="a9e97-108">Binding to static properties</span></span>](#static_properties)  
  
-   [<span data-ttu-id="a9e97-109">UI가 아닌 스레드에서 컬렉션 액세스</span><span class="sxs-lookup"><span data-stu-id="a9e97-109">Accessing collections on non-UI Threads</span></span>](#xthread_access)  
  
-   [<span data-ttu-id="a9e97-110">동기적 및 비동기적으로 데이터 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="a9e97-110">Synchronously and Asynchronously validating data</span></span>](#INotifyDataErrorInfo)  
  
-   [<span data-ttu-id="a9e97-111">데이터 바인딩 원본을 자동으로 업데이트</span><span class="sxs-lookup"><span data-stu-id="a9e97-111">Automatically updating the source of a data binding</span></span>](#delay)  
  
-   [<span data-ttu-id="a9e97-112">ICustomTypeProvider를 구현하는 형식에 바인딩</span><span class="sxs-lookup"><span data-stu-id="a9e97-112">Binding to types that Implement ICustomTypeProvider</span></span>](#ICustomTypeProvider)  
  
-   [<span data-ttu-id="a9e97-113">바인딩 식에서 데이터 바인딩 정보 검색</span><span class="sxs-lookup"><span data-stu-id="a9e97-113">Retrieving data binding information from a binding expression</span></span>](#binding_state)  
  
-   [<span data-ttu-id="a9e97-114">유효한 DataContext 개체 확인</span><span class="sxs-lookup"><span data-stu-id="a9e97-114">Checking for a valid DataContext object</span></span>](#DisconnectedSource)  
  
-   [<span data-ttu-id="a9e97-115">데이터 값이 변경될 때 데이터의 위치 변경(라이브 셰이핑)</span><span class="sxs-lookup"><span data-stu-id="a9e97-115">Repositioning data as the data's values change (Live shaping)</span></span>](#live_shaping)  
  
-   [<span data-ttu-id="a9e97-116">이벤트에 대한 약한 참조 설정을 위한 지원 개선</span><span class="sxs-lookup"><span data-stu-id="a9e97-116">Improved Support for Establishing a Weak Reference to an Event</span></span>](#weak_event_pattern)  
  
-   [<span data-ttu-id="a9e97-117">Dispatcher 클래스에 대한 새로운 메서드</span><span class="sxs-lookup"><span data-stu-id="a9e97-117">New methods for the Dispatcher class</span></span>](#async)  
  
-   [<span data-ttu-id="a9e97-118">이벤트에 대한 태그 확장</span><span class="sxs-lookup"><span data-stu-id="a9e97-118">Markup Extensions for Events</span></span>](#events_markup_extenions)  
  
<a name="ribbon_control"></a>   
## <a name="ribbon-control"></a><span data-ttu-id="a9e97-119">리본 컨트롤</span><span class="sxs-lookup"><span data-stu-id="a9e97-119">Ribbon control</span></span>  
 <span data-ttu-id="a9e97-120">WPF 4.5와 함께 제공 되는 <xref:System.Windows.Controls.Ribbon.Ribbon> 빠른 실행 도구 모음, 응용 프로그램 메뉴 및 탭을 호스팅하는 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-120">WPF 4.5 ships with a <xref:System.Windows.Controls.Ribbon.Ribbon> control that hosts a Quick Access Toolbar, Application Menu, and tabs.</span></span>  <span data-ttu-id="a9e97-121">자세한 내용은 [리본 개요](/visualstudio/vsto/ribbon-overview)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a9e97-121">For more information, see the [Ribbon Overview](/visualstudio/vsto/ribbon-overview).</span></span>  
  
<a name="grouped_virtualization"></a>   
## <a name="improved-performance-when-displaying-large-sets-of-grouped-data"></a><span data-ttu-id="a9e97-122">그룹화된 큰 데이터 집합을 표시할 때의 성능 개선</span><span class="sxs-lookup"><span data-stu-id="a9e97-122">Improved performance when displaying large sets of grouped data</span></span>  
 <span data-ttu-id="a9e97-123">화면에 표시되는 항목에 따라 많은 수의 데이터 항목에서 사용자 인터페이스(UI) 요소의 하위 집합이 생성될 때 UI 가상화가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-123">UI virtualization occurs when  a subset of user interface (UI) elements are generated from a larger number of data items based on which items are visible on the screen.</span></span> <span data-ttu-id="a9e97-124"><xref:System.Windows.Controls.VirtualizingPanel> 정의 <xref:System.Windows.Controls.VirtualizingPanel.IsVirtualizingWhenGrouping%2A> 그룹화 된 데이터에 대 한 UI 가상화 있는 연결 된 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-124">The <xref:System.Windows.Controls.VirtualizingPanel> defines the <xref:System.Windows.Controls.VirtualizingPanel.IsVirtualizingWhenGrouping%2A> attached property that enables UI Virtualization for grouped data.</span></span>  <span data-ttu-id="a9e97-125">데이터 그룹화에 대한 자세한 내용은 방법: XAML에서 뷰를 사용하여 데이터 정렬 및 그룹화를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a9e97-125">For more information about grouping data, see How to: Sort and Group Data Using a View in XAML.</span></span>  <span data-ttu-id="a9e97-126">데이터 그룹화를 가상화 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Windows.Controls.VirtualizingPanel.IsVirtualizingWhenGrouping%2A> 연결 된 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-126">For more information about virtualizing grouped data, see the <xref:System.Windows.Controls.VirtualizingPanel.IsVirtualizingWhenGrouping%2A> attached property.</span></span>  
  
<a name="VirtualizingPanel"></a>   
## <a name="new-features-for-the-virtualizingpanel"></a><span data-ttu-id="a9e97-127">VirtualizingPanel의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="a9e97-127">New features for the VirtualizingPanel</span></span>  
  
1.  <span data-ttu-id="a9e97-128">지정할 수 있는지 여부를 <xref:System.Windows.Controls.VirtualizingPanel>와 같은 <xref:System.Windows.Controls.VirtualizingStackPanel>, 부분 항목을 사용 하 여 표시는 <xref:System.Windows.Controls.VirtualizingPanel.ScrollUnit%2A> 연결 된 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-128">You can specify whether a <xref:System.Windows.Controls.VirtualizingPanel>, such as the <xref:System.Windows.Controls.VirtualizingStackPanel>, displays partial items by using the <xref:System.Windows.Controls.VirtualizingPanel.ScrollUnit%2A> attached property.</span></span> <span data-ttu-id="a9e97-129">경우 <xref:System.Windows.Controls.VirtualizingPanel.ScrollUnit%2A> 로 설정 된 <xref:System.Windows.Controls.ScrollUnit.Item>, <xref:System.Windows.Controls.VirtualizingPanel> 완전히 표시 되는 항목만 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-129">If <xref:System.Windows.Controls.VirtualizingPanel.ScrollUnit%2A> is set to <xref:System.Windows.Controls.ScrollUnit.Item>, the <xref:System.Windows.Controls.VirtualizingPanel> will only display items that are completely visible.</span></span> <span data-ttu-id="a9e97-130">경우 <xref:System.Windows.Controls.VirtualizingPanel.ScrollUnit%2A> 로 설정 된 <xref:System.Windows.Controls.ScrollUnit.Pixel>, <xref:System.Windows.Controls.VirtualizingPanel> 부분적으로 표시 되는 항목을 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-130">If <xref:System.Windows.Controls.VirtualizingPanel.ScrollUnit%2A> is set to <xref:System.Windows.Controls.ScrollUnit.Pixel>, the <xref:System.Windows.Controls.VirtualizingPanel> can display partially visible items.</span></span>  
  
2.  <span data-ttu-id="a9e97-131">뷰포트 전후 캐시의 크기를 지정할 수 있습니다 때는 <xref:System.Windows.Controls.VirtualizingPanel> 에서 사용 하 여 가상화는 <xref:System.Windows.Controls.VirtualizingPanel.CacheLength%2A> 연결 된 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-131">You can specify the  size of the cache before and after the viewport when the <xref:System.Windows.Controls.VirtualizingPanel> is virtualizing by using the <xref:System.Windows.Controls.VirtualizingPanel.CacheLength%2A> attached property.</span></span>  <span data-ttu-id="a9e97-132">캐시는 항목이 가상화되지 않는 뷰포트 위 또는 아래 공간 양입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-132">The cache is the amount of space above or below the viewport in which items are not virtualized.</span></span>  <span data-ttu-id="a9e97-133">캐시를 사용하면 뷰로 스크롤하는 동안 UI 요소가 생성되지 않도록 하여 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-133">Using a cache to avoid generating UI elements as they’re scrolled into view can improve performance.</span></span> <span data-ttu-id="a9e97-134">캐시는 낮은 우선 순위에서 채워지므로 작업 중에는 응용 프로그램이 응답하지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-134">The cache is populated at a lower priority so that the application does not become unresponsive during the operation.</span></span> <span data-ttu-id="a9e97-135"><xref:System.Windows.Controls.VirtualizingPanel.CacheLengthUnit%2A?displayProperty=nameWithType> 속성에서 사용 되는 측정 단위를 결정 <xref:System.Windows.Controls.VirtualizingPanel.CacheLength%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-135">The <xref:System.Windows.Controls.VirtualizingPanel.CacheLengthUnit%2A?displayProperty=nameWithType> property determines the unit of measurement that is used by <xref:System.Windows.Controls.VirtualizingPanel.CacheLength%2A?displayProperty=nameWithType>.</span></span>  
  
<a name="static_properties"></a>   
## <a name="binding-to-static-properties"></a><span data-ttu-id="a9e97-136">정적 속성에 바인딩</span><span class="sxs-lookup"><span data-stu-id="a9e97-136">Binding to static properties</span></span>  
 <span data-ttu-id="a9e97-137">데이터 바인딩 원본으로 정적 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-137">You can use static properties as the source of a data binding.</span></span> <span data-ttu-id="a9e97-138">데이터 바인딩 엔진은 정적 이벤트가 발생할 경우 속성 값이 변경되는 것을 인식합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-138">The data binding engine recognizes when the property's value changes if a static event is raised.</span></span>  <span data-ttu-id="a9e97-139">예를 들어 `SomeClass` 클래스가 `MyProperty`라는 정적 속성을 정의하는 경우 `SomeClass`는 `MyProperty` 값이 변경될 때 발생하는 정적 이벤트를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-139">For example, if the class `SomeClass` defines a static property called `MyProperty`, `SomeClass` can define a static event that is raised when the value of `MyProperty` changes.</span></span>  <span data-ttu-id="a9e97-140">정적 이벤트는 다음 서명 중 하나를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-140">The static event can use either of the following signatures.</span></span>  
  
-   `public static event EventHandler MyPropertyChanged;`  
  
-   `public static event EventHandler<PropertyChangedEventArgs> StaticPropertyChanged;`  
  
 <span data-ttu-id="a9e97-141">첫 번째 경우에서는 클래스를 통해 노출 된 라는 정적 이벤트 참고 *PropertyName* `Changed` 를 통과 <xref:System.EventArgs> 이벤트 처리기에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-141">Note that in the first case, the class exposes a static event named *PropertyName*`Changed` that passes <xref:System.EventArgs> to the event handler.</span></span>  <span data-ttu-id="a9e97-142">두 번째 경우에서 클래스는 명명 된 정적 이벤트를 노출 `StaticPropertyChanged` 를 통과 <xref:System.ComponentModel.PropertyChangedEventArgs> 이벤트 처리기에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-142">In the second case, the class exposes a static event named `StaticPropertyChanged` that passes <xref:System.ComponentModel.PropertyChangedEventArgs> to the event handler.</span></span> <span data-ttu-id="a9e97-143">정적 속성을 구현하는 클래스에서 두 메서드 중 하나를 사용하여 속성-변경 알림이 발생하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-143">A class that implements the static property can choose to raise property-change notifications using either method.</span></span>  
  
<a name="xthread_access"></a>   
## <a name="accessing-collections-on-non-ui-threads"></a><span data-ttu-id="a9e97-144">UI가 아닌 스레드에서 컬렉션 액세스</span><span class="sxs-lookup"><span data-stu-id="a9e97-144">Accessing collections on non-UI Threads</span></span>  
 <span data-ttu-id="a9e97-145">WPF를 사용하면 컬렉션을 만들지 않은 스레드에서 데이터 컬렉션을 액세스하고 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-145">WPF enables you to access and modify data collections on threads other than the one that created the collection.</span></span>  <span data-ttu-id="a9e97-146">이를 통해 데이터베이스와 같은 외부 원본에서 데이터를 수신하는 데 백그라운드 스레드를 사용하고 UI 스레드에 데이터를 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-146">This enables you to use a background thread to receive data from an external source, such as a database, and display the data on the UI thread.</span></span>  <span data-ttu-id="a9e97-147">다른 스레드를 사용하여 콜렉션을 수정하면 사용자 인터페이스는 사용자 상호 작용에 응답성을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-147">By using another thread to modify the collection, your user interface remains responsive to user interaction.</span></span>  
  
<a name="INotifyDataErrorInfo"></a>   
## <a name="synchronously-and-asynchronously-validating-data"></a><span data-ttu-id="a9e97-148">동기적 및 비동기적으로 데이터 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="a9e97-148">Synchronously and Asynchronously validating data</span></span>  
 <span data-ttu-id="a9e97-149"><xref:System.ComponentModel.INotifyDataErrorInfo> 인터페이스 사용자 지정 유효성 검사 규칙을 구현 하 고 유효성 검사 결과 비동기적으로 노출 하는 데이터 엔터티 클래스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-149">The <xref:System.ComponentModel.INotifyDataErrorInfo> interface enables data entity classes to implement custom validation rules and expose validation results asynchronously.</span></span> <span data-ttu-id="a9e97-150">또한 이 인터페이스는 사용자 지정 오류 개체, 속성당 여러 오류, 속성 간 오류 및 엔터티 수준 오류도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-150">This interface also supports custom error objects, multiple errors per property, cross-property errors, and entity-level errors.</span></span>  <span data-ttu-id="a9e97-151">자세한 내용은 <xref:System.ComponentModel.INotifyDataErrorInfo>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a9e97-151">For more information, see <xref:System.ComponentModel.INotifyDataErrorInfo>.</span></span>  
  
<a name="delay"></a>   
## <a name="automatically-updating-the-source-of-a-data-binding"></a><span data-ttu-id="a9e97-152">데이터 바인딩 원본을 자동으로 업데이트</span><span class="sxs-lookup"><span data-stu-id="a9e97-152">Automatically updating the source of a data binding</span></span>  
 <span data-ttu-id="a9e97-153">데이터 바인딩을 사용 하 여 데이터 소스를 업데이트 하는 경우 사용할 수 있습니다는 <xref:System.Windows.Data.BindingBase.Delay%2A> 속성을 통해 소스 업데이트 하기 전에 대상의 속성 변경 후 전달할 수 있는 시간을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-153">If you use a data binding to update a data source, you can use the <xref:System.Windows.Data.BindingBase.Delay%2A> property to specify an amount of time to pass after the property changes on the target before the source updates.</span></span>  <span data-ttu-id="a9e97-154">예를 들어 있다고는 <xref:System.Windows.Controls.Slider> 있는 해당 <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> 양방향 속성 데이터는 데이터 개체의 속성에 바인딩된 및 <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> 속성이로 설정 되어 <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-154">For example, suppose that you have a <xref:System.Windows.Controls.Slider> that has its <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> property data two-way bound to a property of a data object and the <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> property is set to <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>.</span></span>  <span data-ttu-id="a9e97-155">이 예제에서는 사용자가 이동는 <xref:System.Windows.Controls.Slider>, 각 픽셀에 대 한 소스 업데이트 하는 <xref:System.Windows.Controls.Slider> 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-155">In this example, when the user moves the <xref:System.Windows.Controls.Slider>, the source updates for each pixel that the <xref:System.Windows.Controls.Slider> moves.</span></span>  <span data-ttu-id="a9e97-156">소스 개체 슬라이더의 값을 일반적으로 필요한 경우에만 슬라이더의 <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> 변경 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-156">The source object typically needs the value of the slider only when the slider's <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> stops changing.</span></span>  <span data-ttu-id="a9e97-157">사용 하 여 소스를 너무 자주 업데이트를 방지 하려면 <xref:System.Windows.Data.BindingBase.Delay%2A> 지정할 특정 시간 동안 엄지 단추 이동을 중지 후 경과할 때까지 원본 업데이트 되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-157">To prevent updating the source too often, use <xref:System.Windows.Data.BindingBase.Delay%2A> to specify that the source should not be updated until a certain amount of time elapses after the thumb stops moving.</span></span>  
  
<a name="ICustomTypeProvider"></a>   
## <a name="binding-to-types-that-implement-icustomtypeprovider"></a><span data-ttu-id="a9e97-158">ICustomTypeProvider를 구현하는 형식에 바인딩</span><span class="sxs-lookup"><span data-stu-id="a9e97-158">Binding to types that Implement ICustomTypeProvider</span></span>  
 <span data-ttu-id="a9e97-159">WPF를 구현 하는 개체에 대 한 데이터 바인딩을 지원 <xref:System.Reflection.ICustomTypeProvider>사용자 지정 형식이 라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-159">WPF supports data binding to objects that implement <xref:System.Reflection.ICustomTypeProvider>, also known as custom types.</span></span>  <span data-ttu-id="a9e97-160">다음과 같은 경우 사용자 지정 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-160">You can use custom types in the following cases.</span></span>  
  
1.  <span data-ttu-id="a9e97-161">로 <xref:System.Windows.PropertyPath> 데이터 바인딩에서.</span><span class="sxs-lookup"><span data-stu-id="a9e97-161">As a <xref:System.Windows.PropertyPath> in a data binding.</span></span> <span data-ttu-id="a9e97-162">예를 들어는 <xref:System.Windows.Data.Binding.Path%2A> 속성은 <xref:System.Windows.Data.Binding> 사용자 정의 형식의 속성을 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-162">For example, the <xref:System.Windows.Data.Binding.Path%2A> property of a <xref:System.Windows.Data.Binding> can reference a property of a custom type.</span></span>  
  
2.  <span data-ttu-id="a9e97-163">값으로는 <xref:System.Windows.DataTemplate.DataType%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-163">As the value of the <xref:System.Windows.DataTemplate.DataType%2A> property.</span></span>  
  
3.  <span data-ttu-id="a9e97-164">자동으로 생성 된 열을 결정 하는 형식으로는 <xref:System.Windows.Controls.DataGrid>합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-164">As a type that determines the automatically generated columns in a <xref:System.Windows.Controls.DataGrid>.</span></span>  
  
<a name="binding_state"></a>   
## <a name="retrieving-data-binding-information-from-a-binding-expression"></a><span data-ttu-id="a9e97-165">바인딩 식에서 데이터 바인딩 정보 검색</span><span class="sxs-lookup"><span data-stu-id="a9e97-165">Retrieving data binding information from a binding expression</span></span>  
 <span data-ttu-id="a9e97-166">특정 한 경우에 발생할 수 있습니다는 <xref:System.Windows.Data.BindingExpression> 의 <xref:System.Windows.Data.Binding> 및 바인딩 소스 및 대상 개체에 대 한 정보가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-166">In certain cases, you might get the <xref:System.Windows.Data.BindingExpression> of a <xref:System.Windows.Data.Binding> and need information about the source and target objects of the binding.</span></span>  <span data-ttu-id="a9e97-167">원본 또는 대상 개체나 연결된 속성을 얻도록 새로운 API가 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-167">New APIs have been added to enable you to get the source or target object or the associated property.</span></span>  <span data-ttu-id="a9e97-168">있는 경우는 <xref:System.Windows.Data.BindingExpression>, 대상 및 원본에 대 한 정보를 얻으려면 다음 Api를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-168">When you have a <xref:System.Windows.Data.BindingExpression>, use the following APIs to get information about the target and source.</span></span>  
  
|<span data-ttu-id="a9e97-169">바인딩의 다음 값을 찾으려면</span><span class="sxs-lookup"><span data-stu-id="a9e97-169">To find this value of the binding</span></span>|<span data-ttu-id="a9e97-170">다음 API 사용</span><span class="sxs-lookup"><span data-stu-id="a9e97-170">Use this API</span></span>|  
|---------------------------------------|------------------|  
|<span data-ttu-id="a9e97-171">대상 개체</span><span class="sxs-lookup"><span data-stu-id="a9e97-171">The target object</span></span>|<xref:System.Windows.Data.BindingExpressionBase.Target%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="a9e97-172">대상 속성</span><span class="sxs-lookup"><span data-stu-id="a9e97-172">The target property</span></span>|<xref:System.Windows.Data.BindingExpressionBase.TargetProperty%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="a9e97-173">소스 개체</span><span class="sxs-lookup"><span data-stu-id="a9e97-173">The source object</span></span>|<xref:System.Windows.Data.BindingExpression.ResolvedSource%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="a9e97-174">원본 속성</span><span class="sxs-lookup"><span data-stu-id="a9e97-174">The source property</span></span>|<xref:System.Windows.Data.BindingExpression.ResolvedSourcePropertyName%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="a9e97-175">여부는 <xref:System.Windows.Data.BindingExpression> 속한는 <xref:System.Windows.Data.BindingGroup></span><span class="sxs-lookup"><span data-stu-id="a9e97-175">Whether the <xref:System.Windows.Data.BindingExpression> belongs to a <xref:System.Windows.Data.BindingGroup></span></span>|<xref:System.Windows.Data.BindingExpressionBase.BindingGroup%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="a9e97-176">소유자는 <xref:System.Windows.Data.BindingGroup></span><span class="sxs-lookup"><span data-stu-id="a9e97-176">The owner of a <xref:System.Windows.Data.BindingGroup></span></span>|<xref:System.Windows.Data.BindingGroup.Owner%2A>|  
  
<a name="DisconnectedSource"></a>   
## <a name="checking-for-a-valid-datacontext-object"></a><span data-ttu-id="a9e97-177">유효한 DataContext 개체 확인</span><span class="sxs-lookup"><span data-stu-id="a9e97-177">Checking for a valid DataContext object</span></span>  
 <span data-ttu-id="a9e97-178">경우도 있습니다. 여기서는 <xref:System.Windows.FrameworkElement.DataContext%2A> 에 항목 컨테이너의는 <xref:System.Windows.Controls.ItemsControl> 연결이 끊어지면 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-178">There are cases where the <xref:System.Windows.FrameworkElement.DataContext%2A> of an item container in an <xref:System.Windows.Controls.ItemsControl> becomes disconnected.</span></span>  <span data-ttu-id="a9e97-179">항목 컨테이너에 있는 항목을 표시 하는 UI 요소는 한 <xref:System.Windows.Controls.ItemsControl>합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-179">An item container is the UI element that displays an item in an <xref:System.Windows.Controls.ItemsControl>.</span></span>  <span data-ttu-id="a9e97-180">경우는 <xref:System.Windows.Controls.ItemsControl> 는 데이터 컬렉션에 바인딩된 항목 컨테이너는 각 항목에 대해 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-180">When an <xref:System.Windows.Controls.ItemsControl> is data bound to a collection, an item container is generated for each item.</span></span> <span data-ttu-id="a9e97-181">경우에 따라 항목 컨테이너는 시각적 트리에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-181">In some cases, item containers are removed from the visual tree.</span></span> <span data-ttu-id="a9e97-182">기본 컬렉션에서 항목이 제거 될 때 및에서 가상화가 사용 하는 경우 항목 컨테이너 제거 되는 두 가지 일반적인 경우는는 <xref:System.Windows.Controls.ItemsControl>합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-182">Two typical cases where an item container is removed are when an item is removed from the underlying collection and when virtualization is enabled on the <xref:System.Windows.Controls.ItemsControl>.</span></span> <span data-ttu-id="a9e97-183">이러한 경우에는 <xref:System.Windows.FrameworkElement.DataContext%2A> 항목 컨테이너의 속성에서 반환 되는 sentinel 개체에 설정 됩니다는 <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A?displayProperty=nameWithType> 정적 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-183">In these cases, the <xref:System.Windows.FrameworkElement.DataContext%2A> property of the item container will be set to the sentinel object that is returned by the <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A?displayProperty=nameWithType> static property.</span></span>  <span data-ttu-id="a9e97-184">확인 해야 하는지 여부를 <xref:System.Windows.FrameworkElement.DataContext%2A> 같은지는 <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> 개체에 액세스 하기 전에 <xref:System.Windows.FrameworkElement.DataContext%2A> 항목 컨테이너의 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-184">You should check whether the <xref:System.Windows.FrameworkElement.DataContext%2A> is equal to the <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> object before accessing the <xref:System.Windows.FrameworkElement.DataContext%2A> of an item container.</span></span>  
  
<a name="live_shaping"></a>   
## <a name="repositioning-data-as-the-datas-values-change-live-shaping"></a><span data-ttu-id="a9e97-185">데이터 값이 변경될 때 데이터의 위치 변경(라이브 셰이핑)</span><span class="sxs-lookup"><span data-stu-id="a9e97-185">Repositioning data as the data's values change (Live shaping)</span></span>  
 <span data-ttu-id="a9e97-186">데이터의 컬렉션을 그룹화, 정렬 또는 필터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-186">A collection of data can be grouped, sorted, or filtered.</span></span> <span data-ttu-id="a9e97-187">WPF 4.5에서는 데이터가 수정되면 데이터를 다시 배열할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-187">WPF 4.5 enables the data to be rearranged when the data is modified.</span></span> <span data-ttu-id="a9e97-188">예를 들어, 응용 프로그램에서 사용 된 <xref:System.Windows.Controls.DataGrid> 나열 하는 주식 시장에서 주식 및 주식 기준으로 정렬 됩니다 재고 값입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-188">For example, suppose that an application uses a <xref:System.Windows.Controls.DataGrid> to list stocks in a stock market and the stocks are sorted by stock value.</span></span> <span data-ttu-id="a9e97-189">라이브 정렬 주식 활성화 된 경우 <xref:System.Windows.Data.CollectionView>에서 주식의 위치는 <xref:System.Windows.Controls.DataGrid> 재고 값이 큰 이동 또는 보다 작은 다른 주식 값입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-189">If live sorting is enabled on the stocks' <xref:System.Windows.Data.CollectionView>, a stock's position in the <xref:System.Windows.Controls.DataGrid> moves when the value of the stock becomes greater or less than another stock's value.</span></span>   <span data-ttu-id="a9e97-190">자세한 내용은 참조는 <xref:System.ComponentModel.ICollectionViewLiveShaping> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-190">For more information, see the <xref:System.ComponentModel.ICollectionViewLiveShaping> interface.</span></span>  
  
<a name="weak_event_pattern"></a>   
## <a name="improved-support-for-establishing-a-weak-reference-to-an-event"></a><span data-ttu-id="a9e97-191">이벤트에 대한 약한 참조 설정을 위한 지원 개선</span><span class="sxs-lookup"><span data-stu-id="a9e97-191">Improved Support for Establishing a Weak Reference to an Event</span></span>  
 <span data-ttu-id="a9e97-192">이벤트 구독자가 추가 인터페이스 구현 없이 참여할 수 있으므로 약한 이벤트 패턴을 구현하기가 더 쉬워졌습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-192">Implementing the weak event pattern is now easier because subscribers to events can participate in it without implementing an extra interface.</span></span>  <span data-ttu-id="a9e97-193">제네릭 <xref:System.Windows.WeakEventManager> 클래스도 전용 경우 취약 한 이벤트 패턴에서 참여에 대 한 구독자를 사용 하면 <xref:System.Windows.WeakEventManager> 특정 이벤트에 대 한 존재 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-193">The generic <xref:System.Windows.WeakEventManager> class also enables subscribers to participate in the weak event pattern if a dedicated <xref:System.Windows.WeakEventManager> does not exist for a certain event.</span></span>  <span data-ttu-id="a9e97-194">자세한 내용은 [약한 이벤트 패턴](../../../../docs/framework/wpf/advanced/weak-event-patterns.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a9e97-194">For more information, see [Weak Event Patterns](../../../../docs/framework/wpf/advanced/weak-event-patterns.md).</span></span>  
  
<a name="async"></a>   
## <a name="new-methods-for-the-dispatcher-class"></a><span data-ttu-id="a9e97-195">Dispatcher 클래스에 대한 새로운 메서드</span><span class="sxs-lookup"><span data-stu-id="a9e97-195">New methods for the Dispatcher class</span></span>  
 <span data-ttu-id="a9e97-196">Dispatcher 클래스는 동기 및 비동기 작업에 대해 새로운 메서드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-196">The Dispatcher class defines new methods for synchronous and asynchronous operations.</span></span>  <span data-ttu-id="a9e97-197">동기 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 메서드 정의 받아들이는 오버 로드는 <xref:System.Action> 또는 <xref:System.Func%601> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-197">The synchronous <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method defines overloads that take an <xref:System.Action> or <xref:System.Func%601> parameter.</span></span> <span data-ttu-id="a9e97-198">새로운 비동기 메서드를 <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>, 또한를 사용 하며는 <xref:System.Action> 또는 <xref:System.Func%601> 콜백 매개 변수 및 반환 된 <xref:System.Windows.Threading.DispatcherOperation> 또는 <xref:System.Windows.Threading.DispatcherOperation%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-198">The new asynchronous method, <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>, also takes an <xref:System.Action> or <xref:System.Func%601> as the callback parameter and returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>.</span></span>   <span data-ttu-id="a9e97-199"><xref:System.Windows.Threading.DispatcherOperation> 및 <xref:System.Windows.Threading.DispatcherOperation%601> 클래스 정의 <xref:System.Threading.Tasks.Task> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-199">The <xref:System.Windows.Threading.DispatcherOperation> and <xref:System.Windows.Threading.DispatcherOperation%601> classes define a <xref:System.Threading.Tasks.Task> property.</span></span>  <span data-ttu-id="a9e97-200">호출 하는 경우 <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>를 사용할 수 있습니다는 `await` 키워드를 사용 하 여는 <xref:System.Windows.Threading.DispatcherOperation> 관련 <xref:System.Threading.Tasks.Task>합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-200">When you call <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>, you can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="a9e97-201">동기적으로 대기 하는 경우는 <xref:System.Threading.Tasks.Task> 에서 반환 하는 <xref:System.Windows.Threading.DispatcherOperation> 또는 <xref:System.Windows.Threading.DispatcherOperation%601>, 호출의 <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> 확장 메서드.</span><span class="sxs-lookup"><span data-stu-id="a9e97-201">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span> <span data-ttu-id="a9e97-202">호출 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 호출 스레드에서 작업은 큐에 대기 하는 경우 교착 상태가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-202">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock if the operation is queued on a calling thread.</span></span> <span data-ttu-id="a9e97-203">사용 하는 방법에 대 한 자세한 내용은 <xref:System.Threading.Tasks.Task> 비동기 작업을 수행 하려면 참조 [작업 병렬 처리 (작업 병렬 라이브러리)](../../../../docs/standard/parallel-programming/task-based-asynchronous-programming.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-203">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see [Task Parallelism (Task Parallel Library)](../../../../docs/standard/parallel-programming/task-based-asynchronous-programming.md).</span></span>  
  
<a name="events_markup_extenions"></a>   
## <a name="markup-extensions-for-events"></a><span data-ttu-id="a9e97-204">이벤트에 대한 태그 확장</span><span class="sxs-lookup"><span data-stu-id="a9e97-204">Markup Extensions for Events</span></span>  
 <span data-ttu-id="a9e97-205">WPF 4.5에서는 이벤트에 대한 태그 확장을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-205">WPF 4.5 supports markup extensions for events.</span></span>  <span data-ttu-id="a9e97-206">WPF는 이벤트에 사용될 태그 확장을 정의하지 않지만 타사에서 이벤트에 사용할 수 있는 태그 확장을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9e97-206">While WPF does not define a markup extension to be used for events, third parties are able to create a markup extension that can be used with events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a9e97-207">참고 항목</span><span class="sxs-lookup"><span data-stu-id="a9e97-207">See Also</span></span>  
 [<span data-ttu-id="a9e97-208">.NET Framework의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="a9e97-208">What's New in the .NET Framework</span></span>](../../../../docs/framework/whats-new/index.md)

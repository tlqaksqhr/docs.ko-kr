---
title: .NET Framework XAML 서비스에서 사용할 사용자 지정 형식 정의
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 9edc7baa1a540a71997cf5b1ed010ad5c7960d17
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33566498"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="9c705-102">.NET Framework XAML 서비스에서 사용할 사용자 지정 형식 정의</span><span class="sxs-lookup"><span data-stu-id="9c705-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="9c705-103">비즈니스 개체는 사용자 지정 형식을 정의 하거나 특정 프레임 워크에 대 한 종속성이 없는 유형이 때 참고할 수 XAML에 대 한 유용한 특정 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="9c705-104">이러한 사례를 따르는 경우.NET Framework XAML 서비스 XAML 판독기 및 XAML 작성기 수 형식의 XAML 특징을 검색 하 고 XAML 형식 시스템을 사용 하 여 XAML 노드 스트림의 적절 한 표현 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="9c705-105">이 항목 형식 정의 멤버의 정의 및 CLR 형식 또는 멤버의 특성 설정에 대 한 모범 사례를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="9c705-106">생성자 패턴 및 XAML에 대 한 형식 정의</span><span class="sxs-lookup"><span data-stu-id="9c705-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="9c705-107">Xaml에서 개체 요소 인스턴스화할 수는 사용자 지정 클래스는 다음 요구 사항을 충족 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="9c705-108">사용자 지정 클래스는 공용 이어야 하며 기본 (매개 변수가 없는) 공용 생성자를 노출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="9c705-109">구조체에 대한 자세한 내용은 다음 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9c705-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="9c705-110">사용자 지정 클래스는 중첩 된 클래스 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="9c705-111">추가 전체 이름 경로에서 "점" 클래스 네임 스페이스 나누기 모호 만들고 연결 된 속성 등의 기타 XAML 기능을 방해 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="9c705-112">개체 요소를 개체를 인스턴스화할 수 만든된 개체 내부 형식으로 개체를 사용 하는 모든 속성의 속성 요소 형식을 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="9c705-113">여전히 값 변환기를 사용 하도록 설정 하면 이러한 조건을 충족 하지 않는 형식에 대 한 개체 값을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="9c705-114">자세한 내용은 참조 [형식 변환기 및 XAML 태그 확장명](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-114">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="9c705-115">구조체</span><span class="sxs-lookup"><span data-stu-id="9c705-115">Structures</span></span>  
 <span data-ttu-id="9c705-116">구조체는 항상 CLR 정의 하 여 XAML에서 생성 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="9c705-117">즉, CLR 컴파일러는 구조에 대 한 기본 생성자를 암시적으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="9c705-118">이 생성자는 모든 속성 값을 기본값으로 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="9c705-119">일부 경우에는 구조에 대 한 기본 생성 동작 바람직하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="9c705-120">구조 개념적으로 공용 구조체의 값을 채우고를 채우기 위한 것은 때문일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="9c705-121">공용 구조체의 경우 포함된 된 값 상호 배타적인 해석을 하며 따라서 해당 속성은 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="9c705-122">WPF 어휘에 이러한 구조체의 예로 <xref:System.Windows.GridLength>합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="9c705-123">문자열을 만드는 규칙을 서로 다른 해석을 또는 구조 값의 모드를 사용 하 여 특성 형식으로 값을 표현할 수 수 있도록 이러한 구조체는 형식 변환기를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="9c705-124">이러한 구조체는 기본값이 아닌 생성자를 통해 코드를 생성하는 경우에도 이와 유사한 동작을 노출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="9c705-125">인터페이스</span><span class="sxs-lookup"><span data-stu-id="9c705-125">Interfaces</span></span>  
 <span data-ttu-id="9c705-126">인터페이스 멤버의 기본 형식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="9c705-127">XAML 형식 시스템 할당 가능한 목록을 확인 하 고 값으로 제공 되는 개체는 인터페이스에 할당 될 수 예상 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="9c705-128">어떻게 인터페이스 표시 되어야 하는 XAML 형식으로 관련 할당 가능한 형식이 XAML 생성 요구 사항을 지 원하는 한 개념이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="9c705-129">팩터리 메서드</span><span class="sxs-lookup"><span data-stu-id="9c705-129">Factory Methods</span></span>  
 <span data-ttu-id="9c705-130">팩터리 메서드는 XAML 2009 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="9c705-131">개체에 기본 생성자가 있어야 하는 XAML 원칙을 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="9c705-132">팩터리 메서드는이 항목에서 설명 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="9c705-133">참조 [X:factorymethod 지시문](../../../docs/framework/xaml-services/x-factorymethod-directive.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-133">See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="9c705-134">열거형</span><span class="sxs-lookup"><span data-stu-id="9c705-134">Enumerations</span></span>  
 <span data-ttu-id="9c705-135">열거형에는 XAML 네이티브 형식 변환 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="9c705-136">XAML에 지정 된 열거형 상수 이름을 기본 열거형 형식에 대해 확인 되며 및 XAML 개체 작성기에 열거 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="9c705-137">열거형에 대 한 스타일 플래그 사용을 지원 하는 XAML <xref:System.FlagsAttribute> 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="9c705-138">자세한 내용은 참조 [XAML 구문에서 세부](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-138">For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="9c705-139">([XAML 구문에서 세부](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) WPF audience 용으로 작성 된 대부분의 해당 항목의 정보는 특정 구현 프레임 워크 관련 된 XAML 적합 하지만.)</span><span class="sxs-lookup"><span data-stu-id="9c705-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="9c705-140">멤버 정의</span><span class="sxs-lookup"><span data-stu-id="9c705-140">Member Definitions</span></span>  
 <span data-ttu-id="9c705-141">형식은은 XAML 사용에 대 한 멤버를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="9c705-142">XAML에서 사용할 수 없는 형식이 해당 하는 경우에 XAML에서 사용할 수 있는 멤버를 정의 하는 형식에 대 한 것 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="9c705-143">이 CLR 상속 때문에 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="9c705-144">멤버를 상속 하는 일부 형식을 지원 형식으로 XAML 사용 구성원 내부 형식에 대 한 XAML 사용을 지원 하거나 사용할 수 있는 기본 XAML 구문에 있으며, 해당 멤버는 XAML에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="9c705-145">속성</span><span class="sxs-lookup"><span data-stu-id="9c705-145">Properties</span></span>  
 <span data-ttu-id="9c705-146">일반적인 CLR을 사용 하 여 공용 CLR 속성으로 속성을 정의 하는 경우 `get` 및 `set` XAML 형식 시스템에 대 한 속성을 적절 한 정보와 함께 멤버로 제공 보고할 수 접근자 패턴 및 언어에 적합 한 키워드 <xref:System.Xaml.XamlMember> 속성을 같은 <xref:System.Xaml.XamlMember.IsReadPublic%2A> 및 <xref:System.Xaml.XamlMember.IsWritePublic%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="9c705-147">특정 속성을 적용 하 여 텍스트 구문 사용 하도록 설정할 수 <xref:System.ComponentModel.TypeConverterAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="9c705-148">자세한 내용은 참조 [형식 변환기 및 XAML 태그 확장명](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-148">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="9c705-149">텍스트 구문 또는 네이티브 XAML 변환이 없는 경우 및 속성의 형식은 태그 확장 사용 같은 간접 더 이상 없는 경우에서 (<xref:System.Xaml.XamlMember.TargetType%2A> xaml에서 형식 시스템) XAML 개체 작성기에는 t를 처리 하 여 인스턴스를 반환할 수 여야 합니다 CLR 형식으로 대상 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="9c705-150">하지만 XAML 2009를 사용 하는 경우 [X:reference 태그 확장](../../../docs/framework/xaml-services/x-reference-markup-extension.md) 이전 고려 사항에 맞지 않으면 값을 제공 하는 데 사용 될; 형식 정의 문제를 보다 사용량 문제 즉 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-150">If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="9c705-151">이벤트</span><span class="sxs-lookup"><span data-stu-id="9c705-151">Events</span></span>  
 <span data-ttu-id="9c705-152">XAML 형식 시스템으로 구성원으로 이벤트를 보고할 수 공용 CLR 이벤트로 이벤트를 정의 하는 경우 <xref:System.Xaml.XamlMember.IsEvent%2A> 으로 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="9c705-153">.NET Framework XAML 서비스 기능;의 범위 내에 있지 않습니다 배선 이벤트 처리기 이 특정 프레임 워크 및 구현에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="9c705-154">메서드</span><span class="sxs-lookup"><span data-stu-id="9c705-154">Methods</span></span>  
 <span data-ttu-id="9c705-155">메서드에 대 한 인라인 코드는 기본 XAML 기능이 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="9c705-156">대부분의 경우에서 참조 하지 않도록 직접 메서드 멤버 XAML에서 없으며 XAML에서 메서드의 역할 하기 위해 특정 XAML 패턴에 대 한 지원을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="9c705-157">[X:factorymethod 지시문](../../../docs/framework/xaml-services/x-factorymethod-directive.md) 는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-157">[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="9c705-158">필드</span><span class="sxs-lookup"><span data-stu-id="9c705-158">Fields</span></span>  
 <span data-ttu-id="9c705-159">CLR 디자인 지침 비정적 필드를 억제 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="9c705-160">정적 필드에 대 한 정적 필드 값에 액세스할 수 있습니다 통해서만 [X:static 태그 확장](../../../docs/framework/xaml-services/x-static-markup-extension.md);이 경우에 수행 하지 않습니다에 대 한 필드를 노출 하기 위해 CLR 정의에서 특별 한 [X:static](../../../docs/framework/xaml-services/x-static-markup-extension.md) 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-160">For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="9c705-161">연결 가능한 멤버</span><span class="sxs-lookup"><span data-stu-id="9c705-161">Attachable Members</span></span>  
 <span data-ttu-id="9c705-162">연결 가능한 멤버 접근자 메서드를 정의 하는 형식에서 패턴을 통해 XAML로 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="9c705-163">자체 정의 형식이 XAML-으로 사용할 수 있는 개체 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="9c705-164">역할이 서비스 클래스를 선언 하는 일반적인 패턴은 실제로 연결 가능한 멤버를 소유 하 고 관련된 동작을 구현 하지만 UI 표현 등 다른 함수가 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="9c705-165">다음 섹션에서는 자리 표시자에 대 한 *PropertyName* 연결 가능한 멤버의 이름을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="9c705-166">해당 이름의에서 유효 해야 합니다.는 [XamlName 문법](../../../docs/framework/xaml-services/xamlname-grammar.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-166">That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="9c705-167">이러한 패턴 및 다른 형태의 형식 간의 이름 충돌 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="9c705-168">패턴 중 하 나와 일치 하는 멤버가 있는 경우 해석 될 수는 연결 가능한 멤버 사용 경로으로 XAML 프로세서에서 의도 되지 않은 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="9c705-169">GetPropertyName 접근자</span><span class="sxs-lookup"><span data-stu-id="9c705-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="9c705-170">`Get`*PropertyName* 접근자에 대한 서명은 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="9c705-171">`public static object Get`*PropertyName* `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="9c705-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="9c705-172">구현에서 보다 구체적인 형식으로 `target` 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="9c705-173">연결 가능한 멤버;의 사용 범위는 데 사용할 수 있습니다. 원하는 범위를 벗어나는 사용량 XAML 구문 분석 오류에 의해 표시 되는 잘못 된 캐스팅 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="9c705-174">매개 변수 이름을 `target` 한 요구 사항은 아닙니다 되었지만 이름이 `target` 대부분의 구현에는 일반적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="9c705-175">구현에서 보다 구체적인 형식으로 반환 값을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="9c705-176">지원 하기 위해는 <xref:System.ComponentModel.TypeConverter> 연결 가능한 멤버의 특성 사용에 대 한 활성화 된 텍스트 구문이 적용 <xref:System.ComponentModel.TypeConverterAttribute> 에 `Get` *PropertyName* 접근자입니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="9c705-177">하지만에 적용 된 `get` 대신는 `set` 임의의; 보일 수 있지만이 규칙의 개념을 지원할 수 있습니다 직렬화 할 수 있는 읽기 전용 연결 가능한 멤버, 하는 디자이너 시나리오에서 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="9c705-178">SetPropertyName 접근자</span><span class="sxs-lookup"><span data-stu-id="9c705-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="9c705-179">집합에 대 한 서명을*PropertyName* 접근자 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="9c705-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="9c705-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="9c705-181">`target` 이전 섹션에 설명 된 대로 동일한 논리와 결과와 구현에서 더 구체적인 형식으로 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="9c705-182">구현에서 보다 구체적인 형식으로 `value` 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="9c705-183">이 메서드에 대 한 값이 XAML 사용은 특성 형태로 일반적으로 입력 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="9c705-184">특성 형식에서 여야 텍스트 구문에 대 한 값 변환기 지원 하며이 특성에 `Get` *PropertyName* 접근자입니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="9c705-185">연결 가능한 멤버 저장소</span><span class="sxs-lookup"><span data-stu-id="9c705-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="9c705-186">접근자 메서드는 일반적으로 하지는 개체 그래프에 연결 가능한 멤버 값을 배치에 또는 개체 그래프에서 값을 검색 하 고 제대로 serialize 할 수 있는 방법을 제공 하기에 충분 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="9c705-187">이 기능을 제공 하는 `target` 이전 접근자 시그니처에 개체 값을 저장할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="9c705-188">저장 메커니즘은 연결 가능한 멤버가 있지 않은 멤버 목록에는 대상에 연결할 수 있는 멤버는 연결 가능한 멤버 원칙와 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="9c705-189">.NET framework XAML 서비스 Api를 통해 연결할 수 있는 멤버를 저장에 대 한 구현 기술을 제공 <xref:System.Xaml.IAttachedPropertyStore> 및 <xref:System.Xaml.AttachablePropertyServices>합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="9c705-190"><xref:System.Xaml.IAttachedPropertyStore> XAML 작성기를 검색할 저장소 구현 하는 데 사용 되는 형식에 구현 해야 및는 `target` 접근자의 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="9c705-191">정적 <xref:System.Xaml.AttachablePropertyServices> Api는 접근자의 본문 내에서 사용 되 고 하 여 연결할 수 있는 멤버를 참조 해당 <xref:System.Xaml.AttachableMemberIdentifier>합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="9c705-192">XAML 관련 CLR 특성</span><span class="sxs-lookup"><span data-stu-id="9c705-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="9c705-193">올바르게 형식, 멤버 및 어셈블리 특성을 지정 하는 것이.NET Framework XAML 서비스 XAML 형식 시스템의 정보를 보고 하기 위해 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="9c705-194">이 정의 하거나 해당 XAML 판독기 및 XAML 작성기를 기반으로 하는 XAML을 사용 하 여 프레임 워크를 사용 하는 경우 또는 XAML 시스템 기반으로 하는 직접.NET Framework XAML 서비스 XAML 판독기 및 XAML 작성기와 함께 사용할 형식을 하려는 경우에 해당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="9c705-195">사용자 지정 형식의 XAML 지원에 대 한 관련 된 각 XAML 관련 특성의 목록을 보려면 [사용자 지정 형식 및 라이브러리에 대 한 CLR 특성 XAML-Related](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="9c705-196">사용법</span><span class="sxs-lookup"><span data-stu-id="9c705-196">Usage</span></span>  
 <span data-ttu-id="9c705-197">사용자 지정 형식 사용 해야 태그 작성자가 사용자 지정 항목 유형이 있는 어셈블리와 CLR 네임 스페이스에 대 한 접두사를 매핑해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="9c705-198">이 절차는이 항목에 문서화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="9c705-199">액세스 수준</span><span class="sxs-lookup"><span data-stu-id="9c705-199">Access Level</span></span>  
 <span data-ttu-id="9c705-200">XAML 로드 하 고이 있는 형식을 인스턴스화하는 방법을 제공는 `internal` 액세스 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="9c705-201">이 기능은 사용자 코드는 자체 형식 정의 업데이트 하 고 다음 동일한 사용자 코드 범위의 일부 이기도 태그에서 해당 클래스를 인스턴스화할 수 있도록 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="9c705-202">WPF에서 예로 사용자 코드에서 정의 될 때마다 한 <xref:System.Windows.Controls.UserControl> UI 동작을 리팩터링 하는 방법으로 하지만 사용 하 여 지원 클래스를 선언 하 여 암시 수 있는 모든 가능한 확장 메커니즘의 일부가 아니라 용도가 `public` 액세스 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="9c705-203">이러한는 <xref:System.Windows.Controls.UserControl> 선언할 수 있습니다 `internal` 액세스할 백업 코드 참조 XAML 형식으로는 같은 어셈블리에 컴파일됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="9c705-204">완전 신뢰 수준에서 XAML을 로드 하 여 사용 하는 응용 프로그램에 대 한 <xref:System.Xaml.XamlObjectWriter>, 인 클래스를 로드 `internal` 액세스 수준을 항상 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="9c705-205">부분 신뢰에서 XAML을 로드 하는 응용 프로그램을 사용 하 여 액세스 수준 특성을 제어할 수 있습니다는 <xref:System.Xaml.Permissions.XamlAccessLevel> API입니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="9c705-206">또한 지연 메커니즘 (예: WPF 서식 파일 시스템)를 액세스 수준 권한을 전파 되 고 최종 런타임 확인; 하기 위해 유지할 수 여야 합니다. 이 값은 전달 하 여 내부적으로 처리 되는 <xref:System.Xaml.Permissions.XamlAccessLevel> 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="9c705-207">WPF 구현</span><span class="sxs-lookup"><span data-stu-id="9c705-207">WPF Implementation</span></span>  
 <span data-ttu-id="9c705-208">WPF XAML 모델을 사용 하는 부분 신뢰 액세스를 BAML 부분 신뢰 환경에서 로드 되 면 액세스할 수 있습니다 <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> BAML 원본인 어셈블리에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="9c705-209">WPF 지연을 위해 사용 하 여 <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> 액세스 수준 정보를 전달 하기 위한 메커니즘으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="9c705-210">WPF XAML 용어에서는 *내부 형식* 참조 하는 XAML을 포함 하는 동일한 어셈블리에서 정의 된 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="9c705-211">어셈블리를 의도적으로 생략 하는 XAML 네임 스페이스를 통해 이러한 형식을 매핑할 수 = 매핑, 예를 들어 부분 `xmlns:local="clr-namespace:WPFApplication1"`합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="9c705-212">BAML 내부 형식을 참조 하는 경우 고 해당 형식의 `internal` 액세스 수준이이 생성 한 `GeneratedInternalTypeHelper` 어셈블리에 대 한 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="9c705-213">방지 하려는 경우 `GeneratedInternalTypeHelper`를 사용 하거나 `public` 액세스 수준이 또는 해야 관련 클래스를 별도 어셈블리에 모아 놓은 해당 어셈블리가 종속 되 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c705-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9c705-214">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9c705-214">See Also</span></span>  
 [<span data-ttu-id="9c705-215">사용자 지정 형식 및 라이브러리에 대한 XAML 관련 CLR 특성</span><span class="sxs-lookup"><span data-stu-id="9c705-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)  
 [<span data-ttu-id="9c705-216">XAML 서비스</span><span class="sxs-lookup"><span data-stu-id="9c705-216">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)

---
title: RCW
ms.date: 03/30/2017
helpviewer_keywords:
- COM interop, COM wrappers
- RCW
- COM wrappers
- runtime callable wrappers
- interoperation with unmanaged code, COM wrappers
ms.assetid: 7e542583-1e31-4e10-b523-8cf2f29cb4a4
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 7366bfd6459a9387e8c57092ba85cac5f4da125b
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33393512"
---
# <a name="runtime-callable-wrapper"></a><span data-ttu-id="ea15f-102">RCW</span><span class="sxs-lookup"><span data-stu-id="ea15f-102">Runtime Callable Wrapper</span></span>
<span data-ttu-id="ea15f-103">공용 언어 런타임은 RCW(런타임 호출 가능 래퍼)라는 프록시를 통해 COM 개체를 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-103">The common language runtime exposes COM objects through a proxy called the runtime callable wrapper (RCW).</span></span> <span data-ttu-id="ea15f-104">RCW는 .NET 클라이언트에 일반적인 개체인 것처럼 나타나지만 주요 기능이 .NET 클라이언트와 COM 개체 간의 호출을 마샬링하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-104">Although the RCW appears to be an ordinary object to .NET clients, its primary function is to marshal calls between a .NET client and a COM object.</span></span>  
  
 <span data-ttu-id="ea15f-105">런타임은 개체에 있는 참조 수에 관계없이 각 COM 개체에 대해 RCW를 정확한 한 개 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-105">The runtime creates exactly one RCW for each COM object, regardless of the number of references that exist on that object.</span></span> <span data-ttu-id="ea15f-106">런타임은 각 개체에 대해 프로세스당 하나의 RCW를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-106">The runtime maintains a single RCW per process for each object.</span></span>  <span data-ttu-id="ea15f-107">특정 응용 프로그램 도메인이나 아파트에서 RCW를 만든 다음 다른 응용 프로그램 도메인이나 아파트에 참조를 전달하는 경우 첫 번째 개체에 대한 프록시가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-107">If you create an RCW in one application domain or apartment, and then pass a reference to another application domain or apartment, a proxy to the first object will be used.</span></span>  <span data-ttu-id="ea15f-108">다음 그림과 같이 INew 및 INewer 인터페이스를 노출하는 COM 개체에 대한 참조가 임의 개수의 관리되는 클라이언트에 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-108">As the following illustration shows, any number of managed clients can hold a reference to the COM objects that expose INew and INewer interfaces.</span></span>  
  
 <span data-ttu-id="ea15f-109">![RCW](./media/rcw.gif "rcw")</span><span class="sxs-lookup"><span data-stu-id="ea15f-109">![RCW](./media/rcw.gif "rcw")</span></span>  
<span data-ttu-id="ea15f-110">런타임 호출 가능 래퍼를 통해 COM 개체 액세스</span><span class="sxs-lookup"><span data-stu-id="ea15f-110">Accessing COM objects through the runtime callable wrapper</span></span>  
  
 <span data-ttu-id="ea15f-111">형식 라이브러리에서 파생된 메타데이터를 사용하여 런타임은 호출되는 COM 개체와 해당 개체에 대한 래퍼를 둘 다 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-111">Using metadata derived from a type library, the runtime creates both the COM object being called and a wrapper for that object.</span></span> <span data-ttu-id="ea15f-112">각 RCW는 래핑하는 COM 개체에서 인터페이스 포인터 캐시를 유지 관리하고, RCW가 더 이상 필요하지 않으면 COM 개체에서 해당 참조를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-112">Each RCW maintains a cache of interface pointers on the COM object it wraps and releases its reference on the COM object when the RCW is no longer needed.</span></span> <span data-ttu-id="ea15f-113">런타임은 RCW에서 가비지 수집을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-113">The runtime performs garbage collection on the RCW.</span></span>  
  
 <span data-ttu-id="ea15f-114">다른 활동 중에서도 RCW는 래핑된 개체를 대신하여 관리 코드와 비관리 코드 간에 데이터를 마샬링합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-114">Among other activities, the RCW marshals data between managed and unmanaged code, on behalf of the wrapped object.</span></span> <span data-ttu-id="ea15f-115">특히, RCW는 클라이언트와 서버 간에 서로 다른 데이터 표현이 전달될 때마다 메서드 인수 및 메서드 반환 값에 대한 마샬링을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-115">Specifically, the RCW provides marshaling for method arguments and method return values whenever the client and server have different representations of the data passed between them.</span></span>  
  
 <span data-ttu-id="ea15f-116">표준 래퍼는 기본 제공 마샬링 규칙을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-116">The standard wrapper enforces built-in marshaling rules.</span></span> <span data-ttu-id="ea15f-117">예를 들어 .NET 클라이언트가 관리되지 않는 개체에 문자열 형식을 인수의 일부로 전달하는 경우 래퍼가 문자열을 BSTR 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-117">For example, when a .NET client passes a String type as part of an argument to an unmanaged object, the wrapper converts the string to a BSTR type.</span></span> <span data-ttu-id="ea15f-118">COM 개체가 관리되는 호출자에게 BSTR을 반환하는 경우 호출자는 문자열을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-118">Should the COM object return a BSTR to its managed caller, the caller receives a String.</span></span> <span data-ttu-id="ea15f-119">클라이언트와 서버 둘 다 익숙한 데이터를 보내고 받습니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-119">Both the client and the server send and receive data that is familiar to them.</span></span> <span data-ttu-id="ea15f-120">다른 형식은 변환이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-120">Other types require no conversion.</span></span> <span data-ttu-id="ea15f-121">예를 들어 표준 래퍼는 형식을 변환하지 않고 관리 코드와 비관리 코드 간에 항상 4바이트 정수를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-121">For instance, a standard wrapper will always pass a 4-byte integer between managed and unmanaged code without converting the type.</span></span>  
  
## <a name="marshaling-selected-interfaces"></a><span data-ttu-id="ea15f-122">선택한 인터페이스 마샬링</span><span class="sxs-lookup"><span data-stu-id="ea15f-122">Marshaling selected interfaces</span></span>  
 <span data-ttu-id="ea15f-123">RCW([런타임 호출 가능 래퍼](runtime-callable-wrapper.md))의 주요 목표는 관리되는 프로그래밍 모델과 관리되지 않는 프로그래밍 모델 간의 차이를 숨기는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-123">The primary goal of the [runtime callable wrapper](runtime-callable-wrapper.md) (RCW) is to hide the differences between the managed and unmanaged programming models.</span></span> <span data-ttu-id="ea15f-124">매끄러운 전환을 만들기 위해 RCW는 다음 그림과 같이 .NET 클라이언트에 노출하지 않고 선택한 COM 인터페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-124">To create a seamless transition, the RCW consumes selected COM interfaces without exposing them to the .NET client, as shown in the following illustration.</span></span>  
  
 <span data-ttu-id="ea15f-125">![인터페이스 포함 RCW](./media/rcwwithinterfaces.gif "rcwwithinterfaces")</span><span class="sxs-lookup"><span data-stu-id="ea15f-125">![RCW With Interfaces](./media/rcwwithinterfaces.gif "rcwwithinterfaces")</span></span>  
<span data-ttu-id="ea15f-126">COM 인터페이스 및 런타임 호출 가능 래퍼</span><span class="sxs-lookup"><span data-stu-id="ea15f-126">COM interfaces and the runtime callable wrapper</span></span>  
  
 <span data-ttu-id="ea15f-127">초기 바인딩된 개체로 만들어진 경우 RCW는 특정 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-127">When created as an early-bound object, the RCW is a specific type.</span></span> <span data-ttu-id="ea15f-128">COM 개체가 구현하는 인터페이스를 구현하고 개체의 인터페이스에서 메서드, 속성 및 이벤트를 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-128">It implements the interfaces that the COM object implements and exposes the methods, properties, and events from the object's interfaces.</span></span> <span data-ttu-id="ea15f-129">그림에서 RCW는 INew 인터페이스를 노출하지만 **IUnknown** 및 **IDispatch** 인터페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-129">In the illustration, the RCW exposes the INew interface but consumes the **IUnknown** and **IDispatch** interfaces.</span></span> <span data-ttu-id="ea15f-130">또한 RCW는 INew 인터페이스의 모든 멤버를 .NET 클라이언트에 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-130">Further, the RCW exposes all members of the INew interface to the .NET client.</span></span>  
  
 <span data-ttu-id="ea15f-131">RCW는 래핑하는 개체에 의해 노출되는, 다음 표에 나열된 인터페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-131">The RCW consumes the interfaces listed in the following table, which are exposed by the object it wraps.</span></span>  
  
|<span data-ttu-id="ea15f-132">인터페이스</span><span class="sxs-lookup"><span data-stu-id="ea15f-132">Interface</span></span>|<span data-ttu-id="ea15f-133">설명</span><span class="sxs-lookup"><span data-stu-id="ea15f-133">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="ea15f-134">**IDispatch**</span><span class="sxs-lookup"><span data-stu-id="ea15f-134">**IDispatch**</span></span>|<span data-ttu-id="ea15f-135">리플렉션을 통해 런타임에 COM 개체에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-135">For late binding to COM objects through reflection.</span></span>|  
|<span data-ttu-id="ea15f-136">**IErrorInfo**</span><span class="sxs-lookup"><span data-stu-id="ea15f-136">**IErrorInfo**</span></span>|<span data-ttu-id="ea15f-137">오류, 소스, 도움말 파일, 도움말 컨텍스트에 대한 설명과 오류를 정의한 인터페이스의 GUID를 제공합니다(.NET 클래스의 경우 항상 **GUID_NULL**).</span><span class="sxs-lookup"><span data-stu-id="ea15f-137">Provides a textual description of the error, its source, a Help file, Help context, and the GUID of the interface that defined the error (always **GUID_NULL** for .NET classes).</span></span>|  
|<span data-ttu-id="ea15f-138">**IProvideClassInfo**</span><span class="sxs-lookup"><span data-stu-id="ea15f-138">**IProvideClassInfo**</span></span>|<span data-ttu-id="ea15f-139">래핑되는 COM 개체가 **IProvideClassInfo**를 구현하는 경우 RCW는 이 인터페이스에서 형식 정보를 추출하여 더 나은 형식 ID를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-139">If the COM object being wrapped implements **IProvideClassInfo**, the RCW extracts the type information from this interface to provide better type identity.</span></span>|  
|<span data-ttu-id="ea15f-140">**IUnknown**</span><span class="sxs-lookup"><span data-stu-id="ea15f-140">**IUnknown**</span></span>|<span data-ttu-id="ea15f-141">개체 ID, 형식 강제 변환 및 수명 관리에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-141">For object identity, type coercion, and lifetime management:</span></span><br /><br /> <span data-ttu-id="ea15f-142">-   개체 ID</span><span class="sxs-lookup"><span data-stu-id="ea15f-142">-   Object identity</span></span><br />     <span data-ttu-id="ea15f-143">런타임은 각 개체에 대한 **IUnknown** 인터페이스의 값을 비교하여 COM 개체를 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-143">The runtime distinguishes between COM objects by comparing the value of the **IUnknown** interface for each object.</span></span><br /><span data-ttu-id="ea15f-144">-   형식 강제 변환</span><span class="sxs-lookup"><span data-stu-id="ea15f-144">-   Type coercion</span></span><br />     <span data-ttu-id="ea15f-145">RCW는 **QueryInterface** 메서드에 의해 수행된 동적 형식 검색을 인식합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-145">The RCW recognizes the dynamic type discovery performed by the **QueryInterface** method.</span></span><br /><span data-ttu-id="ea15f-146">-   수명 관리</span><span class="sxs-lookup"><span data-stu-id="ea15f-146">-   Lifetime management</span></span><br />     <span data-ttu-id="ea15f-147">**QueryInterface** 메서드를 통해 RCW는 관리되지 않는 개체에 대한 참조를 가져오고, 런타임이 래퍼에 대해 가비지 수집을 수행하여 관리되지 않는 개체를 해제할 때까지 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-147">Using the **QueryInterface** method, the RCW gets and holds a reference to an unmanaged object until the runtime performs garbage collection on the wrapper, which releases the unmanaged object.</span></span>|  
  
 <span data-ttu-id="ea15f-148">필요에 따라 RCW는 래핑하는 개체에 의해 노출되는, 다음 표에 나열된 인터페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-148">The RCW optionally consumes the interfaces listed in the following table, which are exposed by the object it wraps.</span></span>  
  
|<span data-ttu-id="ea15f-149">인터페이스</span><span class="sxs-lookup"><span data-stu-id="ea15f-149">Interface</span></span>|<span data-ttu-id="ea15f-150">설명</span><span class="sxs-lookup"><span data-stu-id="ea15f-150">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="ea15f-151">**IConnectionPoint** 및 **IConnectionPointContainer**</span><span class="sxs-lookup"><span data-stu-id="ea15f-151">**IConnectionPoint** and **IConnectionPointContainer**</span></span>|<span data-ttu-id="ea15f-152">RCW는 연결 지점 이벤트 스타일을 대리자 기반 이벤트에 노출하는 개체를 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-152">The RCW converts objects that expose the connection-point event style to delegate-based events.</span></span>|  
|<span data-ttu-id="ea15f-153">**IDispatchEx**</span><span class="sxs-lookup"><span data-stu-id="ea15f-153">**IDispatchEx**</span></span>|<span data-ttu-id="ea15f-154">클래스가 **IDispatchEx**를 구현하는 경우 RCW는 **IExpando**를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-154">If the class implements **IDispatchEx**, the RCW implements **IExpando**.</span></span> <span data-ttu-id="ea15f-155">**IDispatchEx** 인터페이스는 **IDispatch**와 달리 멤버의 대/소문자 구분 호출, 열거형, 추가, 삭제를 가능하게 하는 **IDispatch** 인터페이스의 확장입니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-155">The **IDispatchEx** interface is an extension of the **IDispatch** interface that, unlike **IDispatch**, enables enumeration, addition, deletion, and case-sensitive calling of members.</span></span>|  
|<span data-ttu-id="ea15f-156">**IEnumVARIANT**</span><span class="sxs-lookup"><span data-stu-id="ea15f-156">**IEnumVARIANT**</span></span>|<span data-ttu-id="ea15f-157">열거형을 지원하는 COM 형식이 컬렉션으로 처리될 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea15f-157">Enables COM types that support enumerations to be treated as collections.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="ea15f-158">참고 항목</span><span class="sxs-lookup"><span data-stu-id="ea15f-158">See Also</span></span>  
 [<span data-ttu-id="ea15f-159">COM 래퍼</span><span class="sxs-lookup"><span data-stu-id="ea15f-159">COM Wrappers</span></span>](com-wrappers.md)  
 <span data-ttu-id="ea15f-160">[선택한 인터페이스 마샬링](https://msdn.microsoft.com/library/fdb97fd0-f694-4832-bf15-a4e7cf413840(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="ea15f-160">[Marshaling Selected Interfaces](https://msdn.microsoft.com/library/fdb97fd0-f694-4832-bf15-a4e7cf413840(v=vs.100))</span></span>  
 [<span data-ttu-id="ea15f-161">COM 호출 가능 래퍼</span><span class="sxs-lookup"><span data-stu-id="ea15f-161">COM Callable Wrapper</span></span>](com-callable-wrapper.md)  
 <span data-ttu-id="ea15f-162">[형식 라이브러리를 어셈블리로 변환 요약](https://msdn.microsoft.com/library/bf3f90c5-4770-4ab8-895c-3ba1055cc958(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="ea15f-162">[Type Library to Assembly Conversion Summary](https://msdn.microsoft.com/library/bf3f90c5-4770-4ab8-895c-3ba1055cc958(v=vs.100))</span></span>  
 [<span data-ttu-id="ea15f-163">형식 라이브러리를 어셈블리로 가져오기</span><span class="sxs-lookup"><span data-stu-id="ea15f-163">Importing a Type Library as an Assembly</span></span>](importing-a-type-library-as-an-assembly.md)

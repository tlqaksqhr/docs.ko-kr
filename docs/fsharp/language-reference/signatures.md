---
title: 서명(F#)
description: 'F # 시그니처 파일을 사용 하 여 형식, 네임 스페이스 및 모듈 등 F # 프로그램 요소를 집합의 공개 서명에 대 한 정보를 보관 하는 방법에 알아봅니다.'
ms.date: 05/16/2016
ms.openlocfilehash: 6e182a1a0ac7f3f9fab27026e582d83ee737822e
ms.sourcegitcommit: e5bb395ec86f536e114314184288f40a8c745e2e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/12/2018
---
# <a name="signatures"></a>서명

서명 파일에는 형식, 네임스페이스, 모듈 등 F# 프로그램 요소 집합의 공개 서명에 대한 정보가 포함됩니다. 이러한 프로그램 요소의 접근성을 지정하는 데 사용할 수 있습니다.


## <a name="remarks"></a>설명
각 F# 코드 파일에 대해 코드 파일과 이름이 같지만 확장명이 .fs가 아니라 .fsi인 *서명 파일*이 있을 수 있습니다. 명령줄을 직접 사용하는 경우 컴파일 명령줄에 서명 파일을 추가할 수도 있습니다. 코드 파일과 서명 파일을 구분하기 위해 코드 파일을 *구현 파일*이라고도 합니다. 프로젝트에서 서명 파일이 연결된 코드 파일 앞에 와야 합니다.

서명 파일은 해당 구현 파일의 네임스페이스, 모듈, 형식 및 멤버에 대해 설명합니다. 서명 파일의 정보를 사용하여 구현 파일 외부 코드에서 액세스할 수 있는 해당 구현 파일의 코드 부분 및 구현 파일 내부 부분을 지정합니다. 서명 파일에 포함된 네임스페이스, 모듈 및 형식은 구현 파일에 포함된 네임스페이스, 모듈 및 형식의 하위 집합이어야 합니다. 이 항목의 뒷부분에서 설명하는 몇 가지 예외를 제외하고 서명 파일에 나열되지 않은 언어 요소는 구현 파일 전용으로 간주됩니다. 프로젝트 또는 명령줄에 서명 파일이 없는 경우 기본 접근성이 사용됩니다.

기본 액세스 가능성에 대 한 자세한 내용은 참조 [액세스 제어](access-control.md)합니다.

서명 파일에서 형식 정의와 각 메서드 또는 함수의 구현을 반복하지 않습니다. 대신, 모듈 또는 네임스페이스 조각에 의해 구현되는 기능의 전체 사양 역할을 하는 각 메서드 및 함수에 대한 서명을 사용합니다. 형식 서명에 대한 구문은 인터페이스 및 추상 클래스의 추상 메서드 선언에 사용되는 구문과 동일하며 올바르게 컴파일된 입력을 표시할 경우 IntelliSense 및 F# 인터프리터 fsi.exe에 의해서도 표시됩니다.

형식 서명의 정보가 형식의 봉인 여부 또는 인터페이스 형식인지 여부를 나타내는 데 충분하지 않을 경우 형식의 속성을 나타내는 특성을 컴파일러에 추가해야 합니다. 이 목적에 사용하는 특성은 다음 표에서 설명합니다.



|특성|설명|
|---------|-----------|
|`[<Sealed>]`|추상 멤버가 없거나 확장되지 않아야 하는 형식에 사용됩니다.|
|`[<Interface>]`|인터페이스인 형식에 사용됩니다.|
구현 파일의 선언과 서명 간에 특성이 일치하지 않는 경우 컴파일러에서 오류가 발생합니다.

`val` 키워드를 사용하여 값 또는 함수 값에 대한 서명을 만듭니다. `type` 키워드는 형식 서명을 소개합니다.

`--sig` 컴파일러 옵션을 사용하여 서명 파일을 생성할 수 있습니다. 일반적으로 .fsi 파일은 수동으로 작성하지 않습니다. 대신, 컴파일러를 사용하여 .fsi 파일을 생성하고, 프로젝트에 추가한 다음(있는 경우) 액세스할 수 없게 하려는 메서드 및 함수를 제거하여 편집합니다.

형식 서명에 대한 다음 몇 가지 규칙이 있습니다.


- 구현 파일의 형식 약어는 서명 파일의 약어가 없는 형식과 일치하지 않아야 합니다.


- 레코드 및 구분된 공용 구조체는 해당 필드와 생성자를 모두 노출하거나 하나도 노출하지 않아야 하며, 서명의 순서가 구현 파일의 순서와 일치해야 합니다. 클래스는 서명의 해당 필드와 메서드를 일부 또는 모두 표시하거나 하나도 표시하지 않을 수 있습니다.


- 생성자가 있는 클래스와 구조체는 해당 기본 클래스의 선언( `inherits` 선언)을 노출해야 합니다. 또한 생성자가 있는 클래스와 구조체는 모든 추상 메서드 및 인터페이스 선언을 노출해야 합니다.


- 인터페이스 형식은 모든 메서드 및 인터페이스를 노출해야 합니다.


값 서명에 대한 규칙은 다음과 같습니다.


- 서명의 접근성 한정자(`public`, `internal`등)와 `inline` 및 `mutable` 한정자는 구현의 해당 한정자와 일치해야 합니다.


- 암시적으로 유추되거나 명시적으로 선언된 제네릭 형식 매개 변수 개수가 일치해야 하고, 제네릭 형식 매개 변수의 형식 및 형식 제약 조건이 일치해야 합니다.


- `Literal` 특성을 사용하는 경우 서명과 구현 둘 다에 표시되어야 하며, 둘 다에 동일한 리터럴 값을 사용해야 합니다.


- 서명 및 구현의 매개 변수 패턴( *인자*라고도 함)이 일치해야 합니다.


- 서명 파일의 매개 변수 이름을 해당 구현 파일에서 다른 경우 서명 파일에 있는 이름 대신 사용 됩니다, 디버깅 또는 프로 파일링 하는 경우 문제를 일으킬 수 있는 합니다. 이러한 불일치 3218 프로젝트 파일의 경고 활성화 알림을 받을 하려는 경우 또는 컴파일러를 호출할 때 (참조 `--warnon` 아래 [컴파일러 옵션](compiler-options.md)).


다음 코드 예제에서는 해당 특성과 함께 네임스페이스, 모듈, 함수 값 및 형식 서명을 포함하는 서명 파일의 예를 보여 줍니다. 또한 해당 구현 파일을 보여 줍니다.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssignatures/snippet9002.fs)]

다음 코드에서는 구현 파일을 보여 줍니다.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssignatures/snippet9001.fs)]
    
## <a name="see-also"></a>참고 항목
[F# 언어 참조](index.md)

[Access Control](access-control.md)

[컴파일러 옵션](compiler-options.md)

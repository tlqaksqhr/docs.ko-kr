---
title: 산술 연산자(F#)
description: 'F # 프로그래밍 언어에서 사용할 수 있는 산술 연산자에 알아봅니다.'
author: cartermp
ms.author: phcart
ms.date: 04/04/2018
ms.topic: language-reference
ms.prod: dotnet-fsharp
ms.devlang: fsharp
ms.openlocfilehash: 147600751ca8f991a7d5af24d1a63beb15ccab10
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/28/2018
---
# <a name="arithmetic-operators"></a><span data-ttu-id="3013f-103">산술 연산자</span><span class="sxs-lookup"><span data-stu-id="3013f-103">Arithmetic Operators</span></span>

<span data-ttu-id="3013f-104">이 항목에서는 F # 언어에서 사용할 수 있는 산술 연산자를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-104">This topic describes arithmetic operators that are available in the F# language.</span></span>

## <a name="summary-of-binary-arithmetic-operators"></a><span data-ttu-id="3013f-105">이진 산술 연산자 요약</span><span class="sxs-lookup"><span data-stu-id="3013f-105">Summary of Binary Arithmetic Operators</span></span>
<span data-ttu-id="3013f-106">다음 표에서 unboxed 정수 및 부동 소수점 형식에 사용할 수 있는 이진 산술 연산자를 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-106">The following table summarizes the binary arithmetic operators that are available for unboxed integral and floating-point types.</span></span>

|<span data-ttu-id="3013f-107">이항 연산자</span><span class="sxs-lookup"><span data-stu-id="3013f-107">Binary operator</span></span>|<span data-ttu-id="3013f-108">노트</span><span class="sxs-lookup"><span data-stu-id="3013f-108">Notes</span></span>|
|---------------|-----|
|<span data-ttu-id="3013f-109">`+` (또한 플러스)</span><span class="sxs-lookup"><span data-stu-id="3013f-109">`+` (addition, plus)</span></span>|<span data-ttu-id="3013f-110">선택 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-110">Unchecked.</span></span> <span data-ttu-id="3013f-111">합계와 함께 번호는 추가 하면 가능한 오버플로 조건을 형식에서 지 원하는 절대 최대값을 초과 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-111">Possible overflow condition when numbers are added together and the sum exceeds the maximum absolute value supported by the type.</span></span>|
|<span data-ttu-id="3013f-112">`-` (빼기, 빼기)</span><span class="sxs-lookup"><span data-stu-id="3013f-112">`-` (subtraction, minus)</span></span>|<span data-ttu-id="3013f-113">선택 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-113">Unchecked.</span></span> <span data-ttu-id="3013f-114">언더플로 상태가 발생할 수 부호 없는 형식을 뺀 또는 부동 소수점 값이 너무 작아서 형식으로 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-114">Possible underflow condition when unsigned types are subtracted, or when floating-point values are too small to be represented by the type.</span></span>|
|<span data-ttu-id="3013f-115">`*` (곱하기, 시간)</span><span class="sxs-lookup"><span data-stu-id="3013f-115">`*` (multiplication, times)</span></span>|<span data-ttu-id="3013f-116">선택 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-116">Unchecked.</span></span> <span data-ttu-id="3013f-117">숫자를 곱해 하면 가능한 오버플로 조건 및 제품 형식에서 지 원하는 절대 최대값을 초과 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-117">Possible overflow condition when numbers are multiplied and the product exceeds the maximum absolute value supported by the type.</span></span>|
|<span data-ttu-id="3013f-118">`/` (나누기)</span><span class="sxs-lookup"><span data-stu-id="3013f-118">`/` (division, divided by)</span></span>|<span data-ttu-id="3013f-119">0으로 나누기는 <xref:System.DivideByZeroException> 정수 계열 형식에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-119">Division by zero causes a <xref:System.DivideByZeroException> for integral types.</span></span> <span data-ttu-id="3013f-120">부동 소수점 형식에 대 한 0으로 나누기 하면 특수 한 부동 소수점 값 `+Infinity` 또는 `-Infinity`합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-120">For floating-point types, division by zero gives you the special floating-point values `+Infinity` or `-Infinity`.</span></span> <span data-ttu-id="3013f-121">이기도 가능한 언더플로 조건을 부동 소수점 숫자는 너무 작아서 형식으로 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-121">There is also a possible underflow condition when a floating-point number is too small to be represented by the type.</span></span>|
|<span data-ttu-id="3013f-122">`%` (나머지, rem)</span><span class="sxs-lookup"><span data-stu-id="3013f-122">`%` (remainder, rem)</span></span>|<span data-ttu-id="3013f-123">나누기 연산의 나머지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-123">Returns the remainder of a division operation.</span></span> <span data-ttu-id="3013f-124">결과의 부호가 첫 번째 피연산자의 부호와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-124">The sign of the result is the same as the sign of the first operand.</span></span>|
|<span data-ttu-id="3013f-125">`**` (의 지 수)</span><span class="sxs-lookup"><span data-stu-id="3013f-125">`**` (exponentiation, to the power of)</span></span>|<span data-ttu-id="3013f-126">결과 형식에 대 한 절대 최대값을 초과 하는 경우 가능한 오버플로 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-126">Possible overflow condition when the result exceeds the maximum absolute value for the type.</span></span><br /><br /><span data-ttu-id="3013f-127">지 수 연산자 부동 소수점 형식 에서만 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-127">The exponentiation operator works only with floating-point types.</span></span>|

## <a name="summary-of-unary-arithmetic-operators"></a><span data-ttu-id="3013f-128">단항 산술 연산자 요약</span><span class="sxs-lookup"><span data-stu-id="3013f-128">Summary of Unary Arithmetic Operators</span></span>
<span data-ttu-id="3013f-129">다음 표에서 정수 및 부동 소수점 형식에 사용할 수 있는 단항 산술 연산자를 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-129">The following table summarizes the unary arithmetic operators that are available for integral and floating-point types.</span></span>


|<span data-ttu-id="3013f-130">단항 연산자</span><span class="sxs-lookup"><span data-stu-id="3013f-130">Unary operator</span></span>|<span data-ttu-id="3013f-131">노트</span><span class="sxs-lookup"><span data-stu-id="3013f-131">Notes</span></span>|
|--------------|-----|
|<span data-ttu-id="3013f-132">`+` (양수)</span><span class="sxs-lookup"><span data-stu-id="3013f-132">`+` (positive)</span></span>|<span data-ttu-id="3013f-133">모든 산술 식에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-133">Can be applied to any arithmetic expression.</span></span> <span data-ttu-id="3013f-134">값의 부호는 변경 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-134">Does not change the sign of the value.</span></span>|
|<span data-ttu-id="3013f-135">`-` (부정, 음수)</span><span class="sxs-lookup"><span data-stu-id="3013f-135">`-` (negation, negative)</span></span>|<span data-ttu-id="3013f-136">모든 산술 식에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-136">Can be applied to any arithmetic expression.</span></span> <span data-ttu-id="3013f-137">값의 부호를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-137">Changes the sign of the value.</span></span>|
<span data-ttu-id="3013f-138">주위에 배치 하에서 오버플로 또는 언더플로 정수 계열 형식에 대 한 동작이입니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-138">The behavior at overflow or underflow for integral types is to wrap around.</span></span> <span data-ttu-id="3013f-139">이렇게 하면 잘못 된 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-139">This causes an incorrect result.</span></span> <span data-ttu-id="3013f-140">정수 오버플로 소프트웨어에 대 한 계정에 기록 되지 않습니다 때 보안 문제를 일으킬 수 있는 잠재적으로 심각한 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-140">Integer overflow is a potentially serious problem that can contribute to security issues when software is not written to account for it.</span></span> <span data-ttu-id="3013f-141">응용 프로그램에 대 한 우려 경우 하에서 확인 된 연산자를 사용 하 여 `Microsoft.FSharp.Core.Operators.Checked`합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-141">If this is a concern for your application, consider using the checked operators in `Microsoft.FSharp.Core.Operators.Checked`.</span></span>


## <a name="summary-of-binary-comparison-operators"></a><span data-ttu-id="3013f-142">이진 비교 연산자 요약</span><span class="sxs-lookup"><span data-stu-id="3013f-142">Summary of Binary Comparison Operators</span></span>
<span data-ttu-id="3013f-143">다음 표에서 정수 및 부동 소수점 형식에 사용할 수 있는 이진 비교 연산자를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-143">The following table shows the binary comparison operators that are available for integral and floating-point types.</span></span> <span data-ttu-id="3013f-144">이러한 연산자의 반환 값 형식 `bool`합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-144">These operators return values of type `bool`.</span></span>

<span data-ttu-id="3013f-145">부동 소수점 숫자를 직접 비교할 수 없습니다, 동등 여부에 대 한 IEEE 부동 소수점 표시 된 값이 같은지를 지원 하지 않으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-145">Floating-point numbers should never be directly compared for equality, because the IEEE floating-point representation does not support an exact equality operation.</span></span> <span data-ttu-id="3013f-146">두 숫자 코드를 검사 하 여 동일한 것으로 쉽게 확인할 수 있는 서로 다른 비트 표현의 있을 실제로 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-146">Two numbers that you can easily verify to be equal by inspecting the code might actually have different bit representations.</span></span>



|<span data-ttu-id="3013f-147">연산자</span><span class="sxs-lookup"><span data-stu-id="3013f-147">Operator</span></span>|<span data-ttu-id="3013f-148">노트</span><span class="sxs-lookup"><span data-stu-id="3013f-148">Notes</span></span>|
|--------|-----|
|<span data-ttu-id="3013f-149">`=` (같음)</span><span class="sxs-lookup"><span data-stu-id="3013f-149">`=` (equality, equals)</span></span>|<span data-ttu-id="3013f-150">할당 연산자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-150">This is not an assignment operator.</span></span> <span data-ttu-id="3013f-151">비교에 대해서만 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-151">It is used only for comparison.</span></span> <span data-ttu-id="3013f-152">일반 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-152">This is a generic operator.</span></span>|
|<span data-ttu-id="3013f-153">`>` (보다 큼)</span><span class="sxs-lookup"><span data-stu-id="3013f-153">`>` (greater than)</span></span>|<span data-ttu-id="3013f-154">일반 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-154">This is a generic operator.</span></span>|
|<span data-ttu-id="3013f-155">`<` (보다 작음)</span><span class="sxs-lookup"><span data-stu-id="3013f-155">`<` (less than)</span></span>|<span data-ttu-id="3013f-156">일반 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-156">This is a generic operator.</span></span>|
|<span data-ttu-id="3013f-157">`>=` (크거나 같음)</span><span class="sxs-lookup"><span data-stu-id="3013f-157">`>=` (greater than or equals)</span></span>|<span data-ttu-id="3013f-158">일반 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-158">This is a generic operator.</span></span>|
|<span data-ttu-id="3013f-159">`<=` (보다 작거나 같음)</span><span class="sxs-lookup"><span data-stu-id="3013f-159">`<=` (less than or equals)</span></span>|<span data-ttu-id="3013f-160">일반 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-160">This is a generic operator.</span></span>|
|<span data-ttu-id="3013f-161">`<>` (같지 않음)</span><span class="sxs-lookup"><span data-stu-id="3013f-161">`<>` (not equal)</span></span>|<span data-ttu-id="3013f-162">일반 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-162">This is a generic operator.</span></span>|

## <a name="overloaded-and-generic-operators"></a><span data-ttu-id="3013f-163">제네릭 및 오버 로드 된 연산자</span><span class="sxs-lookup"><span data-stu-id="3013f-163">Overloaded and Generic Operators</span></span>
<span data-ttu-id="3013f-164">에 정의 된 모든이 여기에 나온 연산자는 **Microsoft.FSharp.Core.Operators** 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-164">All of the operators discussed in this topic are defined in the **Microsoft.FSharp.Core.Operators** namespace.</span></span> <span data-ttu-id="3013f-165">일부 연산자는 정적으로 확인 된 형식 매개 변수를 사용 하 여 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-165">Some of the operators are defined by using statically resolved type parameters.</span></span> <span data-ttu-id="3013f-166">해당 연산자를 사용 하는 각 특정 형식에 대 한 개별 정의 됨을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-166">This means that there are individual definitions for each specific type that works with that operator.</span></span> <span data-ttu-id="3013f-167">단항 및 이항 산술 및 비트 연산자의 모든이 범주에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-167">All of the unary and binary arithmetic and bitwise operators are in this category.</span></span> <span data-ttu-id="3013f-168">비교 연산자는 제네릭 및 따라서 하지 기본 산술 형식 뿐, 모든 유형과 함께 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-168">The comparison operators are generic and therefore work with any type, not just primitive arithmetic types.</span></span> <span data-ttu-id="3013f-169">구별 된 공용 구조체 및 레코드 형식을 F # 컴파일러에 의해 생성 되는 고유한 사용자 지정 구현이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-169">Discriminated union and record types have their own custom implementations that are generated by the F# compiler.</span></span> <span data-ttu-id="3013f-170">메서드를 사용 하는 클래스 형식 <xref:System.Object.Equals%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-170">Class types use the method <xref:System.Object.Equals%2A>.</span></span>

<span data-ttu-id="3013f-171">일반 연산자를 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-171">The generic operators are customizable.</span></span> <span data-ttu-id="3013f-172">비교 함수를 사용자 지정 하려면 재정의 <xref:System.Object.Equals%2A> 사용자 고유의 사용자 지정 같음 비교를 제공 하 고 다음 구현에 <xref:System.IComparable>합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-172">To customize the comparison functions, override <xref:System.Object.Equals%2A> to provide your own custom equality comparison, and then implement <xref:System.IComparable>.</span></span> <span data-ttu-id="3013f-173"><xref:System.IComparable?displayProperty=nameWithType> 인터페이스에는 단일 메서드는 <xref:System.IComparable.CompareTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3013f-173">The <xref:System.IComparable?displayProperty=nameWithType> interface has a single method, the <xref:System.IComparable.CompareTo%2A> method.</span></span>


## <a name="operators-and-type-inference"></a><span data-ttu-id="3013f-174">연산자 및 형식 유추</span><span class="sxs-lookup"><span data-stu-id="3013f-174">Operators and Type Inference</span></span>
<span data-ttu-id="3013f-175">식에서 연산자를 사용 하는 연산자에는 형식 유추를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-175">The use of an operator in an expression constrains type inference on that operator.</span></span> <span data-ttu-id="3013f-176">또한 연산자의 사용 방지 연산자는 산술 형식 의미 하기 때문에 자동 일반화 합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-176">Also, the use of operators prevents automatic generalization, because the use of operators implies an arithmetic type.</span></span> <span data-ttu-id="3013f-177">다른 정보가 없는 경우, F # 컴파일러에서 유추 `int` 산술 식의 형식으로.</span><span class="sxs-lookup"><span data-stu-id="3013f-177">In the absence of any other information, the F# compiler infers `int` as the type of arithmetic expressions.</span></span> <span data-ttu-id="3013f-178">다른 형식을 지정 하 여이 동작을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-178">You can override this behavior by specifying another type.</span></span> <span data-ttu-id="3013f-179">인수 형식 및 반환 형식은 따라서 `function1` 다음 코드에서는 것으로 유추 됩니다 `int`에 대 한 형식 `function2` 것으로 유추 `float`합니다.</span><span class="sxs-lookup"><span data-stu-id="3013f-179">Thus the argument types and return type of `function1` in the following code are inferred to be `int`, but the types for `function2` are inferred to be `float`.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3501.fs)]
    
## <a name="see-also"></a><span data-ttu-id="3013f-180">참고 항목</span><span class="sxs-lookup"><span data-stu-id="3013f-180">See Also</span></span>
[<span data-ttu-id="3013f-181">기호 및 연산자 참조</span><span class="sxs-lookup"><span data-stu-id="3013f-181">Symbol and Operator Reference</span></span>](index.md)

[<span data-ttu-id="3013f-182">연산자 오버로드</span><span class="sxs-lookup"><span data-stu-id="3013f-182">Operator Overloading</span></span>](../operator-overloading.md)

[<span data-ttu-id="3013f-183">비트 연산자</span><span class="sxs-lookup"><span data-stu-id="3013f-183">Bitwise Operators</span></span>](bitwise-operators.md)

[<span data-ttu-id="3013f-184">부울 연산자</span><span class="sxs-lookup"><span data-stu-id="3013f-184">Boolean Operators</span></span>](boolean-operators.md)

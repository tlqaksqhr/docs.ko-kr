---
title: 컴파일러 지시문(F#)
description: 'F # 언어 전처리기 지시문, 조건부 컴파일 지시문, line 지시문과 컴파일러 지시문에 알아봅니다.'
ms.date: 05/16/2016
ms.openlocfilehash: 5b7974d586b085ad8a40bc2d872cdd425494475a
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
---
# <a name="compiler-directives"></a>컴파일러 지시문

이 항목에서는 처리기 지시문과 컴파일러 지시문에 대해 설명합니다.


## <a name="preprocessor-directives"></a>전처리기 지시문
전처리기 지시문은 # 기호를 접두사로 사용하며 따로 한 줄을 할애하여 지시문을 작성합니다. 이 지시문은 컴파일러 자체보다 먼저 실행되는 전처리기를 통해 해석됩니다.

다음 표에는 F#에서 사용할 수 있는 전처리기 지시문의 목록이 나와 있습니다.


|지시문|설명|
|---------|-----------|
|`#if` *symbol*|조건부 컴파일을 지원합니다. 다음 섹션의 코드는 `#if` 경우 포함 됩니다는 *기호* 정의 됩니다.|
|`#else`|조건부 컴파일을 지원합니다. 위의 `#if`와 함께 사용되는 기호를 정의하지 않은 경우 포함할 코드 섹션을 표시합니다.|
|`#endif`|조건부 컴파일을 지원합니다. 코드의 조건부 섹션이 끝나는 지점을 표시합니다.|
|`#`[line] *int*,<br/>`#`[line] *int* *string*,<br/>`#`[line] *int* *verbatim-string*|디버깅을 위해 원본 소스 코드 줄과 파일 이름을 표시합니다. 이 기능은 F# 소스 코드를 생성하는 도구에서 사용할 수 있습니다.|
|`#nowarn` *warningcode*|컴파일러 경고를 해제합니다. 경고를 해제하려면 컴파일러 출력에서 해당 번호를 찾아 따옴표에 포함합니다. "FS" 접두사를 생략합니다. 같은 줄에서 여러 경고 번호를 해제하려면 각 번호를 따옴표에 포함하고 각 문자열을 공백으로 구분합니다. 예를 들어:

`#nowarn "9" "40"`


경고 해제 효과 지시문 앞에 있는 파일의 일부를 포함 하 여 전체 파일에 적용 됩니다. |

## <a name="conditional-compilation-directives"></a>조건부 컴파일 지시문
이러한 지시문 중 하나에 의해 비활성화 된 코드는 Visual studio 코드 편집기에서 흐리게 표시 됩니다.


>[!NOTE] 
다른 언어에 있는 그대로 동일한 조건부 컴파일 지시문의 동작을 볼 수 없습니다. 예를 들어 기호가 포함된 부울 식은 사용할 수 없으며 `true` 및 `false`가 특별한 의미를 가지지도 않습니다. `if` 지시문에 사용하는 기호는 명령줄이나 프로젝트 설정에서 정의해야 합니다. `define` 전처리기 지시문이 없습니다.


다음 코드에서는 `#if`, `#else` 및 `#endif` 지시문을 사용하는 방법을 보여 줍니다. 이 예제의 코드에는 `function1`에 대한 두 가지 버전의 정의가 포함되어 있습니다. 때 `VERSION1` 사용 하 여 정의 [-define 컴파일러 옵션](https://msdn.microsoft.com/library/434394ae-0d4a-459c-a684-bffede519a04), 사이 코드는 `#if` 지시문 및 `#else` 지시문 활성화 됩니다. 그렇지 않은 경우에는 `#else`와 `#endif` 사이의 코드가 활성화됩니다.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet7301.fs)]

F#에는 `#define` 전처리기 지시문이 없습니다. `#if` 지시문에 사용되는 기호를 정의하려면 컴파일러 옵션이나 프로젝트 설정을 사용해야 합니다.

조건부 컴파일 지시문은 중첩하여 사용할 수 있습니다. 전처리기 지시문에서 들여쓰기는 중요하지 않습니다.


## <a name="line-directives"></a>줄 지시문
빌드 과정에서 컴파일러를 통해 F# 코드의 오류를 보고할 때는 각 오류의 발생 지점에 해당하는 줄 번호가 참조 정보로 사용됩니다. 이러한 줄 번호는 1부터 시작합니다. 파일의 맨 첫 줄이 1번입니다. 그러나 다른 도구를 사용하여 F# 소스 코드를 생성하는 경우에는 생성된 코드의 줄 번호가 일반적으로 크게 중요하지 않습니다. 생성된 F# 코드의 오류가 다른 소스에서 발생한 것일 가능성이 높기 때문입니다. `#line` 지시문을 사용하면 다른 도구를 통해 F# 소스 코드를 생성할 때 원래 줄 번호와 소스 파일에 대한 정보를 생성된 F# 코드에 전달할 수 있습니다.

`#line` 지시문을 사용하는 경우 파일 이름을 따옴표로 묶어야 합니다. 문자열 앞에 축자 토큰(`@`)이 오지 않는 경우 백슬래시 문자를 경로에 사용하려면 한 개가 아닌 두 개의 백슬래시 문자를 사용하여 이를 이스케이프해야 합니다. 다음은 유효한 줄 토큰입니다. 이 예제에서는 도구를 사용하여 원래 파일 `Script1`을 실행한 결과로 F# 코드 파일이 자동 생성되며 이러한 지시문이 있는 위치의 코드가 파일 `Script1`의 25번 줄에 있는 몇몇 토큰으로부터 생성되는 것으로 가정합니다.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet7303.fs)]

이 토큰은 해당 위치에서 생성되는 F# 코드가 `Script1`의 `25`번 줄 또는 그 부근에 있는 몇몇 구문으로부터 파생됨을 나타냅니다.


## <a name="compiler-directives"></a>컴파일러 지시문
컴파일러 지시문은 # 기호가 접두사로 사용된다는 점에서 전처리기 지시문과 형태가 비슷하지만 전처리기에 의해 해석되지 않고 컴파일러를 통해 해석 및 처리되도록 남겨진다는 점에서 차이가 있습니다.

다음 표에는 F#에서 사용할 수 있는 컴파일러 지시문이 나와 있습니다.


|지시문|설명|
|---------|-----------|
|`#light` ["on"&#124;"off"]|다른 ML 버전과의 호환성을 위해 간단한 구문을 사용하거나 사용하지 않도록 설정합니다. 기본적으로 간단한 구문을 사용하도록 설정됩니다. 자세한 구문은 항상 사용할 수 있도록 설정됩니다. 따라서 간단한 구문과 자세한 구문을 함께 사용할 수 있습니다. `#light` 지시문 자체는 `#light "on"`과 같습니다. `#light "off"`를 지정하는 경우에는 모든 언어 구문에 대해 자세한 구문 형식을 사용해야 합니다. F# 관련 설명에 나오는 구문은 간단한 구문을 사용하는 것을 전제로 하여 제시됩니다. 자세한 내용은 참조 [자세한 구문](verbose-syntax.md)합니다.|
해석기 (fsi.exe) 지시문에 대 한 참조 [F #을 사용한 대화형 프로그래밍](../tutorials/fsharp-interactive/index.md)합니다.


## <a name="see-also"></a>참고 항목
[F# 언어 참조](index.md)

[컴파일러 옵션](compiler-options.md)


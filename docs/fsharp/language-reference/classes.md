---
title: 클래스(F#)
description: 'F # 클래스는 속성, 메서드 및 이벤트를 가질 수 있는 개체를 나타내는 형식 하는 방법에 대해 알아봅니다.'
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: dotnet-fsharp
ms.devlang: fsharp
ms.openlocfilehash: 0bfb45b6481576729bfe8d4bd016fb151757660a
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/28/2018
---
# <a name="classes"></a>클래스

*클래스* 속성, 메서드 및 이벤트를 가질 수 있는 개체를 나타내는입니다.


## <a name="syntax"></a>구문

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a>설명
클래스는.NET 개체 유형;에 대 한 기본적인 설명을 나타냅니다. 클래스는 F #에서 개체 지향 프로그래밍을 지 원하는 기본 형식 개념입니다.

위 구문에는 `type-name` 은 임의의 유효한 식별자입니다. `type-params` 선택적 제네릭 형식 매개 변수에 대해 설명 합니다. 형식 매개 변수 이름과 꺾쇠 괄호로 묶여 있는 제약 조건을 구성 됩니다 (`<` 및 `>`). 자세한 내용은 참조 [제네릭](generics/index.md) 및 [제약 조건을](generics/constraints.md)합니다. `parameter-list` 생성자 매개 변수에 대해 설명 합니다. 형식;에 관련 된 첫 번째 액세스 한정자 두 번째 주 생성자에 적용 됩니다. 기본값은 두 경우 모두 `public`합니다.

사용 하 여 클래스에 대 한 기본 클래스를 지정 하는 `inherit` 키워드입니다. 괄호로 기본 클래스 생성자에 대 한 인수를 제공 해야 합니다.

함수를 사용 하 여 로컬 클래스에 있는 값 또는 필드를 선언 하면 `let` 바인딩 및 사용자에 대 한 일반 규칙을 따라야 `let` 바인딩. `do-bindings` 섹션 개체 생성 시 실행 되는 코드가 포함 됩니다.

`member-list` 추가 생성자, 인스턴스 및 정적 메서드 선언, 인터페이스 선언, 추상 바인딩 및 속성 및 이벤트 선언으로 구성 합니다. 에 설명 되어 [멤버](members/index.md)합니다.

`identifier` 선택적 함께 사용 되는 `as` 키워드를 인스턴스 변수 또는 형식의 인스턴스를 참조 하도록 형식 정의에 사용할 수 있는 자체 식별자에는 이름을 제공 합니다. 자세한 내용은이 항목의 뒷부분에 나오는 자체 식별자 섹션을 참조 합니다.

키워드 `class` 및 `end` 시작을 표시 하 고 정의의 끝은 선택 사항입니다.

와 함께 서로 참조 하는 형식 재귀 형식을 조인 하는 상호는 `and` 상호 재귀 함수는 마찬가지로 키워드입니다. 예를 들어 상호 재귀 형식 섹션을 참조 합니다.


## <a name="constructors"></a>생성자
생성자는 클래스 형식의 인스턴스를 생성 하는 코드입니다. 클래스에 대 한 생성자 보다 다른.NET 언어에서 F #에서 약간 다르게 작동 합니다. F # 클래스, 즉 항상에 해당 인수를 설명 하는 기본 생성자는 `parameter-list` 뒤에 형식 이름 및 해당 본문으로 구성 됩니다는 `let` (및 `let rec`) 클래스 선언과 의시작부분에바인딩`do`뒤에 있습니다. 기본 생성자의 인수는 클래스 선언 전체 많습니다.

다른 생성자를 사용 하 여 추가할 수 있습니다는 `new` 키워드를 다음과 같이 멤버를 추가 합니다.

`new`(`argument-list`) = `constructor-body`

새로운 생성자의 본문 위쪽 클래스 선언에 지정 된 기본 생성자를 호출 해야 합니다.

다음 예제에서는이 개념을 보여 줍니다. 다음 코드에서 `MyClass` 두 명의 생성자가, 두 개의 인수 및 다른 생성자를 사용 하는 기본 생성자는 인수가 필요 없습니다.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]
    
## <a name="let-and-do-bindings"></a>let 및 do 바인딩

`let` 및 `do` 바인딩은 클래스 정의에서 기본 클래스 생성자의 본문을 구성 하 고 실행 하므로 클래스 인스턴스를 만들 때마다 합니다. 경우는 `let` 바인딩은 함수는 다음 멤버로 컴파일됩니다. 경우는 `let` 바인딩 함수 또는 멤버에 사용 되지 않는 값은 다음 생성자에 로컬인 변수가 컴파일됩니다. 그렇지 않으면 클래스의 필드에 컴파일됩니다. `do` 식 다음에 나오는 기본 생성자로 컴파일되고 모든 인스턴스에 대해 초기화 코드를 실행 합니다. 모든 추가 생성자는 항상 기본 생성자를 호출 하므로 `let` 바인딩 및 `do` 바인딩은 생성자가 호출 프로그램에 관계 없이 항상 실행 합니다.

하지만 필드에 의해 만들어진 `let` 액세스할 수에서 정적 메서드는 정적 메서드를 매개 변수로 인스턴스 변수를 사용 하는 경우에; 바인딩 메서드 및 클래스의 속성을 통해 액세스할 수 있습니다. 이러한 있는 경우 자체 식별자를 사용 하 여 액세스할 수 없습니다.


## <a name="self-identifiers"></a>자체 식별자

A *자체 식별자* 현재 인스턴스를 나타내는 이름입니다. 자체 식별자 유사는 `this` C# 또는 c + + 키워드 또는 `Me` Visual Basic의 합니다. 자체 식별자의 범위는 개별 방법에 대해서만 또는 전체 클래스 정의 대 한 자체 식별자 여부에 따라 두 가지 방법으로 정의할 수 있습니다.

전체 클래스에 대 한 자체 식별자를 정의 하려면 사용 하 여는 `as` 생성자 매개 변수의 닫는 괄호 뒤 키워드를 나열 하 고 식별자 이름을 지정 합니다.

자체 식별자에 대 한 단 하나의 메서드를 정의 하려면 멤버 선언 바로 앞에 메서드 이름 및 구분 기호로 마침표 (.)에서 자체 식별자를 제공 합니다.

다음 코드 예제에서는 자체 식별자를 만들려고 하는 두 가지 방법을 보여 줍니다. 첫 번째 줄에서은 `as` 키워드 자체 식별자를 정의 하는 데 사용 됩니다. 다섯 번째 줄에서는 식별자 `this` 인 범위를 메서드에 제한 자체 식별자를 정의 하는 데 사용 되 `PrintMessage`합니다.

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

와 달리 다른.NET 언어의 이름을 지정할 수 있습니다 자체 식별자 원하는; 있습니다으로 제한 되지 않은 이름 같은 `self`, `Me`, 또는 `this`합니다.

선언 된 경우 자체 식별자는 `as` 키워드 될 때까지 초기화 되지 않은 후의 `let` 바인딩이 실행 되 합니다. 따라서에서 사용할 수 없습니다는 `let` 바인딩. 자체 식별자를 사용할 수는 `do` 바인딩 섹션.


## <a name="generic-type-parameters"></a>제네릭 형식 매개 변수

꺾쇠 괄호에 제네릭 형식 매개 변수에 지정 된 (`<` 및 `>`), 작은따옴표와 식별자의 형식에서입니다. 여러 제네릭 형식 매개 변수는 쉼표로 구분 됩니다. 제네릭 형식 매개 변수는 선언 전체 범위에는. 다음 코드 예제에서는 제네릭 형식 매개 변수를 지정 하는 방법을 보여 줍니다.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

형식을 사용 하는 경우 형식 인수 유추 됩니다. 다음 코드에서는 유추 된 형식은 튜플 시퀀스.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]
    
## <a name="specifying-inheritance"></a>상속 지정

`inherit` 절이 있는 경우 직접 기본 클래스를 식별 합니다. F #에서 직접 기본 클래스를 하나만 허용 됩니다. 인터페이스는 클래스를 구현 하는 기본 클래스를 고려 하지 않습니다. 인터페이스에 대해서는 설명의 [인터페이스](Interfaces.md) 항목입니다.

액세스할 수 있습니다 메서드 및 속성 기본 클래스의 파생된 클래스에서 해당 언어 키워드를 사용 하 여 `base` 를 식별자로 뒤에 마침표 (.)와 멤버의 이름입니다.

자세한 내용은 [상속](inheritance.md)을 참조하세요.


## <a name="members-section"></a>구성원 섹션
이 섹션의 정적 또는 인스턴스 메서드, 속성, 인터페이스 구현, 추상 멤버, 이벤트 선언 및 추가 생성자를 정의할 수 있습니다. Let 및 않는 바인딩을이 섹션에 나타날 수 없습니다. 다양 한 클래스 뿐만 아니라 F # 형식에 멤버를 추가할 수 있습니다, 때문에 별도 항목에서 설명 [멤버](members/index.md)합니다.


## <a name="mutually-recursive-types"></a>상호 재귀 형식
서로 순환 방식으로 참조 하는 형식을 정의할 때는 있습니다 문자열 함께 형식 정의 사용 하 여는 `and` 키워드입니다. `and` 키워드를 대체는 `type` 다음과 같이 첫 번째 정의 제외한 모든 페이지에 키워드입니다.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

출력은 현재 디렉터리에 있는 모든 파일의 목록.


## <a name="when-to-use-classes-unions-records-and-structures"></a>클래스, 공용 구조체, 레코드 및 구조를 사용 하는 경우
어떤 유형별로 용인지 특정 상황에 대 한 적절 한 유형을 선택 하 게 파악 해야 해야 다양 한 형식에서 선택할 수를 지정 합니다. 클래스는 개체 지향 프로그래밍 컨텍스트에서 사용 하도록 디자인 되었습니다. 개체 지향 프로그래밍은.NET Framework에는 작성 된 응용 프로그램에서 사용 되는 주요 패러다임입니다. F # 코드는.NET Framework 또는 다른 개체 지향 라이브러리와 밀접 하 게 작업 해야 하는 경우와 같은 UI 라이브러리는 개체 지향 형식 시스템에서를 확장 해야 할 경우에 특히 클래스는 적절 한 것입니다.

개체 지향 코드와 밀접 하 게 작용할 되지 있습니다 또는 자체 포함 하 고 따라서 개체 지향 코드와 자주 상호 작용 으로부터 보호 되는 코드를 작성 하는 경우 레코드를 사용 하 여 고려해 야 하 고 구별 된 공용 구조체입니다. 단일도 하 게 고려 하 여 작성 한 코드와 일치 하는 적절 한 패턴 함께 구별 된 공용 구조체 개체 계층에 더 간단한 방법으로 사용할 수 있습니다. 구분 된 공용 구조체에 대 한 자세한 내용은 참조 [구별 된 공용 구조체](discriminated-unions.md)합니다.

레코드 클래스를 보다 간단 하다는 이점이 했지만 그 단순 함으로 수행할 수 있는 형식의 요구를 초과할 때 레코드 적합 하지 않습니다. 레코드는 기본적으로 단순 집계 값을 사용자 지정 작업을 수행할 수 있는 별도 생성자가 없는, 숨겨진된 필드를 상속 또는 인터페이스 구현 없이입니다. 속성 및 메서드와 같은 멤버 자체 동작을 더 복잡 한 레코드를 추가할 수 있지만 레코드에 저장 되는 필드는 여전히 값의 간단한 집계. 레코드에 대 한 자세한 내용은 참조 [레코드](records.md)합니다.

또한 구조 소규모 데이터를 집계 하는 데 유용 하지만.NET 값 형식에 있는 클래스와 레코드에서 서로 합니다. 클래스와 레코드.NET 참조 형식입니다. 값 형식을 값으로 전달 됩니다 한다는 점에서 값 형식과 참조 형식이의 의미 체계가 서로 다릅니다. 즉, 복사 되는 비트 수준 매개 변수로 전달 되거나 함수에서 반환 된 경우에 합니다. 또한 스택에 저장 인지, 대신 부모 개체 안에 포함 된 필드로 사용 되는 경우 힙의 고유한 별도 위치에 저장 합니다. 따라서 힙 액세스의 오버 헤드가 문제가 때 구조는 자주 액세스 하는 데이터에 적합 합니다. 구조에 대 한 자세한 내용은 참조 [구조](structures.md)합니다.


## <a name="see-also"></a>참고 항목
[F# 언어 참조](index.md)

[멤버](members/index.md)

[상속](inheritance.md)

[인터페이스](interfaces.md)


---
title: "쿼리 식 기본 사항"
description: "쿼리 식과 관련된 개념 소개"
keywords: .NET, .NET Core, C#
author: BillWagner
manager: wpickett
ms.author: wiwagn
ms.date: 11/30/2016
ms.topic: article
ms.prod: .net-core
ms.technology: .net-core-technologies
ms.devlang: dotnet
ms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: be8e2374f89366c6a98df900674a957bd2f531cc
ms.contentlocale: ko-kr
ms.lasthandoff: 07/28/2017

---
# <a name="query-expression-basics"></a><span data-ttu-id="8bc3e-104">쿼리 식 기본 사항</span><span class="sxs-lookup"><span data-stu-id="8bc3e-104">Query expression basics</span></span>

## <a name="what-is-a-query-and-what-does-it-do"></a><span data-ttu-id="8bc3e-105">쿼리란 무엇이며 쿼리의 기능은 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="8bc3e-105">What is a query and what does it do?</span></span> 

 <span data-ttu-id="8bc3e-106">*쿼리*는 지정된 데이터 소스(또는 소스)에서 검색할 데이터 및 반환된 데이터에 필요한 모양과 구성을 설명하는 지침 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-106">A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have.</span></span> <span data-ttu-id="8bc3e-107">쿼리와 쿼리에서 생성되는 결과는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-107">A query is distinct from the results that it produces.</span></span>  
  
 <span data-ttu-id="8bc3e-108">일반적으로 소스 데이터는 논리적으로 같은 종류의 요소 시퀀스로서 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-108">Generally, the source data is organized logically as a sequence of elements of the same kind.</span></span> <span data-ttu-id="8bc3e-109">예를 들어 SQL Database 테이블은 행 시퀀스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-109">For example, a SQL database table contains a sequence of rows.</span></span> <span data-ttu-id="8bc3e-110">XML 파일에는 XML 요소의 "시퀀스"가 있습니다(트리 구조에서는 계층적으로 구성되지만).</span><span class="sxs-lookup"><span data-stu-id="8bc3e-110">In an XML file, there is a "sequence" of XML elements (although these are organized hierarchically in a tree structure).</span></span> <span data-ttu-id="8bc3e-111">메모리 내 컬렉션은 개체의 시퀀스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-111">An in-memory collection contains a sequence of objects.</span></span> 
  
 <span data-ttu-id="8bc3e-112">응용 프로그램의 관점에서 소스 데이터의 특정 형식과 구조는 중요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-112">From an application's viewpoint, the specific type and structure of the original source data is not important.</span></span> <span data-ttu-id="8bc3e-113">응용 프로그램에는 소스 데이터가 항상 <xref:System.Collections.Generic.IEnumerable%601> 또는 <xref:System.Linq.IQueryable%601> 컬렉션으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-113">The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection.</span></span> <span data-ttu-id="8bc3e-114">예를 들어 LINQ to XML에서 소스 데이터는 `IEnumerable`\<<xref:System.Xml.Linq.XElement>>로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-114">For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span></span>  
  
 <span data-ttu-id="8bc3e-115">이 소스 시퀀스에서 쿼리는 다음 세 가지 중 하나를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-115">Given this source sequence, a query may do one of three things:</span></span>  
  
-   <span data-ttu-id="8bc3e-116">개별 요소를 수정하지 않고 요소의 하위 집합을 검색하여 새 시퀀스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-116">Retrieve a subset of the elements to produce a new sequence without modifying the individual elements.</span></span> <span data-ttu-id="8bc3e-117">그런 다음 쿼리는 다음 예제와 같이 여러 가지 방법으로 반환된 시퀀스를 정렬 또는 그룹화할 수 있습니다(`scores`를 `int[]`로 가정).</span><span class="sxs-lookup"><span data-stu-id="8bc3e-117">The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):</span></span>  
  
     <span data-ttu-id="8bc3e-118">[!code-cs[csrefQueryExpBasics#45](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-118">[!code-cs[csrefQueryExpBasics#45](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]</span></span>  
  
-   <span data-ttu-id="8bc3e-119">이전 예제와 같이 요소의 시퀀스를 검색하지만, 이를 새로운 개체 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-119">Retrieve a sequence of elements as in the previous example but transform them to a new type of object.</span></span> <span data-ttu-id="8bc3e-120">예를 들어 쿼리를 통해 데이터 소스에 있는 특정 고객 레코드에서 성만 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-120">For example, a query may retrieve only the last names from certain customer records in a data source.</span></span> <span data-ttu-id="8bc3e-121">또는 전체 레코드를 검색한 다음 이를 사용하여 최종 결과 시퀀스를 생성하기 전에 다른 메모리 내 개체 유형 또는 XML 데이터를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-121">Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence.</span></span> <span data-ttu-id="8bc3e-122">다음 예제는 `int`에서 `string`으로의 프로젝션을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-122">The following example shows a projection from an `int` to a `string`.</span></span> <span data-ttu-id="8bc3e-123">`highScoresQuery`의 새 형식을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-123">Note the new type of `highScoresQuery`.</span></span>  
  
     <span data-ttu-id="8bc3e-124">[!code-cs[csrefQueryExpBasics#46](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-124">[!code-cs[csrefQueryExpBasics#46](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]</span></span>  
  
-   <span data-ttu-id="8bc3e-125">소스 데이터에 대한 다음과 같은 singleton 값을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-125">Retrieve a singleton value about the source data, such as:</span></span>  
  
    -   <span data-ttu-id="8bc3e-126">특정 조건과 일치하는 요소의 수.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-126">The number of elements that match a certain condition.</span></span>  
  
    -   <span data-ttu-id="8bc3e-127">최대값 또는 최소값을 가지고 있는 요소.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-127">The element that has the greatest or least value.</span></span>  
  
    -   <span data-ttu-id="8bc3e-128">조건과 일치하는 첫 번째 요소 또는 지정된 요소 집합에서 특정 값의 합계.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-128">The first element that matches a condition, or the sum of particular values in a specified set of elements.</span></span> <span data-ttu-id="8bc3e-129">예를 들어 다음 쿼리는 `scores` 정수 배열에서 80보다 큰 점수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-129">For example, the following query returns the number of scores greater than 80 from the `scores` integer array:</span></span>  
  
     <span data-ttu-id="8bc3e-130">[!code-cs[csrefQueryExpBasics#47](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-130">[!code-cs[csrefQueryExpBasics#47](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]</span></span>  
  
     <span data-ttu-id="8bc3e-131">이전 예제에서는 `Count` 메서드를 호출하기 전에 쿼리 식 주변에 괄호를 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-131">In the previous example, note the use of parentheses around the query expression before the call to the `Count` method.</span></span> <span data-ttu-id="8bc3e-132">구체적인 결과를 저장하기 위한 새 변수를 사용하여 식을 표현할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-132">You can also express this by using a new variable to store the concrete result.</span></span> <span data-ttu-id="8bc3e-133">이 기술은 결과를 저장하는 쿼리와 별도로 쿼리를 저장하는 변수를 유지하기 때문에 더 읽기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-133">This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.</span></span>  
  
     <span data-ttu-id="8bc3e-134">[!code-cs[csrefQueryExpBasics#48](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-134">[!code-cs[csrefQueryExpBasics#48](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-135">이전 예에서는 `highScoresQuery`에 의해 반환된 요소 수를 확인하려면 `Count`가 결과를 반복해야 하기 때문에 `Count`에 대한 호출에서 쿼리가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-135">In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`.</span></span>  
  
## <a name="what-is-a-query-expression"></a><span data-ttu-id="8bc3e-136">쿼리 식이란 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="8bc3e-136">What is a query expression?</span></span>  

 <span data-ttu-id="8bc3e-137">*쿼리 식*은 쿼리 구문으로 표현되는 쿼리입니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-137">A *query expression* is a query expressed in query syntax.</span></span> <span data-ttu-id="8bc3e-138">쿼리 식은 고급 언어 구문으로서,</span><span class="sxs-lookup"><span data-stu-id="8bc3e-138">A query expression is a first-class language construct.</span></span> <span data-ttu-id="8bc3e-139">다른 식과 같으며 C# 식이 유효한 모든 컨텍스트에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-139">It is just like any other expression and can be used in any context in which a C# expression is valid.</span></span> <span data-ttu-id="8bc3e-140">쿼리 식은 SQL 또는 XQuery와 유사한 선언적 구문으로 작성된 절 집합으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-140">A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery.</span></span> <span data-ttu-id="8bc3e-141">각 절에는 하나 이상의 C# 식이 포함되며, 이러한 식은 자체가 쿼리 식이거나 쿼리 식을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-141">Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.</span></span>  
  
 <span data-ttu-id="8bc3e-142">쿼리 식은 [from](../language-reference/keywords/from-clause.md) 절로 시작하고 [select](../language-reference/keywords/select-clause.md) 또는 [group](../language-reference/keywords/group-clause.md) 절로 끝나야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-142">A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause.</span></span> <span data-ttu-id="8bc3e-143">첫 번째 `from` 절과 마지막 `select` 또는 `group` 절 사이에 선택적으로 [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) 절과 심지어 추가 [from](../language-reference/keywords/from-clause.md) 절 중에서 하나 이상을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-143">Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses.</span></span> <span data-ttu-id="8bc3e-144">또한 [into](../language-reference/keywords/into.md) 키워드를 사용하여, `join` 또는 `group` 절의 결과를 동일한 쿼리 식의 추가 쿼리 절에 대한 소스로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-144">You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression.</span></span>  
  
### <a name="query-variable"></a><span data-ttu-id="8bc3e-145">쿼리 변수</span><span class="sxs-lookup"><span data-stu-id="8bc3e-145">Query variable</span></span>  
 
 <span data-ttu-id="8bc3e-146">LINQ에서 쿼리 변수는 쿼리의 *결과* 대신 *쿼리*를 저장하는 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-146">In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query.</span></span> <span data-ttu-id="8bc3e-147">좀 더 구체적으로, 쿼리 변수는 항상 `foreach` 문이나 `IEnumerator.MoveNext` 메서드에 대한 직접 호출에서 반복될 때 요소 시퀀스를 생성하는 Enumerable 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-147">More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method.</span></span>  
  
 <span data-ttu-id="8bc3e-148">다음 코드 예제는 하나의 데이터 소스, 하나의 필터링 절, 하나의 순서 지정 절, 변환 없는 원본 요소로 간단한 쿼리 식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-148">The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements.</span></span> <span data-ttu-id="8bc3e-149">`select` 절은 쿼리를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-149">The `select` clause ends the query.</span></span>  
  
 <span data-ttu-id="8bc3e-150">[!code-cs[csrefQueryExpBasics#49](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-150">[!code-cs[csrefQueryExpBasics#49](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-151">이전 예제에서 `scoreQuery`는 *쿼리 변수*이며, 간단히 *쿼리*라고 하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-151">In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*.</span></span> <span data-ttu-id="8bc3e-152">쿼리 변수는 `foreach` 루프에서 생성되는 실제 결과 데이터를 저장하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-152">The query variable stores no actual result data, which is produced in the `foreach` loop.</span></span> <span data-ttu-id="8bc3e-153">그리고 `foreach` 문이 실행될 때, 쿼리 변수 `scoreQuery`를 통해 쿼리 결과가 반환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-153">And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`.</span></span> <span data-ttu-id="8bc3e-154">오히려 반복 변수 `testScore`를 통해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-154">Rather, they are returned through the iteration variable `testScore`.</span></span> <span data-ttu-id="8bc3e-155">`scoreQuery` 변수는 두 번째 `foreach` 루프에서 반복될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-155">The `scoreQuery` variable can be iterated in a second `foreach` loop.</span></span> <span data-ttu-id="8bc3e-156">변수 또는 데이터 소스를 수정하지 않는 한 동일한 결과가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-156">It will produce the same results as long as neither it nor the data source has been modified.</span></span>  
  
 <span data-ttu-id="8bc3e-157">쿼리 변수는 쿼리 구문이나 메서드 구문 또는 이 두 가지 조합으로 표현된 쿼리를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-157">A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two.</span></span> <span data-ttu-id="8bc3e-158">다음 예제에서는 `queryMajorCities` 및 `queryMajorCities2` 모두 쿼리 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-158">In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:</span></span>  
  
 <span data-ttu-id="8bc3e-159">[!code-cs[csrefQueryExpBasics#50](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-159">[!code-cs[csrefQueryExpBasics#50](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-160">반면에 다음 두 예제는 쿼리 변수가 아닌 변수가 각각을 통해 쿼리로 초기화된다는 것을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-160">On the other hand, the following two examples show variables that are not query variables even through each is initialized with a query.</span></span> <span data-ttu-id="8bc3e-161">이들은 결과를 저장하기 때문에 쿼리 변수가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-161">They are not query variables because they store results:</span></span>  
  
 <span data-ttu-id="8bc3e-162">[!code-cs[csrefQueryExpBasics#51](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-162">[!code-cs[csrefQueryExpBasics#51](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-163">쿼리를 표현하는 다양한 방법에 대한 자세한 내용은 [LINQ의 쿼리 구문 및 메서드 구문](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-163">For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span></span>  
  
#### <a name="explicit-and-implicit-typing-of-query-variables"></a><span data-ttu-id="8bc3e-164">쿼리 변수의 명시적 형식 및 암시적 형식</span><span class="sxs-lookup"><span data-stu-id="8bc3e-164">Explicit and implicit typing of query variables</span></span>  
 
 <span data-ttu-id="8bc3e-165">이 문서는 일반적으로 쿼리 변수와 [select 절](../language-reference/keywords/select-clause.md) 간의 형식 관계를 표시하기 위해 쿼리 변수의 명시적 형식을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-165">This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md).</span></span> <span data-ttu-id="8bc3e-166">그러나 [var](../language-reference/keywords/var.md) 키워드를 사용하여 컴파일 시간에 쿼리 변수(또는 다른 지역 변수)의 형식을 추론하도록 컴파일러에 지시할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-166">However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time.</span></span> <span data-ttu-id="8bc3e-167">예를 들어 이 항목의 앞에 나온 쿼리 예제를 암시적 형식을 사용하여 표현할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-167">For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:</span></span>  
  
 <span data-ttu-id="8bc3e-168">[!code-cs[csrefQueryExpBasics#52](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-168">[!code-cs[csrefQueryExpBasics#52](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-169">자세한 내용은 [암시적으로 형식화된 지역 변수](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) 및 [LINQ 쿼리 작업의 형식 관계](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-169">For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span></span>  
  
### <a name="starting-a-query-expression"></a><span data-ttu-id="8bc3e-170">쿼리 식 시작</span><span class="sxs-lookup"><span data-stu-id="8bc3e-170">Starting a query expression</span></span>  
 
 <span data-ttu-id="8bc3e-171">쿼리 식은 `from` 절로 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-171">A query expression must begin with a `from` clause.</span></span> <span data-ttu-id="8bc3e-172">쿼리 식은 범위 변수와 함께 데이터 소스를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-172">It specifies a data source together with a range variable.</span></span> <span data-ttu-id="8bc3e-173">범위 변수는 소스 시퀀스가 트래버스할 때 소스 시퀀스의 각 연속 요소를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-173">The range variable represents each successive element in the source sequence as the source sequence is being traversed.</span></span> <span data-ttu-id="8bc3e-174">범위 변수는 데이터 소스의 요소 형식을 기반으로 강력하게 형식이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-174">The range variable is strongly typed based on the type of elements in the data source.</span></span> <span data-ttu-id="8bc3e-175">다음 예제에서 `countries`는 `Country` 개체의 배열이므로 범위 변수의 형식도 `Country`로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-175">In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`.</span></span> <span data-ttu-id="8bc3e-176">범위 변수의 형식은 강력하게 지정되므로 사용 가능한 형식 멤버에 액세스하기 위해 점 연산자를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-176">Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.</span></span>  
  
 <span data-ttu-id="8bc3e-177">[!code-cs[csrefQueryExpBasics#53](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-177">[!code-cs[csrefQueryExpBasics#53](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-178">쿼리가 세미콜론 또는 *continuation* 절로 종료될 때까지 범위 변수는 범위 내에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-178">The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause.</span></span>  
  
 <span data-ttu-id="8bc3e-179">쿼리 식에는 여러 `from` 절이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-179">A query expression may contain multiple `from` clauses.</span></span> <span data-ttu-id="8bc3e-180">소스 시퀀스의 각 요소가 컬렉션이거나 컬렉션을 포함하는 경우 `from` 절을 추가로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-180">Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection.</span></span> <span data-ttu-id="8bc3e-181">예를 들어 `Country` 개체의 컬렉션이 있으며, 각각에 `Cities`라는 이름의 `City` 개체 컬렉션이 포함되어 있다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-181">For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`.</span></span> <span data-ttu-id="8bc3e-182">각 `Country`에서 `City` 개체를 쿼리하려면 다음과 같이 두 개의 `from` 절을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-182">To query the `City` objects in each `Country`, use two `from` clauses as shown here:</span></span>  
  
 <span data-ttu-id="8bc3e-183">[!code-cs[csrefQueryExpBasics#54](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-183">[!code-cs[csrefQueryExpBasics#54](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-184">자세한 내용은 [from 절](../language-reference/keywords/from-clause.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-184">For more information, see [from clause](../language-reference/keywords/from-clause.md).</span></span>  
  
### <a name="ending-a-query-expression"></a><span data-ttu-id="8bc3e-185">쿼리 식 종료</span><span class="sxs-lookup"><span data-stu-id="8bc3e-185">Ending a query expression</span></span>  
 
 <span data-ttu-id="8bc3e-186">쿼리 식은 `group` 절 또는 `select` 절로 끝나야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-186">A query expression must end with either a `group` clause or a `select` clause.</span></span>  
  
#### <a name="group-clause"></a><span data-ttu-id="8bc3e-187">group 절</span><span class="sxs-lookup"><span data-stu-id="8bc3e-187">group clause</span></span>  
 
 <span data-ttu-id="8bc3e-188">지정한 키로 구성되는 그룹의 시퀀스를 생성하려면 `group` 절을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-188">Use the `group` clause to produce a sequence of groups organized by a key that you specify.</span></span> <span data-ttu-id="8bc3e-189">키의 데이터 형식은 무엇이든 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-189">The key can be any data type.</span></span> <span data-ttu-id="8bc3e-190">예를 들어 다음 쿼리는 하나 이상의 `Country` 개체를 포함하며 키가 `char` 값인 그룹의 시퀀스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-190">For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value.</span></span>  
  
 <span data-ttu-id="8bc3e-191">[!code-cs[csrefQueryExpBasics#55](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-191">[!code-cs[csrefQueryExpBasics#55](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-192">그룹화에 대한 자세한 내용은 [group 절](../language-reference/keywords/group-clause.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-192">For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md).</span></span>  
  
#### <a name="select-clause"></a><span data-ttu-id="8bc3e-193">select 절</span><span class="sxs-lookup"><span data-stu-id="8bc3e-193">select clause</span></span>  
 <span data-ttu-id="8bc3e-194">다른 모든 시퀀스 형식을 생성하려면 `select` 절을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-194">Use the `select` clause to produce all other types of sequences.</span></span> <span data-ttu-id="8bc3e-195">간단한 `select` 절은 데이터 소스에 포함된 개체와 동일한 개체 형식의 시퀀스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-195">A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source.</span></span> <span data-ttu-id="8bc3e-196">이 예제에서는 데이터 소스에 `Country` 개체가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-196">In this example, the data source contains `Country` objects.</span></span> <span data-ttu-id="8bc3e-197">`orderby` 절은 단지 요소를 새로운 순서로 정렬하고, `select` 절은 다시 정렬된 `Country` 개체의 시퀀스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-197">The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects.</span></span>  
  
 <span data-ttu-id="8bc3e-198">[!code-cs[csrefQueryExpBasics#56](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-198">[!code-cs[csrefQueryExpBasics#56](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-199">소스 데이터를 새 형식의 시퀀스로 변환하려면 `select` 절을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-199">The `select` clause can be used to transform source data into sequences of new types.</span></span> <span data-ttu-id="8bc3e-200">이 변환을 *프로젝션*이라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-200">This transformation is also named a *projection*.</span></span> <span data-ttu-id="8bc3e-201">다음 예에서 `select` 절은 원래 요소에 필드의 하위 집합만 포함하는 일련의 무명 형식을 *프로젝션*합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-201">In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element.</span></span> <span data-ttu-id="8bc3e-202">새 개체는 개체 이니셜라이저를 사용하여 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-202">Note that the new objects are initialized by using an object initializer.</span></span>  
  
 <span data-ttu-id="8bc3e-203">[!code-cs[csrefQueryExpBasics#57](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-203">[!code-cs[csrefQueryExpBasics#57](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-204">소스 데이터를 변환하기 위해 `select` 절을 사용하는 모든 방법에 대한 자세한 내용은 [select 절](../language-reference/keywords/select-clause.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-204">For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md).</span></span>  
  
#### <a name="continuations-with-into"></a><span data-ttu-id="8bc3e-205">"into"를 사용한 연속</span><span class="sxs-lookup"><span data-stu-id="8bc3e-205">Continuations with "into"</span></span>  
 
 <span data-ttu-id="8bc3e-206">`select` 또는 `group` 절에서 `into` 키워드를 사용하여 쿼리를 저장하는 임시 식별자를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-206">You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query.</span></span> <span data-ttu-id="8bc3e-207">그룹화 또는 선택 작업 후에 쿼리에 대해 추가 쿼리 작업을 수행해야 하는 경우 이렇게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-207">Do this when you must perform additional query operations on a query after a grouping or select operation.</span></span> <span data-ttu-id="8bc3e-208">다음 예제에서 `countries`는 인구 1,000만 명 범위에 따라 그룹화됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-208">In the following example `countries` are grouped according to population in ranges of 10 million.</span></span> <span data-ttu-id="8bc3e-209">이러한 그룹을 만든 후에는 추가 절이 일부 그룹을 필터링한 다음 오름차순으로 그룹을 정렬합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-209">After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order.</span></span> <span data-ttu-id="8bc3e-210">추가 작업을 수행하려면 `countryGroup`으로 표현되는 연속이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-210">To perform those additional operations, the continuation represented by `countryGroup` is required.</span></span>  
  
 <span data-ttu-id="8bc3e-211">[!code-cs[csrefQueryExpBasics#58](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-211">[!code-cs[csrefQueryExpBasics#58](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-212">자세한 내용은 [into](../language-reference/keywords/into.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-212">For more information, see [into](../language-reference/keywords/into.md).</span></span>  
  
### <a name="filtering-ordering-and-joining"></a><span data-ttu-id="8bc3e-213">필터링, 정렬 및 조인</span><span class="sxs-lookup"><span data-stu-id="8bc3e-213">Filtering, ordering, and joining</span></span>

 <span data-ttu-id="8bc3e-214">시작 절 `from`과 종료 절 `select` 또는 `group` 사이의 다른 모든 절(`where`, `join`, `orderby`, `from`, `let`)은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-214">Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional.</span></span> <span data-ttu-id="8bc3e-215">선택 사항인 절은 쿼리 본문에서 0번 또는 여러 번 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-215">Any of the optional clauses may be used zero times or multiple times in a query body.</span></span>  
  
#### <a name="where-clause"></a><span data-ttu-id="8bc3e-216">where 절</span><span class="sxs-lookup"><span data-stu-id="8bc3e-216">where clause</span></span>  

 <span data-ttu-id="8bc3e-217">하나 이상의 조건자 식을 기반으로 소스 데이터에서 요소를 필터링하려면 `where` 절을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-217">Use the `where` clause to filter out elements from the source data based on one or more predicate expressions.</span></span> <span data-ttu-id="8bc3e-218">다음 예제의 `where` 절에는 조건자 하나와 조건 두 개가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-218">The `where` clause in the following example has one predicate with two conditions.</span></span>  
  
 <span data-ttu-id="8bc3e-219">[!code-cs[csrefQueryExpBasics#59](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-219">[!code-cs[csrefQueryExpBasics#59](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-220">자세한 내용은 [where 절](../language-reference/keywords/where-clause.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-220">For more information, see [where clause](../language-reference/keywords/where-clause.md).</span></span>  
  
#### <a name="orderby-clause"></a><span data-ttu-id="8bc3e-221">orderby 절</span><span class="sxs-lookup"><span data-stu-id="8bc3e-221">orderby clause</span></span>

 <span data-ttu-id="8bc3e-222">결과를 오름차순 또는 내림차순으로 정렬하려면 `orderby` 절을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-222">Use the `orderby` clause to sort the results in either ascending or descending order.</span></span> <span data-ttu-id="8bc3e-223">2차 정렬 순서를 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-223">You can also specify secondary sort orders.</span></span> <span data-ttu-id="8bc3e-224">다음 예제에서는 `Area` 속성을 사용하여 `country` 개체에 대해 1차 정렬을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-224">The following example performs a primary sort on the `country` objects by using the `Area` property.</span></span> <span data-ttu-id="8bc3e-225">그런 다음 `Population` 속성을 사용하여 2차 정렬을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-225">It then performs a secondary sort by using the `Population` property.</span></span>  
  
 <span data-ttu-id="8bc3e-226">[!code-cs[csrefQueryExpBasics#60](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-226">[!code-cs[csrefQueryExpBasics#60](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-227">`ascending` 키워드는 선택 사항이며, 순서가 지정되지 않은 경우 기본 정렬 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-227">The `ascending` keyword is optional; it is the default sort order if no order is specified.</span></span> <span data-ttu-id="8bc3e-228">자세한 내용은 [orderby 절](../language-reference/keywords/orderby-clause.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-228">For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md).</span></span>  
  
#### <a name="join-clause"></a><span data-ttu-id="8bc3e-229">join 절</span><span class="sxs-lookup"><span data-stu-id="8bc3e-229">join clause</span></span>

 <span data-ttu-id="8bc3e-230">각 요소의 지정된 키 간 동일성 비교에 따라 하나의 데이터 소스의 요소를 다른 데이터 소스의 요소와 연결하거나 결합하려면 `join` 절을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-230">Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element.</span></span> <span data-ttu-id="8bc3e-231">LINQ에서는 요소의 형식이 서로 다른 개체의 시퀀스에 대해 조인 작업이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-231">In LINQ, join operations are performed on sequences of objects whose elements are different types.</span></span> <span data-ttu-id="8bc3e-232">두 개의 시퀀스를 조인한 후 `select` 또는 `group` 문을 사용하여 출력 시퀀스에 저장할 요소를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-232">After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence.</span></span> <span data-ttu-id="8bc3e-233">연결된 각 요소 집합의 속성을 출력 시퀀스의 새 형식으로 결합하는 데에도 무명 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-233">You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence.</span></span> <span data-ttu-id="8bc3e-234">다음 예제는 `Category` 속성이 `categories` 문자열 배열의 범주 중 하나와 일치하는 `prod` 개체를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-234">The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array.</span></span> <span data-ttu-id="8bc3e-235">`Category`가 `categories`의 문자열과 일치하지 않는 제품은 필터링됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-235">Products whose `Category` does not match any string in `categories` are filtered out.</span></span> <span data-ttu-id="8bc3e-236">`select` 문은 속성을 `cat` 및 `prod`에서 가져오는 새 형식을 프로젝션합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-236">The `select` statement projects a new type whose properties are taken from both `cat` and `prod`.</span></span>  
  
 <span data-ttu-id="8bc3e-237">[!code-cs[csrefQueryExpBasics#61](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-237">[!code-cs[csrefQueryExpBasics#61](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-238">[into](../language-reference/keywords/into.md) 키워드를 사용하여 `join` 작업의 결과를 임시 변수에 저장함으로써 그룹 조인을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-238">You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword.</span></span> <span data-ttu-id="8bc3e-239">자세한 내용은 [join 절](../language-reference/keywords/join-clause.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-239">For more information, see [join clause](../language-reference/keywords/join-clause.md).</span></span>  
  
#### <a name="let-clause"></a><span data-ttu-id="8bc3e-240">let 절</span><span class="sxs-lookup"><span data-stu-id="8bc3e-240">let clause</span></span> 

 <span data-ttu-id="8bc3e-241">식의 결과(예: 메서드 호출)를 새 범위 변수에 저장하려면 `let` 절을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-241">Use the `let` clause to store the result of an expression, such as a method call, in a new range variable.</span></span> <span data-ttu-id="8bc3e-242">다음 예제에서 범위 변수 `firstName`은 `Split`에서 반환하는 문자열 배열의 첫 번째 요소를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-242">In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`.</span></span>  
  
 <span data-ttu-id="8bc3e-243">[!code-cs[csrefQueryExpBasics#62](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-243">[!code-cs[csrefQueryExpBasics#62](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-244">자세한 내용은 [let 절](../language-reference/keywords/let-clause.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-244">For more information, see [let clause](../language-reference/keywords/let-clause.md).</span></span>  
  
### <a name="subqueries-in-a-query-expression"></a><span data-ttu-id="8bc3e-245">쿼리 식의 하위 쿼리</span><span class="sxs-lookup"><span data-stu-id="8bc3e-245">Subqueries in a query expression</span></span>  

 <span data-ttu-id="8bc3e-246">쿼리 절 자체에 쿼리 식을 포함할 수 있는데, 이를 *하위 쿼리*라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-246">A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*.</span></span> <span data-ttu-id="8bc3e-247">각 하위 쿼리는 자체 `from` 절로 시작되는데, 이것이 반드시 첫 번째 `from` 절에 있는 동일한 데이터 소스를 가리킬 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-247">Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause.</span></span> <span data-ttu-id="8bc3e-248">예를 들어 다음 쿼리는 그룹화 작업의 결과를 검색하기 위해 select 문에서 사용되는 쿼리 식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-248">For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.</span></span>  
  
 <span data-ttu-id="8bc3e-249">[!code-cs[csrefQueryExpBasics#63](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]</span><span class="sxs-lookup"><span data-stu-id="8bc3e-249">[!code-cs[csrefQueryExpBasics#63](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]</span></span>  
  
 <span data-ttu-id="8bc3e-250">자세한 내용은 [방법: 그룹화 작업에서 하위 쿼리 수행](perform-a-subquery-on-a-grouping-operation.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8bc3e-250">For more information, see [How to: perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8bc3e-251">참고 항목</span><span class="sxs-lookup"><span data-stu-id="8bc3e-251">See Also</span></span>  
 <span data-ttu-id="8bc3e-252">[C# 프로그래밍 가이드](../programming-guide/index.md) </span><span class="sxs-lookup"><span data-stu-id="8bc3e-252">[C# programming guide](../programming-guide/index.md) </span></span>  
 <span data-ttu-id="8bc3e-253">[LINQ 쿼리 식](index.md) </span><span class="sxs-lookup"><span data-stu-id="8bc3e-253">[LINQ query expressions](index.md) </span></span>  
 <span data-ttu-id="8bc3e-254">[쿼리 키워드(LINQ)](../language-reference/keywords/query-keywords.md) </span><span class="sxs-lookup"><span data-stu-id="8bc3e-254">[Query keywords (LINQ)](../language-reference/keywords/query-keywords.md) </span></span>  
 [<span data-ttu-id="8bc3e-255">표준 쿼리 연산자 개요</span><span class="sxs-lookup"><span data-stu-id="8bc3e-255">Standard query operators overview</span></span>](../programming-guide/concepts/linq/standard-query-operators-overview.md)


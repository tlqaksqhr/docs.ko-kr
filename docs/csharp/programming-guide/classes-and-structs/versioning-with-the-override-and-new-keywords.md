---
title: "Override 및 New 키워드를 사용하여 버전 관리(C# 프로그래밍 가이드)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- C# language, versioning
- C# language, override and new
ms.assetid: 88247d07-bd0d-49e9-a619-45ccbbfdf0c5
caps.latest.revision: "25"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: be51a5b3d3eecc58d43dcbbcb0802cce7fd16c45
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="versioning-with-the-override-and-new-keywords-c-programming-guide"></a><span data-ttu-id="6d61e-102">Override 및 New 키워드를 사용하여 버전 관리(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="6d61e-102">Versioning with the Override and New Keywords (C# Programming Guide)</span></span>
<span data-ttu-id="6d61e-103">C# 언어는 서로 다른 라이브러리의 [기본](../../../csharp/language-reference/keywords/base.md) 및 파생 클래스 간 버전 관리를 개발하고 이전 버전과의 호환성을 유지할 수 있도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-103">The C# language is designed so that versioning between [base](../../../csharp/language-reference/keywords/base.md) and derived classes in different libraries can evolve and maintain backward compatibility.</span></span> <span data-ttu-id="6d61e-104">예를 들어 파생 클래스의 멤버와 동일한 이름을 가진 기본 [클래스](../../../csharp/language-reference/keywords/class.md)에 새 멤버가 추가되면 C#이 완전히 지원되고 예기치 않은 동작이 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-104">This means, for example, that the introduction of a new member in a base [class](../../../csharp/language-reference/keywords/class.md) with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior.</span></span> <span data-ttu-id="6d61e-105">따라서 클래스는 메서드가 상속된 메서드를 재정의할지 아니면 메서드가 유사한 이름의 상속된 메서드를 숨기는 새 메서드인지를 명시적으로 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-105">It also means that a class must explicitly state whether a method is intended to override an inherited method, or whether a method is a new method that hides a similarly named inherited method.</span></span>  
  
 <span data-ttu-id="6d61e-106">C#에서 파생 클래스는 기본 클래스 메서드와 동일한 이름 가진 메서드를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-106">In C#, derived classes can contain methods with the same name as base class methods.</span></span>  
  
-   <span data-ttu-id="6d61e-107">기본 클래스 메서드를 [virtual](../../../csharp/language-reference/keywords/virtual.md)로 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-107">The base class method must be defined [virtual](../../../csharp/language-reference/keywords/virtual.md).</span></span>  
  
-   <span data-ttu-id="6d61e-108">파생 클래스의 메서드 앞에 [new](../../../csharp/language-reference/keywords/new.md) 또는 [override](../../../csharp/language-reference/keywords/override.md) 키워드가 있으면 컴파일러는 경고를 표시하고 메서드는 `new` 키워드가 있는 것처럼 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-108">If the method in the derived class is not preceded by [new](../../../csharp/language-reference/keywords/new.md) or [override](../../../csharp/language-reference/keywords/override.md) keywords, the compiler will issue a warning and the method will behave as if the `new` keyword were present.</span></span>  
  
-   <span data-ttu-id="6d61e-109">파생 클래스의 메서드 앞에 `new` 키워드가 있는 경우 이 메서드는 기본 클래스의 메서드와 독립적으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-109">If the method in the derived class is preceded with the `new` keyword, the method is defined as being independent of the method in the base class.</span></span>  
  
-   <span data-ttu-id="6d61e-110">파생 클래스의 메서드 앞에 `override` 키워드가 있는 경우 파생 클래스의 개체는 기본 클래스 메서드 대신 해당 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-110">If the method in the derived class is preceded with the `override` keyword, objects of the derived class will call that method instead of the base class method.</span></span>  
  
-   <span data-ttu-id="6d61e-111">기본 클래스 메서드는 `base` 키워드를 사용하여 파생 클래스 내에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-111">The base class method can be called from within the derived class using the `base` keyword.</span></span>  
  
-   <span data-ttu-id="6d61e-112">`override`, `virtual`, 및 `new` 키워드는 속성, 인덱서 및 이벤트에도 적용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-112">The `override`, `virtual`, and `new` keywords can also be applied to properties, indexers, and events.</span></span>  
  
 <span data-ttu-id="6d61e-113">기본적으로 C# 메서드는 가상입니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-113">By default, C# methods are not virtual.</span></span> <span data-ttu-id="6d61e-114">메서드가 가상으로 선언되면 이 메서드를 상속하는 클래스는 자체 버전을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-114">If a method is declared as virtual, any class inheriting the method can implement its own version.</span></span> <span data-ttu-id="6d61e-115">메서드를 가상으로 만들려면 기본 클래스의 메서드 선언에서 `virtual` 한정자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-115">To make a method virtual, the `virtual` modifier is used in the method declaration of the base class.</span></span> <span data-ttu-id="6d61e-116">파생 클래스는 `override` 키워드를 사용하여 기본 가상 메서드를 재정의하거나 `new` 키워드를 사용하여 기본 클래스에서 가상 메서드를 숨길 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-116">The derived class can then override the base virtual method by using the `override` keyword or hide the virtual method in the base class by using the `new` keyword.</span></span> <span data-ttu-id="6d61e-117">`override` 키워드와 `new` 키워드가 모두 지정되지 않은 경우 컴파일러는 경고를 표시하고 파생 클래스의 메서드는 기본 클래스의 메서드를 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-117">If neither the `override` keyword nor the `new` keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class.</span></span>  
  
 <span data-ttu-id="6d61e-118">이를 실증적으로 보여 주기 위해, A 회사가 프로그램에서 사용하는 `GraphicsClass`라는 클래스를 만들었다고 잠시 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-118">To demonstrate this in practice, assume for a moment that Company A has created a class named `GraphicsClass`, which your program uses.</span></span> <span data-ttu-id="6d61e-119">다음은 `GraphicsClass`입니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-119">The following is `GraphicsClass`:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#27](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_1.cs)]  
  
 <span data-ttu-id="6d61e-120">회사에서 이 클래스를 사용하며, 사용자는 이를 사용하여 고유한 클래스를 파생시키고 새 메서드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-120">Your company uses this class, and you use it to derive your own class, adding a new method:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#28](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_2.cs)]  
  
 <span data-ttu-id="6d61e-121">회사 A에서 `GraphicsClass`의 새 버전을 출시할 때까지 응용 프로그램은 문제없이 사용됩니다. 새 버전은 다음 코드와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-121">Your application is used without problems, until Company A releases a new version of `GraphicsClass`, which resembles the following code:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#29](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_3.cs)]  
  
 <span data-ttu-id="6d61e-122">`GraphicsClass`의 새 버전에는 이제 `DrawRectangle`이라는 메서드가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-122">The new version of `GraphicsClass` now contains a method named `DrawRectangle`.</span></span> <span data-ttu-id="6d61e-123">처음에는 아무것도 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-123">Initially, nothing occurs.</span></span> <span data-ttu-id="6d61e-124">새 버전은 여전히 이전 버전과 호환되는 이진입니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-124">The new version is still binary compatible with the old version.</span></span> <span data-ttu-id="6d61e-125">새 클래스가 해당 컴퓨터 시스템에 설치되어 있어도 사용자가 배포한 소프트웨어는 계속 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-125">Any software that you have deployed will continue to work, even if the new class is installed on those computer systems.</span></span> <span data-ttu-id="6d61e-126">`DrawRectangle` 메서드에 대한 호출은 파생 클래스에서 계속 해당 버전을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-126">Any existing calls to the method `DrawRectangle` will continue to reference your version, in your derived class.</span></span>  
  
 <span data-ttu-id="6d61e-127">그러나 `GraphicsClass`의 새 버전을 사용하여 응용 프로그램을 다시 컴파일하자마자 컴파일러에서 경고(CS0108)를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-127">However, as soon as you recompile your application by using the new version of `GraphicsClass`, you will receive a warning from the compiler, CS0108.</span></span> <span data-ttu-id="6d61e-128">이 경고는 `DrawRectangle` 메서드가 응용 프로그램에서 어떻게 작동할지를 고려해야 한다고 알립니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-128">This warning informs you that you have to consider how you want your `DrawRectangle` method to behave in your application.</span></span>  
  
 <span data-ttu-id="6d61e-129">메서드가 새로운 기본 클래스 메서드를 재정의하도록 하려면 `override` 키워드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-129">If you want your method to override the new base class method, use the `override` keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#30](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_4.cs)]  
  
 <span data-ttu-id="6d61e-130">`override` 키워드는 `YourDerivedGraphicsClass`에서 파생된 개체가 `DrawRectangle`의 파생 클래스 버전을 사용하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-130">The `override` keyword makes sure that any objects derived from `YourDerivedGraphicsClass` will use the derived class version of `DrawRectangle`.</span></span> <span data-ttu-id="6d61e-131">`YourDerivedGraphicsClass`에서 파생된 개체는 기본 키워드를 사용하여 여전히 `DrawRectangle`의 기본 클래스 버전에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-131">Objects derived from `YourDerivedGraphicsClass` can still access the base class version of `DrawRectangle` by using the base keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#44](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_5.cs)]  
  
 <span data-ttu-id="6d61e-132">메서드가 새 기본 클래스 메서드를 재정의하도록 하지 않으려면 다음 고려 사항을 적용하세요.</span><span class="sxs-lookup"><span data-stu-id="6d61e-132">If you do not want your method to override the new base class method, the following considerations apply.</span></span> <span data-ttu-id="6d61e-133">두 메서드 간 혼동을 피하려면 메서드의 이름을 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-133">To avoid confusion between the two methods, you can rename your method.</span></span> <span data-ttu-id="6d61e-134">이 방법은 시간이 오래 걸리고 오류가 발생하기 쉬우며 어떤 경우에는 실용적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-134">This can be time-consuming and error-prone, and just not practical in some cases.</span></span> <span data-ttu-id="6d61e-135">그러나 프로젝트 규모가 비교적 작으면 Visual Studio 리팩터링 옵션을 사용하여 메서드의 이름을 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-135">However, if your project is relatively small, you can use Visual Studio's Refactoring options to rename the method.</span></span> <span data-ttu-id="6d61e-136">자세한 내용은 [클래스 및 형식 리팩터링(클래스 디자이너)](/visualstudio/ide/refactoring-classes-and-types-class-designer)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6d61e-136">For more information, see [Refactoring Classes and Types (Class Designer)](/visualstudio/ide/refactoring-classes-and-types-class-designer).</span></span>  
  
 <span data-ttu-id="6d61e-137">또는 파생 클래스 정의에서 `new` 키워드를 사용하여 경고를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-137">Alternatively, you can prevent the warning by using the keyword `new` in your derived class definition:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#31](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_6.cs)]  
  
 <span data-ttu-id="6d61e-138">`new` 키워드는 사용자 정의가 기본 클래스에 포함된 정의를 숨긴다는 것을 컴파일러에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-138">Using the `new` keyword tells the compiler that your definition hides the definition that is contained in the base class.</span></span> <span data-ttu-id="6d61e-139">이것은 기본적인 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-139">This is the default behavior.</span></span>  
  
## <a name="override-and-method-selection"></a><span data-ttu-id="6d61e-140">재정의 및 메서드 선택</span><span class="sxs-lookup"><span data-stu-id="6d61e-140">Override and Method Selection</span></span>  
 <span data-ttu-id="6d61e-141">클래스에서 메서드 이름을 지정할 때, 동일한 이름을 가진 두 개의 메서드가 있고 전달된 매개 변수와 호환되는 매개 변수가 있는 경우와 같이 둘 이상의 메서드가 호출과 호환되는 경우, C# 컴파일러는 호출할 수 있는 최상의 메서드를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-141">When a method is named on a class, the C# compiler selects the best method to call if more than one method is compatible with the call, such as when there are two methods with the same name, and parameters that are compatible with the parameter passed.</span></span> <span data-ttu-id="6d61e-142">다음 메서드는 호환 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-142">The following methods would be compatible:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#32](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_7.cs)]  
  
 <span data-ttu-id="6d61e-143">`Derived`의 인스턴스에서 `DoWork`가 호출되면 C# 컴파일러는 호출이 원래 `Derived`에 선언된 `DoWork` 버전과 호환되도록 만들려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-143">When `DoWork` is called on an instance of `Derived`, the C# compiler will first try to make the call compatible with the versions of `DoWork` declared originally on `Derived`.</span></span> <span data-ttu-id="6d61e-144">재정의 메서드는 클래스에서 선언된 것으로 간주되지 않습니다. 재정의 메서드는 기본 클래스에서 선언된 메서드의 새로운 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-144">Override methods are not considered as declared on a class, they are new implementations of a method declared on a base class.</span></span> <span data-ttu-id="6d61e-145">C# 컴파일러는 메서드 호출을 `Derived`의 원래 메서드와 일치시킬 수 없는 경우에만, 재정의된 메서드에 대한 호출을 동일한 이름 및 호환되는 매개 변수와 일치시키려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-145">Only if the C# compiler cannot match the method call to an original method on `Derived` will it try to match the call to an overridden method with the same name and compatible parameters.</span></span> <span data-ttu-id="6d61e-146">예:</span><span class="sxs-lookup"><span data-stu-id="6d61e-146">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#33](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_8.cs)]  
  
 <span data-ttu-id="6d61e-147">`val` 변수를 double로 암시적으로 변환할 수 있으므로 C# 컴파일러는 `DoWork(int)` 대신 `DoWork(double)`을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-147">Because the variable `val` can be converted to a double implicitly, the C# compiler calls `DoWork(double)` instead of `DoWork(int)`.</span></span> <span data-ttu-id="6d61e-148">이것을 방지할 수 있는 두 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-148">There are two ways to avoid this.</span></span> <span data-ttu-id="6d61e-149">첫째, 가상 메서드와 동일한 이름을 가진 새 메서드를 선언하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-149">First, avoid declaring new methods with the same name as virtual methods.</span></span> <span data-ttu-id="6d61e-150">둘째, `Derived`의 인스턴스를 `Base`에 캐스팅하여 기본 클래스 메서드 목록을 검색하게 함으로써 가상 메서드를 호출하도록 C# 컴파일러에 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-150">Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of `Derived` to `Base`.</span></span> <span data-ttu-id="6d61e-151">메서드는 가상이므로 `Derived`에서 `DoWork(int)`의 구현이 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d61e-151">Because the method is virtual, the implementation of `DoWork(int)` on `Derived` will be called.</span></span> <span data-ttu-id="6d61e-152">예:</span><span class="sxs-lookup"><span data-stu-id="6d61e-152">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#34](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_9.cs)]  
  
 <span data-ttu-id="6d61e-153">`new` 및 `override`의 추가 예제는 [Override 및 New 키워드를 사용해야 하는 경우](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6d61e-153">For more examples of `new` and `override`, see [Knowing When to Use Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6d61e-154">참고 항목</span><span class="sxs-lookup"><span data-stu-id="6d61e-154">See Also</span></span>  
 [<span data-ttu-id="6d61e-155">C# 프로그래밍 가이드</span><span class="sxs-lookup"><span data-stu-id="6d61e-155">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="6d61e-156">클래스 및 구조체</span><span class="sxs-lookup"><span data-stu-id="6d61e-156">Classes and Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/index.md)  
 [<span data-ttu-id="6d61e-157">메서드</span><span class="sxs-lookup"><span data-stu-id="6d61e-157">Methods</span></span>](../../../csharp/programming-guide/classes-and-structs/methods.md)  
 [<span data-ttu-id="6d61e-158">상속</span><span class="sxs-lookup"><span data-stu-id="6d61e-158">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)

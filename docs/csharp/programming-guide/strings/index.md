---
title: "문자열(C# 프로그래밍 가이드)"
ms.date: 2015-07-20
ms.prod: .net
ms.technology:
- devlang-csharp
ms.topic: article
dev_langs:
- CSharp
helpviewer_keywords:
- C# language, strings
- strings [C#]
ms.assetid: 21580405-cb25-4541-89d5-037846a38b07
caps.latest.revision: 41
author: BillWagner
ms.author: wiwagn
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: e41a7b68d890aa7a96aeddd660e0dca90596d998
ms.contentlocale: ko-kr
ms.lasthandoff: 07/28/2017

---
# <a name="strings-c-programming-guide"></a><span data-ttu-id="efb0c-102">문자열(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="efb0c-102">Strings (C# Programming Guide)</span></span>
<span data-ttu-id="efb0c-103">문자열은 값이 텍스트인 <xref:System.String> 형식의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-103">A string is an object of type <xref:System.String> whose value is text.</span></span> <span data-ttu-id="efb0c-104">내부적으로 텍스트는 <xref:System.Char> 개체의 순차적 읽기 전용 컬렉션으로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-104">Internally, the text is stored as a sequential read-only collection of <xref:System.Char> objects.</span></span> <span data-ttu-id="efb0c-105">C# 문자열의 끝에 null 종료 문자가 없으므로 C# 문자열에는 포함된 null 문자('\0')를 여러 개 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-105">There is no null-terminating character at the end of a C# string; therefore a C# string can contain any number of embedded null characters ('\0').</span></span> <span data-ttu-id="efb0c-106">문자열의 <xref:System.String.Length%2A> 속성은 유니코드 문자 수가 아닌 포함된 `Char` 개체 수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-106">The <xref:System.String.Length%2A> property of a string represents the number of `Char` objects it contains, not the number of Unicode characters.</span></span> <span data-ttu-id="efb0c-107">문자열에서 개별 유니코드 코드 포인트에 액세스하려면 <xref:System.Globalization.StringInfo> 개체를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-107">To access the individual Unicode code points in a string, use the <xref:System.Globalization.StringInfo> object.</span></span>  
  
## <a name="string-vs-systemstring"></a><span data-ttu-id="efb0c-108">문자열과 System.String</span><span class="sxs-lookup"><span data-stu-id="efb0c-108">string vs. System.String</span></span>  
 <span data-ttu-id="efb0c-109">C#에서 `string` 키워드는 <xref:System.String>의 별칭입니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-109">In C#, the `string` keyword is an alias for <xref:System.String>.</span></span> <span data-ttu-id="efb0c-110">따라서 `String` 및 `string`은 동일하며 원하는 명명 규칙을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-110">Therefore, `String` and `string` are equivalent, and you can use whichever naming convention you prefer.</span></span> <span data-ttu-id="efb0c-111">`String` 클래스는 문자열을 안전하게 작성, 조작 및 비교할 수 있도록 다양한 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-111">The `String` class provides many methods for safely creating, manipulating, and comparing strings.</span></span> <span data-ttu-id="efb0c-112">또한 C# 언어는 일반적인 문자열 작업을 간소화 하기 위해 일부 연산자를 오버로드합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-112">In addition, the C# language overloads some operators to simplify common string operations.</span></span> <span data-ttu-id="efb0c-113">키워드에 대한 자세한 내용은 [string](../../../csharp/language-reference/keywords/string.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="efb0c-113">For more information about the keyword, see [string](../../../csharp/language-reference/keywords/string.md).</span></span> <span data-ttu-id="efb0c-114">형식 및 메서드에 대한 자세한 내용은 <xref:System.String>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="efb0c-114">For more information about the type and its methods, see <xref:System.String>.</span></span>  
  
## <a name="declaring-and-initializing-strings"></a><span data-ttu-id="efb0c-115">문자열 선언 및 초기화</span><span class="sxs-lookup"><span data-stu-id="efb0c-115">Declaring and Initializing Strings</span></span>  
 <span data-ttu-id="efb0c-116">다음 예제에서와 같이 다양한 방법으로 문자열을 선언하고 초기화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-116">You can declare and initialize strings in various ways, as shown in the following example:</span></span>  
  
 <span data-ttu-id="efb0c-117">[!code-cs[csProgGuideStrings #1](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_1.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-117">[!code-cs[csProgGuideStrings#1](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_1.cs)]</span></span>  
  
 <span data-ttu-id="efb0c-118">문자 배열이 포함된 문자열을 초기화할 경우를 제외하고는 문자열 개체를 만들기 위해 [new](../../../csharp/language-reference/keywords/new-operator.md) 연산자를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-118">Note that you do not use the [new](../../../csharp/language-reference/keywords/new-operator.md) operator to create a string object except when initializing the string with an array of chars.</span></span>  
  
 <span data-ttu-id="efb0c-119">문자열 길이가 0인 새 <xref:System.String> 개체를 만들려면 <xref:System.String.Empty> 상수 값이 포함된 문자열을 초기화하세요.</span><span class="sxs-lookup"><span data-stu-id="efb0c-119">Initialize a string with the <xref:System.String.Empty> constant value to create a new <xref:System.String> object whose string is of zero length.</span></span> <span data-ttu-id="efb0c-120">빈 문자열을 문자열 리터럴로 나타내면 ""로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-120">The string literal representation of a zero-length string is "".</span></span> <span data-ttu-id="efb0c-121">[null](../../../csharp/language-reference/keywords/null.md) 대신 <xref:System.String.Empty> 값이 포함된 문자열을 초기화하면 <xref:System.NullReferenceException> 발생을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-121">By initializing strings with the <xref:System.String.Empty> value instead of [null](../../../csharp/language-reference/keywords/null.md), you can reduce the chances of a <xref:System.NullReferenceException> occurring.</span></span> <span data-ttu-id="efb0c-122">액세스하기 전에 문자열의 값을 확인하려면 정적 <xref:System.String.IsNullOrEmpty%28System.String%29> 메서드를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="efb0c-122">Use the static <xref:System.String.IsNullOrEmpty%28System.String%29> method to verify the value of a string before you try to access it.</span></span>  
  
## <a name="immutability-of-string-objects"></a><span data-ttu-id="efb0c-123">문자열 개체의 불변성</span><span class="sxs-lookup"><span data-stu-id="efb0c-123">Immutability of String Objects</span></span>  
 <span data-ttu-id="efb0c-124">문자열 개체는 *변경할 수 없습니다*. 즉, 생성된 후에는 바꿀 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-124">String objects are *immutable*: they cannot be changed after they have been created.</span></span> <span data-ttu-id="efb0c-125">실제로 문자열을 수정하는 것으로 나타나는 모든 <xref:System.String> 메서드 및 C# 연산자는 새로운 문자열 개체에 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-125">All of the <xref:System.String> methods and C# operators that appear to modify a string actually return the results in a new string object.</span></span> <span data-ttu-id="efb0c-126">다음 예제에서 `s1` 및 `s2`의 콘텐츠는 단일 문자열을 형성하도록 연결되며, 두 개의 원본 문자열은 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-126">In the following example, when the contents of `s1` and `s2` are concatenated to form a single string, the two original strings are unmodified.</span></span> <span data-ttu-id="efb0c-127">`+=` 연산자는 결합된 콘텐츠를 포함하는 새 문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-127">The `+=` operator creates a new string that contains the combined contents.</span></span> <span data-ttu-id="efb0c-128">새 개체는 `s1` 변수에 할당되며, 참조를 유지하는 변수가 없으므로 `s1`에 할당된 원래 개체는 가비지 수집을 위해 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-128">That new object is assigned to the variable `s1`, and the original object that was assigned to `s1` is released for garbage collection because no other variable holds a reference to it.</span></span>  
  
 <span data-ttu-id="efb0c-129">[!code-cs[csProgGuideStrings #2](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_2.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-129">[!code-cs[csProgGuideStrings#2](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_2.cs)]</span></span>  
  
 <span data-ttu-id="efb0c-130">문자열 "수정"은 실제로 새 문자열을 만드는 것이므로 문자열에 대한 참조를 만들 때 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-130">Because a string "modification" is actually a new string creation, you must use caution when you create references to strings.</span></span> <span data-ttu-id="efb0c-131">문자열에 대한 참조를 만든 후 원래 문자열을 "수정"하더라도 참조는 문자열을 수정할 때 만든 새 개체가 아니라 원래 개체를 계속 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-131">If you create a reference to a string, and then "modify" the original string, the reference will continue to point to the original object instead of the new object that was created when the string was modified.</span></span> <span data-ttu-id="efb0c-132">이 동작은 다음 코드에서 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-132">The following code illustrates this behavior:</span></span>  
  
 <span data-ttu-id="efb0c-133">[!code-cs[csProgGuideStrings #25](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_3.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-133">[!code-cs[csProgGuideStrings#25](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_3.cs)]</span></span>  
  
 <span data-ttu-id="efb0c-134">원래 문자열에 대한 검색 및 바꾸기 작업과 같이, 수정을 기반으로 하는 새 문자열 작성 방법에 대한 자세한 내용은 [방법: 문자열 콘텐츠 수정](../../../csharp/programming-guide/strings/how-to-modify-string-contents.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="efb0c-134">For more information about how to create new strings that are based on modifications such as search and replace operations on the original string, see [How to: Modify String Contents](../../../csharp/programming-guide/strings/how-to-modify-string-contents.md).</span></span>  
  
## <a name="regular-and-verbatim-string-literals"></a><span data-ttu-id="efb0c-135">일반 및 축자 문자열 리터럴</span><span class="sxs-lookup"><span data-stu-id="efb0c-135">Regular and Verbatim String Literals</span></span>  
 <span data-ttu-id="efb0c-136">다음 예제와 같이 C#에서 제공하는 이스케이프 문자를 포함해야 하는 경우 일반 문자열 리터럴을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-136">Use regular string literals when you must embed escape characters provided by C#, as shown in the following example:</span></span>  
  
 <span data-ttu-id="efb0c-137">[!code-cs[csProgGuideStrings #3](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_4.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-137">[!code-cs[csProgGuideStrings#3](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_4.cs)]</span></span>  
  
 <span data-ttu-id="efb0c-138">문자열 텍스트에 백슬래시 문자가 포함된 경우 가독성을 높이고 편의를 위해 축자 문자열을 사용합니다(예: 파일 경로).</span><span class="sxs-lookup"><span data-stu-id="efb0c-138">Use verbatim strings for convenience and better readability when the string text contains backslash characters, for example in file paths.</span></span> <span data-ttu-id="efb0c-139">축자 문자열에서는 문자열 텍스트의 일부로 줄 바꿈 문자가 유지되므로 여러 줄 문자열을 초기화하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-139">Because verbatim strings preserve new line characters as part of the string text, they can be used to initialize multiline strings.</span></span> <span data-ttu-id="efb0c-140">축자 문자열 내에 따옴표를 포함하려면 큰따옴표를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="efb0c-140">Use double quotation marks to embed a quotation mark inside a verbatim string.</span></span> <span data-ttu-id="efb0c-141">다음 예제에서는 몇 가지 일반적인 축자 문자열에 대한 사용을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-141">The following example shows some common uses for verbatim strings:</span></span>  
  
 <span data-ttu-id="efb0c-142">[!code-cs[csProgGuideStrings #4](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_5.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-142">[!code-cs[csProgGuideStrings#4](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_5.cs)]</span></span>  
  
## <a name="string-escape-sequences"></a><span data-ttu-id="efb0c-143">문자열 이스케이프 시퀀스</span><span class="sxs-lookup"><span data-stu-id="efb0c-143">String Escape Sequences</span></span>  
  
|<span data-ttu-id="efb0c-144">이스케이프 시퀀스</span><span class="sxs-lookup"><span data-stu-id="efb0c-144">Escape sequence</span></span>|<span data-ttu-id="efb0c-145">문자 이름</span><span class="sxs-lookup"><span data-stu-id="efb0c-145">Character name</span></span>|<span data-ttu-id="efb0c-146">유니코드 인코딩</span><span class="sxs-lookup"><span data-stu-id="efb0c-146">Unicode encoding</span></span>|  
|---------------------|--------------------|----------------------|  
|<span data-ttu-id="efb0c-147">\\'</span><span class="sxs-lookup"><span data-stu-id="efb0c-147">\\'</span></span>|<span data-ttu-id="efb0c-148">작은따옴표</span><span class="sxs-lookup"><span data-stu-id="efb0c-148">Single quote</span></span>|<span data-ttu-id="efb0c-149">0x0027</span><span class="sxs-lookup"><span data-stu-id="efb0c-149">0x0027</span></span>|  
|<span data-ttu-id="efb0c-150">\\"</span><span class="sxs-lookup"><span data-stu-id="efb0c-150">\\"</span></span>|<span data-ttu-id="efb0c-151">큰따옴표</span><span class="sxs-lookup"><span data-stu-id="efb0c-151">Double quote</span></span>|<span data-ttu-id="efb0c-152">0x0022</span><span class="sxs-lookup"><span data-stu-id="efb0c-152">0x0022</span></span>|  
|\\\\ |<span data-ttu-id="efb0c-153">백슬래시</span><span class="sxs-lookup"><span data-stu-id="efb0c-153">Backslash</span></span>|<span data-ttu-id="efb0c-154">0x005C</span><span class="sxs-lookup"><span data-stu-id="efb0c-154">0x005C</span></span>|  
|<span data-ttu-id="efb0c-155">\0</span><span class="sxs-lookup"><span data-stu-id="efb0c-155">\0</span></span>|<span data-ttu-id="efb0c-156">Null</span><span class="sxs-lookup"><span data-stu-id="efb0c-156">Null</span></span>|<span data-ttu-id="efb0c-157">0x0000</span><span class="sxs-lookup"><span data-stu-id="efb0c-157">0x0000</span></span>|  
|<span data-ttu-id="efb0c-158">\a</span><span class="sxs-lookup"><span data-stu-id="efb0c-158">\a</span></span>|<span data-ttu-id="efb0c-159">경고</span><span class="sxs-lookup"><span data-stu-id="efb0c-159">Alert</span></span>|<span data-ttu-id="efb0c-160">0x0007</span><span class="sxs-lookup"><span data-stu-id="efb0c-160">0x0007</span></span>|  
|<span data-ttu-id="efb0c-161">\b</span><span class="sxs-lookup"><span data-stu-id="efb0c-161">\b</span></span>|<span data-ttu-id="efb0c-162">백스페이스</span><span class="sxs-lookup"><span data-stu-id="efb0c-162">Backspace</span></span>|<span data-ttu-id="efb0c-163">0x0008</span><span class="sxs-lookup"><span data-stu-id="efb0c-163">0x0008</span></span>|  
|<span data-ttu-id="efb0c-164">\f</span><span class="sxs-lookup"><span data-stu-id="efb0c-164">\f</span></span>|<span data-ttu-id="efb0c-165">폼 피드</span><span class="sxs-lookup"><span data-stu-id="efb0c-165">Form feed</span></span>|<span data-ttu-id="efb0c-166">0x000C</span><span class="sxs-lookup"><span data-stu-id="efb0c-166">0x000C</span></span>|  
|\n|<span data-ttu-id="efb0c-167">줄 바꿈</span><span class="sxs-lookup"><span data-stu-id="efb0c-167">New line</span></span>|<span data-ttu-id="efb0c-168">0x000A</span><span class="sxs-lookup"><span data-stu-id="efb0c-168">0x000A</span></span>|  
|<span data-ttu-id="efb0c-169">\r</span><span class="sxs-lookup"><span data-stu-id="efb0c-169">\r</span></span>|<span data-ttu-id="efb0c-170">캐리지 리턴</span><span class="sxs-lookup"><span data-stu-id="efb0c-170">Carriage return</span></span>|<span data-ttu-id="efb0c-171">0x000D</span><span class="sxs-lookup"><span data-stu-id="efb0c-171">0x000D</span></span>|  
|<span data-ttu-id="efb0c-172">\t</span><span class="sxs-lookup"><span data-stu-id="efb0c-172">\t</span></span>|<span data-ttu-id="efb0c-173">가로 탭</span><span class="sxs-lookup"><span data-stu-id="efb0c-173">Horizontal tab</span></span>|<span data-ttu-id="efb0c-174">0x0009</span><span class="sxs-lookup"><span data-stu-id="efb0c-174">0x0009</span></span>|  
|<span data-ttu-id="efb0c-175">\U</span><span class="sxs-lookup"><span data-stu-id="efb0c-175">\U</span></span>|<span data-ttu-id="efb0c-176">서로게이트 쌍의 경우 유니코드 이스케이프 시퀀스</span><span class="sxs-lookup"><span data-stu-id="efb0c-176">Unicode escape sequence for surrogate pairs.</span></span>|<span data-ttu-id="efb0c-177">\Unnnnnnnn</span><span class="sxs-lookup"><span data-stu-id="efb0c-177">\Unnnnnnnn</span></span>|  
|<span data-ttu-id="efb0c-178">\u</span><span class="sxs-lookup"><span data-stu-id="efb0c-178">\u</span></span>|<span data-ttu-id="efb0c-179">유니코드 이스케이프 시퀀스</span><span class="sxs-lookup"><span data-stu-id="efb0c-179">Unicode escape sequence</span></span>|<span data-ttu-id="efb0c-180">\u0041 = "A"</span><span class="sxs-lookup"><span data-stu-id="efb0c-180">\u0041 = "A"</span></span>|  
|<span data-ttu-id="efb0c-181">\v</span><span class="sxs-lookup"><span data-stu-id="efb0c-181">\v</span></span>|<span data-ttu-id="efb0c-182">세로 탭</span><span class="sxs-lookup"><span data-stu-id="efb0c-182">Vertical tab</span></span>|<span data-ttu-id="efb0c-183">0x000B</span><span class="sxs-lookup"><span data-stu-id="efb0c-183">0x000B</span></span>|  
|<span data-ttu-id="efb0c-184">\x</span><span class="sxs-lookup"><span data-stu-id="efb0c-184">\x</span></span>|<span data-ttu-id="efb0c-185">길이가 변하는 경우를 제외하고 "\u"와 유사한 유니코드 이스케이프 시퀀스합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-185">Unicode escape sequence similar to "\u" except with variable length.</span></span>|<span data-ttu-id="efb0c-186">\x0041 = "A"</span><span class="sxs-lookup"><span data-stu-id="efb0c-186">\x0041 = "A"</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="efb0c-187">컴파일 시 축자 문자열은 모두 동일한 이스케이프 시퀀스가 포함된 일반 문자열로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-187">At compile time, verbatim strings are converted to ordinary strings with all the same escape sequences.</span></span> <span data-ttu-id="efb0c-188">따라서 디버거 조사식 창에서 축자 문자열을 확인할 경우 소스 코드의 축자 버전이 아니라 컴파일러에 의해 추가된 이스케이프 문자가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-188">Therefore, if you view a verbatim string in the debugger watch window, you will see the escape characters that were added by the compiler, not the verbatim version from your source code.</span></span> <span data-ttu-id="efb0c-189">예를 들어 축자 문자열 @"C:\files.txt"는 조사식 창에 "c:\\\files.txt"로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-189">For example, the verbatim string @"C:\files.txt" will appear in the watch window as "C:\\\files.txt".</span></span>  
  
## <a name="format-strings"></a><span data-ttu-id="efb0c-190">형식 문자열</span><span class="sxs-lookup"><span data-stu-id="efb0c-190">Format Strings</span></span>  
 <span data-ttu-id="efb0c-191">형식 문자열은 콘텐츠가 런타임 시 동적으로 결정될 수 있는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-191">A format string is a string whose contents can be determined dynamically at runtime.</span></span> <span data-ttu-id="efb0c-192">정적 <xref:System.String.Format%2A> 메서드를 사용하고, 런타임 시 다른 값으로 바뀔 자리 표시자를 중괄호에 포함하여 형식 문자열을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-192">You create a format string by using the static <xref:System.String.Format%2A> method and embedding placeholders in braces that will be replaced by other values at runtime.</span></span> <span data-ttu-id="efb0c-193">다음 예제에서는 형식 문자열을 사용하여 루프의 각 반복의 결과를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-193">The following example uses a format string to output the result of each iteration of a loop:</span></span>  
  
 <span data-ttu-id="efb0c-194">[!code-cs[csProgGuideStrings#26](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_6.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-194">[!code-cs[csProgGuideStrings#26](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_6.cs)]</span></span>  
  
 <span data-ttu-id="efb0c-195"><xref:System.Console.WriteLine%2A> 메서드를 한 번 오버로드하면 형식 문자열을 매개 변수로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-195">One overload of the <xref:System.Console.WriteLine%2A> method takes a format string as a parameter.</span></span> <span data-ttu-id="efb0c-196">따라서 메서드에 대한 명시적 호출이 없어도 형식 문자열 리터럴을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-196">Therefore, you can just embed a format string literal without an explicit call to the method.</span></span> <span data-ttu-id="efb0c-197">그러나 <xref:System.Diagnostics.Trace.WriteLine%2A>은 형식 문자열이 아닌 문자열만 허용하므로, <xref:System.Diagnostics.Trace.WriteLine%2A> 메서드를 사용하여 Visual Studio **출력** 창에 디버그 출력을 표시할 경우에는 <xref:System.String.Format%2A> 메서드를 명시적으로 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-197">However, if you use the <xref:System.Diagnostics.Trace.WriteLine%2A> method to display debug output in the Visual Studio **Output** window, you have to explicitly call the <xref:System.String.Format%2A> method because <xref:System.Diagnostics.Trace.WriteLine%2A> only accepts a string, not a format string.</span></span> <span data-ttu-id="efb0c-198">형식 문자열에 대한 자세한 내용은 [형식 서식 지정](../../../standard/base-types/formatting-types.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="efb0c-198">For more information about format strings, see [Formatting Types](../../../standard/base-types/formatting-types.md).</span></span>  
  
## <a name="substrings"></a><span data-ttu-id="efb0c-199">부분 문자열</span><span class="sxs-lookup"><span data-stu-id="efb0c-199">Substrings</span></span>  
 <span data-ttu-id="efb0c-200">부분 문자열은 문자열에 포함된 임의의 문자 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-200">A substring is any sequence of characters that is contained in a string.</span></span> <span data-ttu-id="efb0c-201">원래 문자열 일부에서 새 문자열을 만들려면 <xref:System.String.Substring%2A> 메서드를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="efb0c-201">Use the <xref:System.String.Substring%2A> method to create a new string from a part of the original string.</span></span> <span data-ttu-id="efb0c-202"><xref:System.String.IndexOf%2A> 메서드를 사용하면 부분 문자열 항목을 하나 이상 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-202">You can search for one or more occurrences of a substring by using the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="efb0c-203">지정된 부분 문자열의 모든 항목을 새 문자열로 바꾸려면 <xref:System.String.Replace%2A> 메서드를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="efb0c-203">Use the <xref:System.String.Replace%2A> method to replace all occurrences of a specified substring with a new string.</span></span> <span data-ttu-id="efb0c-204"><xref:System.String.Substring%2A> 메서드와 마찬가지로, <xref:System.String.Replace%2A>는 실제로 새 문자열을 반환하며, 원래 문자열은 수정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-204">Like the <xref:System.String.Substring%2A> method, <xref:System.String.Replace%2A> actually returns a new string and does not modify the original string.</span></span> <span data-ttu-id="efb0c-205">자세한 내용은 [방법: 문자열 메서드를 사용하여 문자열 검색](../../../csharp/programming-guide/strings/how-to-search-strings-using-string-methods.md) 및 [방법: 문자열 콘텐츠 수정](../../../csharp/programming-guide/strings/how-to-modify-string-contents.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="efb0c-205">For more information, see [How to: Search Strings Using String Methods](../../../csharp/programming-guide/strings/how-to-search-strings-using-string-methods.md) and [How to: Modify String Contents](../../../csharp/programming-guide/strings/how-to-modify-string-contents.md).</span></span>  
  
 <span data-ttu-id="efb0c-206">[!code-cs[csProgGuideStrings #7](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_7.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-206">[!code-cs[csProgGuideStrings#7](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_7.cs)]</span></span>  
  
## <a name="accessing-individual-characters"></a><span data-ttu-id="efb0c-207">개별 문자 액세스</span><span class="sxs-lookup"><span data-stu-id="efb0c-207">Accessing Individual Characters</span></span>  
 <span data-ttu-id="efb0c-208">다음 예제와 같이 인덱스 값이 있는 배열 표기법을 사용하여 개별 문자에 대한 읽기 전용 액세스 권한을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-208">You can use array notation with an index value to acquire read-only access to individual characters, as in the following example:</span></span>  
  
 <span data-ttu-id="efb0c-209">[!code-cs[csProgGuideStrings #9](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_8.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-209">[!code-cs[csProgGuideStrings#9](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_8.cs)]</span></span>  
  
 <span data-ttu-id="efb0c-210">문자열에서 개별 문자를 수정해야 하는 기능이 <xref:System.String> 메서드에서 제공되지 않는 경우에는 <xref:System.Text.StringBuilder> 개체를 사용하여 개별 문자를 "현재 위치"에서 수정한 후 새 문자열을 만들어 <xref:System.Text.StringBuilder> 메서드로 결과를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-210">If the <xref:System.String> methods do not provide the functionality that you must have to modify individual characters in a string, you can use a <xref:System.Text.StringBuilder> object to modify the individual chars "in-place", and then create a new string to store the results by using the <xref:System.Text.StringBuilder> methods.</span></span> <span data-ttu-id="efb0c-211">다음 예제에서는 특정 방식으로 원래 문자열을 수정한 다음 나중에 사용할 수 있도록 결과를 저장해야 한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-211">In the following example, assume that you must modify the original string in a particular way and then store the results for future use:</span></span>  
  
 <span data-ttu-id="efb0c-212">[!code-cs[csProgGuideStrings #8](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_9.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-212">[!code-cs[csProgGuideStrings#8](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_9.cs)]</span></span>  
  
## <a name="null-strings-and-empty-strings"></a><span data-ttu-id="efb0c-213">null 문자열 및 빈 문자열</span><span class="sxs-lookup"><span data-stu-id="efb0c-213">Null Strings and Empty Strings</span></span>  
 <span data-ttu-id="efb0c-214">빈 문자열은 문자가 포함되지 않은 <xref:System.String?displayProperty=fullName> 개체의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-214">An empty string is an instance of a <xref:System.String?displayProperty=fullName> object that contains zero characters.</span></span> <span data-ttu-id="efb0c-215">빈 문자열은 빈 텍스트 필드를 나타내는 다양한 프로그래밍 시나리오에서 자주 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-215">Empty strings are used often in various programming scenarios to represent a blank text field.</span></span> <span data-ttu-id="efb0c-216">빈 문자열은 유효한 <xref:System.String?displayProperty=fullName> 개체이므로 빈 문자열에 대해 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-216">You can call methods on empty strings because they are valid <xref:System.String?displayProperty=fullName> objects.</span></span> <span data-ttu-id="efb0c-217">빈 문자열은 다음과 같이 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-217">Empty strings are initialized as follows:</span></span>  
  
```  
string s = String.Empty;  
```  
  
 <span data-ttu-id="efb0c-218">반면, null 문자열은 <xref:System.String?displayProperty=fullName> 개체의 인스턴스를 참조하지 않으므로 null 문자열에서 메서드를 호출하려고 하면 <xref:System.NullReferenceException>이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-218">By contrast, a null string does not refer to an instance of a <xref:System.String?displayProperty=fullName> object and any attempt to call a method on a null string causes a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="efb0c-219">그러나 다른 문자열과 연결 및 비교 작업에서는 null 문자열을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-219">However, you can use null strings in concatenation and comparison operations with other strings.</span></span> <span data-ttu-id="efb0c-220">다음 예제에는 null 문자열에 대한 참조로 예외가 발생하거나 발생하지 않는 몇 가지 경우가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-220">The following examples illustrate some cases in which a reference to a null string does and does not cause an exception to be thrown:</span></span>  
  
 <span data-ttu-id="efb0c-221">[!code-cs[csProgGuideStrings #27](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_10.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-221">[!code-cs[csProgGuideStrings#27](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_10.cs)]</span></span>  
  
## <a name="using-stringbuilder-for-fast-string-creation"></a><span data-ttu-id="efb0c-222">빠른 문자열 생성을 위한 StringBuilder 사용</span><span class="sxs-lookup"><span data-stu-id="efb0c-222">Using StringBuilder for Fast String Creation</span></span>  
 <span data-ttu-id="efb0c-223">.NET에서 문자열 작업은 고도로 최적화되어 있으므로 대부분의 경우 성능에 크게 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-223">String operations in .NET are highly optimized and in most cases do not significantly impact performance.</span></span> <span data-ttu-id="efb0c-224">그러나 수백 번 또는 수천 번 실행하는 타이트 루프와 같은 일부 시나리오에서는 문자열 작업이 성능에 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-224">However, in some scenarios such as tight loops that are executing many hundreds or thousands of times, string operations can affect performance.</span></span> <span data-ttu-id="efb0c-225">프로그램이 여러 문자열 조작을 수행하는 경우에는 <xref:System.Text.StringBuilder> 클래스에서 개선된 성능을 제공하는 문자열 버퍼를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-225">The <xref:System.Text.StringBuilder> class creates a string buffer that offers better performance if your program performs many string manipulations.</span></span> <span data-ttu-id="efb0c-226"><xref:System.Text.StringBuilder> 문자열을 사용하면 개별 문자를 다시 할당할 수도 있지만 기본 제공 문자열 데이터 형식을 지원하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-226">The <xref:System.Text.StringBuilder> string also enables you to reassign individual characters, something the built-in string data type does not support.</span></span> <span data-ttu-id="efb0c-227">예를 들어 이 코드는 새 문자열을 만들지 않고 문자열의 콘텐츠를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-227">This code, for example, changes the content of a string without creating a new string:</span></span>  
  
 <span data-ttu-id="efb0c-228">[!code-cs[csProgGuideStrings #20](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_11.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-228">[!code-cs[csProgGuideStrings#20](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_11.cs)]</span></span>  
  
 <span data-ttu-id="efb0c-229">이 예제에서 <xref:System.Text.StringBuilder> 개체는 숫자 형식 집합에서 문자열을 만드는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-229">In this example, a <xref:System.Text.StringBuilder> object is used to create a string from a set of numeric types:</span></span>  
  
 <span data-ttu-id="efb0c-230">[!code-cs[csProgGuideStrings #15](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_12.cs)]</span><span class="sxs-lookup"><span data-stu-id="efb0c-230">[!code-cs[csProgGuideStrings#15](../../../csharp/programming-guide/strings/codesnippet/CSharp/index_12.cs)]</span></span>  
  
## <a name="strings-extension-methods-and-linq"></a><span data-ttu-id="efb0c-231">문자열, 확장 메서드 및 LINQ</span><span class="sxs-lookup"><span data-stu-id="efb0c-231">Strings, Extension Methods and LINQ</span></span>  
 <span data-ttu-id="efb0c-232"><xref:System.String> 형식이 <xref:System.Collections.Generic.IEnumerable%601>을 구현하므로 문자열에서 <xref:System.Linq.Enumerable> 클래스에 정의된 확장 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-232">Because the <xref:System.String> type implements <xref:System.Collections.Generic.IEnumerable%601>, you can use the extension methods defined in the <xref:System.Linq.Enumerable> class on strings.</span></span> <span data-ttu-id="efb0c-233">시각적인 혼란을 방지하기 위해 <xref:System.String> 형식의 경우 이러한 메서드가 IntelliSense에서 제외되지만, 제외되더라도 사용할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-233">To avoid visual clutter, these methods are excluded from IntelliSense for the <xref:System.String> type, but they are available nevertheless.</span></span> <span data-ttu-id="efb0c-234">문자열에서 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 쿼리 식을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-234">You can also use [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query expressions on strings.</span></span> <span data-ttu-id="efb0c-235">자세한 내용은 [LINQ 및 문자열](../../../csharp/programming-guide/concepts/linq/linq-and-strings.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="efb0c-235">For more information, see [LINQ and Strings](../../../csharp/programming-guide/concepts/linq/linq-and-strings.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="efb0c-236">관련 항목</span><span class="sxs-lookup"><span data-stu-id="efb0c-236">Related Topics</span></span>  
  
|<span data-ttu-id="efb0c-237">항목</span><span class="sxs-lookup"><span data-stu-id="efb0c-237">Topic</span></span>|<span data-ttu-id="efb0c-238">설명</span><span class="sxs-lookup"><span data-stu-id="efb0c-238">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="efb0c-239">방법: 문자열 내용 수정</span><span class="sxs-lookup"><span data-stu-id="efb0c-239">How to: Modify String Contents</span></span>](../../../csharp/programming-guide/strings/how-to-modify-string-contents.md)|<span data-ttu-id="efb0c-240">문자열의 콘텐츠를 수정하는 방법을 보여 주는 코드 예제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-240">Provides a code example that illustrates how to modify the contents of strings.</span></span>|  
|[<span data-ttu-id="efb0c-241">방법: 여러 문자열 연결</span><span class="sxs-lookup"><span data-stu-id="efb0c-241">How to: Concatenate Multiple Strings</span></span>](../../../csharp/programming-guide/strings/how-to-concatenate-multiple-strings.md)|<span data-ttu-id="efb0c-242">`+` 연산자 및 `Stringbuilder` 클래스를 사용하여 컴파일 및 런타임 시 문자열을 서로 조인하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-242">Illustrates how to use the `+` operator and the `Stringbuilder` class to join strings together at compile time and run time.</span></span>|  
|[<span data-ttu-id="efb0c-243">방법: 문자열 비교</span><span class="sxs-lookup"><span data-stu-id="efb0c-243">How to: Compare Strings</span></span>](../../../csharp/programming-guide/strings/how-to-compare-strings.md)|<span data-ttu-id="efb0c-244">문자열의 서수 비교를 수행하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-244">Shows how to perform ordinal comparisons of strings.</span></span>|  
|[<span data-ttu-id="efb0c-245">방법: String.Split을 사용하여 문자열 구문 분석</span><span class="sxs-lookup"><span data-stu-id="efb0c-245">How to: Parse Strings Using String.Split </span></span>](../../../csharp/programming-guide/strings/how-to-parse-strings-using-string-split.md)|<span data-ttu-id="efb0c-246">`String.Split` 메서드 문자열을 사용하여 문자열을 구문 분석하는 방법을 보여 주는 코드 예제가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-246">Contains a code example that illustrates how to use the `String.Split` method to parse strings.</span></span>|  
|[<span data-ttu-id="efb0c-247">방법: 문자열 메서드를 사용하여 문자열 검색</span><span class="sxs-lookup"><span data-stu-id="efb0c-247">How to: Search Strings Using String Methods</span></span>](../../../csharp/programming-guide/strings/how-to-search-strings-using-string-methods.md)|<span data-ttu-id="efb0c-248">특정 메서드를 사용하여 문자열을 검색하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-248">Explains how to use specific methods to search strings.</span></span>|  
|[<span data-ttu-id="efb0c-249">방법: 정규식을 사용하여 문자열 검색</span><span class="sxs-lookup"><span data-stu-id="efb0c-249">How to: Search Strings Using Regular Expressions</span></span>](../../../csharp/programming-guide/strings/how-to-search-strings-using-regular-expressions.md)|<span data-ttu-id="efb0c-250">정규식을 사용하여 문자열을 검색하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-250">Explains how to use regular expressions to search strings.</span></span>|  
|[<span data-ttu-id="efb0c-251">방법: 문자열이 숫자 값을 나타내는지 확인</span><span class="sxs-lookup"><span data-stu-id="efb0c-251">How to: Determine Whether a String Represents a Numeric Value</span></span>](../../../csharp/programming-guide/strings/how-to-determine-whether-a-string-represents-a-numeric-value.md)|<span data-ttu-id="efb0c-252">문자열에 올바른 숫자 값이 있는지 여부를 확인할 수 있도록 문자열을 안전하게 구문 분석하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-252">Shows how to safely parse a string to see whether it has a valid numeric value.</span></span>|  
|[<span data-ttu-id="efb0c-253">방법: 문자열을 DateTime으로 변환</span><span class="sxs-lookup"><span data-stu-id="efb0c-253">How to: Convert a String to a DateTime</span></span>](../../../csharp/programming-guide/strings/how-to-convert-a-string-to-a-datetime.md)|<span data-ttu-id="efb0c-254">"01/24/2008"과 같은 문자열을 <xref:System.DateTime?displayProperty=fullName> 개체로 변환하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-254">Shows how to convert a string such as "01/24/2008" to a <xref:System.DateTime?displayProperty=fullName> object.</span></span>|  
|[<span data-ttu-id="efb0c-255">기본적인 문자열 작업</span><span class="sxs-lookup"><span data-stu-id="efb0c-255">Basic String Operations</span></span>](https://msdn.microsoft.com/library/a292he7t)|<span data-ttu-id="efb0c-256"><xref:System.String?displayProperty=fullName> 및 <xref:System.Text.StringBuilder?displayProperty=fullName> 메서드를 사용하여 기본적인 문자열 작업을 수행하는 항목에 대한 링크를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-256">Provides links to topics that use <xref:System.String?displayProperty=fullName> and <xref:System.Text.StringBuilder?displayProperty=fullName> methods to perform basic string operations.</span></span>|  
|[<span data-ttu-id="efb0c-257">문자열 구문 분석</span><span class="sxs-lookup"><span data-stu-id="efb0c-257">Parsing Strings</span></span>](https://msdn.microsoft.com/library/b4w53z0y)|<span data-ttu-id="efb0c-258">문자열에 문자 또는 공백을 삽입하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-258">Describes how to insert characters or empty spaces into a string.</span></span>|  
|[<span data-ttu-id="efb0c-259">문자열 비교</span><span class="sxs-lookup"><span data-stu-id="efb0c-259">Comparing Strings</span></span>](https://msdn.microsoft.com/library/fbh501kz)|<span data-ttu-id="efb0c-260">문자열을 비교하는 방법에 대한 정보가 포함되어 있으며, C# 및 Visual Basic의 예제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-260">Includes information about how to compare strings and provides examples in C# and Visual Basic.</span></span>|  
|[<span data-ttu-id="efb0c-261">StringBuilder 클래스 사용</span><span class="sxs-lookup"><span data-stu-id="efb0c-261">Using the StringBuilder Class</span></span>](../../../standard/base-types/stringbuilder.md)|<span data-ttu-id="efb0c-262"><xref:System.Text.StringBuilder> 클래스를 사용하여 동적 문자열 개체를 만들고 수정하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-262">Describes how to create and modify dynamic string objects by using the <xref:System.Text.StringBuilder> class.</span></span>|  
|[<span data-ttu-id="efb0c-263">LINQ 및 문자열</span><span class="sxs-lookup"><span data-stu-id="efb0c-263">LINQ and Strings</span></span>](../../../csharp/programming-guide/concepts/linq/linq-and-strings.md)|<span data-ttu-id="efb0c-264">LINQ 쿼리를 사용하여 다양한 문자열 작업을 수행하는 방법에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-264">Provides information about how to perform various string operations by using LINQ queries.</span></span>|  
|[<span data-ttu-id="efb0c-265">C# 프로그래밍 가이드</span><span class="sxs-lookup"><span data-stu-id="efb0c-265">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)|<span data-ttu-id="efb0c-266">C#에서 프로그래밍 구문을 설명하는 항목에 대한 링크를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb0c-266">Provides links to topics that explain programming constructs in C#.</span></span>|  


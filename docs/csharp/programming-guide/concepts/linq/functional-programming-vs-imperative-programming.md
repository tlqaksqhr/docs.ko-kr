---
title: 함수형 프로그래밍과 명령형 프로그래밍 비교(C#)
ms.date: 07/20/2015
ms.assetid: 5e35c5a0-c949-422a-873b-fca6b2254f57
ms.openlocfilehash: 85e0e4bf287157f2d4f952996cbb2e5a4ff6ac89
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33334901"
---
# <a name="functional-programming-vs-imperative-programming-c"></a><span data-ttu-id="4b1db-102">함수형 프로그래밍과 명령형 프로그래밍 비교(C#)</span><span class="sxs-lookup"><span data-stu-id="4b1db-102">Functional Programming vs. Imperative Programming (C#)</span></span>
<span data-ttu-id="4b1db-103">이 항목에서는 함수형 프로그래밍을 더욱 일반적인 명령형(절차적) 프로그래밍과 비교하고 대조합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-103">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="4b1db-104">함수형 프로그래밍과 명령형 프로그래밍 비교</span><span class="sxs-lookup"><span data-stu-id="4b1db-104">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="4b1db-105">*함수형 프로그래밍* 패러다임은 순수하게 함수적인 접근 방법으로 문제를 해결하는 것을 지원하기 위해 만들어졌습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-105">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="4b1db-106">함수형 프로그래밍은 *선언적 프로그래밍*의 형태로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-106">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="4b1db-107">이와 대조적으로 C#, Visual Basic, C++ 및 Java와 같은 OOP(개체 지향 프로그래밍) 언어를 비롯한 대부분의 주류 언어는 주로 *명령형*(절차적) 프로그래밍을 지원하기 위해 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-107">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="4b1db-108">명령형 방법을 사용하는 경우 개발자는 컴퓨터에서 목표를 이루기 위해 수행해야 하는 단계를 매우 자세히 설명하는 코드를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-108">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="4b1db-109">이러한 프로그래밍을 *알고리즘* 프로그래밍이라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-109">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="4b1db-110">이와 대조적으로 함수형 방법에는 실행할 일련의 함수로 문제를 구성하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-110">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="4b1db-111">이 경우 각 함수에 대한 입력과 각 함수가 반환하는 항목을 신중하게 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-111">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="4b1db-112">다음 표에서는 이러한 두 방법의 일반적인 차이점에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-112">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="4b1db-113">특성</span><span class="sxs-lookup"><span data-stu-id="4b1db-113">Characteristic</span></span>|<span data-ttu-id="4b1db-114">명령형 방법</span><span class="sxs-lookup"><span data-stu-id="4b1db-114">Imperative approach</span></span>|<span data-ttu-id="4b1db-115">함수형 방법</span><span class="sxs-lookup"><span data-stu-id="4b1db-115">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="4b1db-116">프로그래머가 중점을 두는 부분</span><span class="sxs-lookup"><span data-stu-id="4b1db-116">Programmer focus</span></span>|<span data-ttu-id="4b1db-117">작업을 수행하는 방법(알고리즘)과 상태의 변경을 추적하는 방법</span><span class="sxs-lookup"><span data-stu-id="4b1db-117">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="4b1db-118">원하는 정보와 필요한 변환</span><span class="sxs-lookup"><span data-stu-id="4b1db-118">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="4b1db-119">상태 변경</span><span class="sxs-lookup"><span data-stu-id="4b1db-119">State changes</span></span>|<span data-ttu-id="4b1db-120">중요</span><span class="sxs-lookup"><span data-stu-id="4b1db-120">Important.</span></span>|<span data-ttu-id="4b1db-121">존재하지 않음</span><span class="sxs-lookup"><span data-stu-id="4b1db-121">Non-existent.</span></span>|  
|<span data-ttu-id="4b1db-122">실행 순서</span><span class="sxs-lookup"><span data-stu-id="4b1db-122">Order of execution</span></span>|<span data-ttu-id="4b1db-123">중요</span><span class="sxs-lookup"><span data-stu-id="4b1db-123">Important.</span></span>|<span data-ttu-id="4b1db-124">중요도가 낮음</span><span class="sxs-lookup"><span data-stu-id="4b1db-124">Low importance.</span></span>|  
|<span data-ttu-id="4b1db-125">주요 흐름 제어</span><span class="sxs-lookup"><span data-stu-id="4b1db-125">Primary flow control</span></span>|<span data-ttu-id="4b1db-126">루프, 조건 및 함수(메서드) 호출</span><span class="sxs-lookup"><span data-stu-id="4b1db-126">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="4b1db-127">재귀를 비롯한 함수 호출</span><span class="sxs-lookup"><span data-stu-id="4b1db-127">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="4b1db-128">주요 조작 단위</span><span class="sxs-lookup"><span data-stu-id="4b1db-128">Primary manipulation unit</span></span>|<span data-ttu-id="4b1db-129">클래스나 구조체의 인스턴스</span><span class="sxs-lookup"><span data-stu-id="4b1db-129">Instances of structures or classes.</span></span>|<span data-ttu-id="4b1db-130">1급(first-class) 개체와 데이터 컬렉션인 함수</span><span class="sxs-lookup"><span data-stu-id="4b1db-130">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="4b1db-131">대부분의 언어가 특정 프로그래밍 패러다임을 지원하도록 디자인되었지만 대부분의 일반 언어도 다양한 패러다임을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-131">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="4b1db-132">예를 들어, 함수 포인터가 있는 언어로 함수형 프로그래밍을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-132">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="4b1db-133">또한 C#에서는 람다 식과 형식 유추를 비롯한 함수형 프로그래밍을 지원하기 위해 명시적 언어 확장을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-133">Furthermore, C# includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="4b1db-134">LINQ 기술은 선언적 함수형 프로그래밍의 형태입니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-134">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="4b1db-135">XSLT를 사용하는 함수형 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="4b1db-135">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="4b1db-136">많은 XSLT 개발자는 순수 함수형 방법에 익숙합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-136">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="4b1db-137">XSLT 스타일시트를 개발하는 가장 효과적인 방법은 각 템플릿을 구성 가능한 분리된 변환으로 처리하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-137">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="4b1db-138">실행 순서는 완전히 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-138">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="4b1db-139">XSLT는 절차적 코드 실행에 대한 이스케이프 메커니즘으로 인해 비순수 함수가 생성되는 의도하지 않은 결과를 발생시킬 수 있는 점을 제외하고 의도하지 않은 결과를 허용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-139">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="4b1db-140">XSLT가 효과적인 도구이긴 하지만 일부 특징은 최적이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-140">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="4b1db-141">예를 들어, XML로 프로그래밍 구문을 표현하면 비교적 상세한 코드가 생성되므로 코드를 유지 관리하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-141">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="4b1db-142">또한 재귀에 크게 의존하여 흐름을 제어하면 읽기 어려운 코드가 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-142">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="4b1db-143">XSLT에 대한 자세한 내용은 [XSLT 변환](../../../../standard/data/xml/xslt-transformations.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b1db-143">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>  
  
 <span data-ttu-id="4b1db-144">그러나 XSLT는 XML의 모양을 변환하는 데 순수 함수형 방법을 사용하는 경우의 가치를 입증합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-144">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="4b1db-145">LINQ to XML을 사용하는 순수 함수형 프로그래밍은 많은 부분이 XSLT와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-145">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="4b1db-146">그러나 LINQ to XML과 C#에 도입된 프로그래밍 구문을 사용하면 XSLT보다 읽기 쉽고 유지 관리가 용이한 순수 함수 변환을 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-146">However, the programming constructs introduced by LINQ to XML and C#  allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="4b1db-147">순수 함수의 이점</span><span class="sxs-lookup"><span data-stu-id="4b1db-147">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="4b1db-148">함수 변환을 순수 함수로 구현하는 기본적인 이유는 순수 함수가 구성 가능하기 때문입니다. 즉, 순수 함수는 상태 비저장, 자체 포함 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-148">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="4b1db-149">이러한 특징은 다음과 같은 여러 가지 이점을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-149">These characteristics bring a number of benefits, including the following:</span></span>  
  
-   <span data-ttu-id="4b1db-150">가독성과 유지 관리 편의성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-150">Increased readability and maintainability.</span></span> <span data-ttu-id="4b1db-151">이는 각 함수가 인수가 제공되는 경우 특정 태스크를 완료하도록 디자인되었기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-151">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="4b1db-152">함수는 외부 상태에 의존하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-152">The function does not rely on any external state.</span></span>  
  
-   <span data-ttu-id="4b1db-153">반복되는 개발이 쉬워집니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-153">Easier reiterative development.</span></span> <span data-ttu-id="4b1db-154">코드를 리팩터링하기가 쉬워서 디자인 변경 사항을 구현하기가 더욱 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-154">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="4b1db-155">예를 들어, 복잡한 변환을 작성할 때 일부 코드가 변환에서 몇 번 반복되는 경우</span><span class="sxs-lookup"><span data-stu-id="4b1db-155">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="4b1db-156">순수 메서드를 통해 리팩터링하면 의도하지 않은 결과가 발생할 것에 대해 걱정하지 않고 원하는 대로 순수 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-156">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
-   <span data-ttu-id="4b1db-157">테스트와 디버깅이 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-157">Easier testing and debugging.</span></span> <span data-ttu-id="4b1db-158">순수 함수를 분리하여 더 용이하게 테스트할 수 있기 때문에 일반적인 값, 유효한 경계 경우 및 무효한 경계 경우를 사용하여 순수 함수를 호출하는 테스트 코드를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-158">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="4b1db-159">OOP 개발자의 전환</span><span class="sxs-lookup"><span data-stu-id="4b1db-159">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="4b1db-160">일반적인 OOP(개체 지향 프로그래밍)에서 대부분의 개발자는 명령형/절차적 스타일로 프로그래밍하는 데 익숙합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-160">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="4b1db-161">순수 함수 스타일의 개발로 전환하려면 사고 방식과 개발 방법을 전환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-161">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="4b1db-162">OOP 개발자는 문제를 해결하기 위해 클래스 계층 구조를 디자인하고, 적절하게 캡슐화하는 데 중점을 두며, 클래스 계약 측면에서 사고합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-162">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="4b1db-163">개체 형식의 동작과 상태가 가장 중요하며, 클래스, 인터페이스, 상속 및 다형성과 같은 언어 기능이 이러한 문제를 처리하기 위해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-163">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="4b1db-164">이와 대조적으로 함수형 프로그래밍에서는 계산 문제를 데이터 컬렉션의 순수 함수 변환에 대한 계산에서의 실행으로 취급합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-164">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="4b1db-165">함수형 프로그래밍에서는 상태와 변경 가능한 데이터를 사용하지 않으며 대신 함수의 적용을 강조합니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-165">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="4b1db-166">다행히도 C#에서는 명령형 프로그래밍 방법과 함수형 프로그래밍 방법을 모두 지원하기 때문에 함수형 프로그래밍으로 완전히 전환할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-166">Fortunately, C# doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="4b1db-167">개발자는 특정 시나리오에 가장 적합한 방법을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-167">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="4b1db-168">실제로 프로그램에는 흔히 두 방법이 결합되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b1db-168">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4b1db-169">참고 항목</span><span class="sxs-lookup"><span data-stu-id="4b1db-169">See Also</span></span>  
 [<span data-ttu-id="4b1db-170">순수 함수 변환 소개(C#)</span><span class="sxs-lookup"><span data-stu-id="4b1db-170">Introduction to Pure Functional Transformations (C#)</span></span>](../../../../csharp/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)  
 [<span data-ttu-id="4b1db-171">XSLT 변환</span><span class="sxs-lookup"><span data-stu-id="4b1db-171">XSLT Transformations</span></span>](../../../../standard/data/xml/xslt-transformations.md)  
 [<span data-ttu-id="4b1db-172">순수 함수로 리팩터링(C#)</span><span class="sxs-lookup"><span data-stu-id="4b1db-172">Refactoring Into Pure Functions (C#)</span></span>](../../../../csharp/programming-guide/concepts/linq/refactoring-into-pure-functions.md)

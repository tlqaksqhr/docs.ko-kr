---
title: "LINQ의 쿼리 구문 및 메서드 구문(C#)"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-csharp
ms.topic: article
dev_langs:
- CSharp
helpviewer_keywords:
- LINQ [C#], query syntax vs. method syntax
- queries [LINQ in C#], syntax comparisons
ms.assetid: eedd6dd9-fec2-428c-9581-5b8783810ded
caps.latest.revision: 30
author: BillWagner
ms.author: wiwagn
translation.priority.ht:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- ru-ru
- zh-cn
- zh-tw
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: 35ad7e9b086f36ca92974fdea197da4c513c8a51
ms.contentlocale: ko-kr
ms.lasthandoff: 07/28/2017

---
# <a name="query-syntax-and-method-syntax-in-linq-c"></a><span data-ttu-id="eeed5-102">LINQ의 쿼리 구문 및 메서드 구문(C#)</span><span class="sxs-lookup"><span data-stu-id="eeed5-102">Query Syntax and Method Syntax in LINQ (C#)</span></span>
<span data-ttu-id="eeed5-103">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)](Language Integrated Query) 소개 설명서에 있는 대부분의 쿼리는 LINQ 선언적 쿼리 구문을 사용하여 작성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-103">Most queries in the introductory Language Integrated Query ([!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]) documentation are written by using the LINQ declarative query syntax.</span></span> <span data-ttu-id="eeed5-104">그러나 쿼리 구문은 코드를 컴파일할 때 .NET CLR(공용 언어 런타임)에 대한 메서드 호출로 변환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-104">However, the query syntax must be translated into method calls for the .NET common language runtime (CLR) when the code is compiled.</span></span> <span data-ttu-id="eeed5-105">이러한 메서드 호출은 `Where`, `Select`, `GroupBy`, `Join`, `Max`, `Average` 등과 같은 표준 쿼리 연산자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-105">These method calls invoke the standard query operators, which have names such as `Where`, `Select`, `GroupBy`, `Join`, `Max`, and `Average`.</span></span> <span data-ttu-id="eeed5-106">사용자는 쿼리 구문 대신 메서드 구문을 사용하여 연산자를 직접 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-106">You can call them directly by using method syntax instead of query syntax.</span></span>  
  
 <span data-ttu-id="eeed5-107">쿼리 구문과 메서드 구문은 의미상 동일하지만, 쿼리 구문이 더 간단하고 읽기 쉽다고 생각하는 사람이 많습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-107">Query syntax and method syntax are semantically identical, but many people find query syntax simpler and easier to read.</span></span> <span data-ttu-id="eeed5-108">일부 쿼리는 메서드 호출로 표현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-108">Some queries must be expressed as method calls.</span></span> <span data-ttu-id="eeed5-109">예를 들어, 지정된 조건과 일치하는 요소 수를 검색하는 쿼리를 표현하려면 메서드 호출을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-109">For example, you must use a method call to express a query that retrieves the number of elements that match a specified condition.</span></span> <span data-ttu-id="eeed5-110">또한 소스 시퀀스에서 최대값을 갖는 요소를 검색하는 쿼리에 대해서도 메서드 호출을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-110">You also must use a method call for a query that retrieves the element that has the maximum value in a source sequence.</span></span> <span data-ttu-id="eeed5-111"><xref:System.Linq> 네임스페이스의 표준 쿼리 연산자에 대한 참조 문서는 일반적으로 메서드 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-111">The reference documentation for the standard query operators in the <xref:System.Linq> namespace generally uses method syntax.</span></span> <span data-ttu-id="eeed5-112">따라서 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 쿼리를 작성하기 시작한 경우에도 쿼리 및 쿼리 식 자체에서 메서드 구문을 사용하는 방법을 잘 알고 있으면 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-112">Therefore, even when getting started writing [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] queries, it is useful to be familiar with how to use method syntax in queries and in query expressions themselves.</span></span>  
  
## <a name="standard-query-operator-extension-methods"></a><span data-ttu-id="eeed5-113">표준 쿼리 연산자 확장 메서드</span><span class="sxs-lookup"><span data-stu-id="eeed5-113">Standard Query Operator Extension Methods</span></span>  
 <span data-ttu-id="eeed5-114">다음 예제는 간단한 *쿼리 식* 및 *메서드 기반 쿼리*로서 작성된, 의미상 동등한 쿼리를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-114">The following example shows a simple *query expression* and the semantically equivalent query written as a *method-based query*.</span></span>  
  
 <span data-ttu-id="eeed5-115">[!code-cs[csLINQGettingStarted#22](../../../../csharp/programming-guide/concepts/linq/codesnippet/CSharp/query-syntax-and-method-syntax-in-linq_1.cs)]</span><span class="sxs-lookup"><span data-stu-id="eeed5-115">[!code-cs[csLINQGettingStarted#22](../../../../csharp/programming-guide/concepts/linq/codesnippet/CSharp/query-syntax-and-method-syntax-in-linq_1.cs)]</span></span>  
  
 <span data-ttu-id="eeed5-116">두 예제에서 출력은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-116">The output from the two examples is identical.</span></span> <span data-ttu-id="eeed5-117">쿼리 변수의 형식이 두 양식에서 모두 동일한 것을 알 수 있습니다(<xref:System.Collections.Generic.IEnumerable%601>).</span><span class="sxs-lookup"><span data-stu-id="eeed5-117">You can see that the type of the query variable is the same in both forms: <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="eeed5-118">메서드 기반 쿼리를 이해할 수 있도록 더 자세히 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-118">To understand the method-based query, let's examine it more closely.</span></span> <span data-ttu-id="eeed5-119">식의 오른쪽에서 `where` 절이 이제 `numbers` 개체의 인스턴스 메서드로 표현된 것을 알 수 있습니다. 이 개체를 다시 호출하면 `IEnumerable<int>` 형식을 갖게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-119">On the right side of the expression, notice that the `where` clause is now expressed as an instance method on the `numbers` object, which as you will recall has a type of `IEnumerable<int>`.</span></span> <span data-ttu-id="eeed5-120">제네릭 <xref:System.Collections.Generic.IEnumerable%601> 인터페이스에 대해 잘 알고 있다면 여기에 `Where` 메서드가 없다는 사실을 알 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-120">If you are familiar with the generic <xref:System.Collections.Generic.IEnumerable%601> interface, you know that it does not have a `Where` method.</span></span> <span data-ttu-id="eeed5-121">그러나 Visual Studio IDE에서 IntelliSense 완성 목록을 호출하면 `Where` 메서드뿐 아니라 `Select`, `SelectMany`, `Join`, `Orderby` 등의 다른 많은 메서드도 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-121">However, if you invoke the IntelliSense completion list in the Visual Studio IDE, you will see not only a `Where` method, but many other methods such as `Select`, `SelectMany`, `Join`, and `Orderby`.</span></span> <span data-ttu-id="eeed5-122">이들은 모두 표준 쿼리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-122">These are all the standard query operators.</span></span>  
  
 <span data-ttu-id="eeed5-123">![Intellisense의 표준 쿼리 연산자](../../../../csharp/programming-guide/concepts/linq/media/standardqueryops.png "StandardQueryOps")</span><span class="sxs-lookup"><span data-stu-id="eeed5-123">![Standard Query Operators in Intellisense](../../../../csharp/programming-guide/concepts/linq/media/standardqueryops.png "StandardQueryOps")</span></span>  
  
 <span data-ttu-id="eeed5-124"><xref:System.Collections.Generic.IEnumerable%601>이 이러한 추가 메서드를 포함하도록 다시 정의된 것처럼 보이지만 실제로는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-124">Although it looks as if <xref:System.Collections.Generic.IEnumerable%601> has been redefined to include these additional methods, in fact this is not the case.</span></span> <span data-ttu-id="eeed5-125">표준 쿼리 연산자는 *확장 메서드*라는 새로운 종류의 메서드로서 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-125">The standard query operators are implemented as a new kind of method called *extension methods*.</span></span> <span data-ttu-id="eeed5-126">확장 메서드는 기존 형식을 "확장"하며, 마치 형식에 대한 인스턴스 메서드인 것처럼 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-126">Extensions methods "extend" an existing type; they can be called as if they were instance methods on the type.</span></span> <span data-ttu-id="eeed5-127">표준 쿼리 연산자는 <xref:System.Collections.Generic.IEnumerable%601>을 확장하므로 `numbers.Where(...)`를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-127">The standard query operators extend <xref:System.Collections.Generic.IEnumerable%601> and that is why you can write `numbers.Where(...)`.</span></span>  
  
 <span data-ttu-id="eeed5-128">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]를 사용하기 시작할 때 확장 메서드에 대해 알아야 할 것은, 정확한 `using` 지시문을 사용하여 이를 응용 프로그램의 범위로 가져오는 방법뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-128">To get started using [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], all that you really have to know about extension methods is how to bring them into scope in your application by using the correct `using` directives.</span></span> <span data-ttu-id="eeed5-129">응용 프로그램의 관점에서는 일반 인스턴스 메서드와 확장 메서드가 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-129">From your application's point of view, an extension method and a regular instance method are the same.</span></span>  
  
 <span data-ttu-id="eeed5-130">확장 메서드에 대한 자세한 내용은 [확장 메서드](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eeed5-130">For more information about extension methods, see [Extension Methods](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md).</span></span> <span data-ttu-id="eeed5-131">표준 쿼리 연산자에 대한 자세한 내용은 [표준 쿼리 연산자 개요(C#)](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eeed5-131">For more information about standard query operators, see [Standard Query Operators Overview (C#)](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md).</span></span> <span data-ttu-id="eeed5-132">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] 및 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 같은 일부 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 공급자는 <xref:System.Collections.Generic.IEnumerable%601> 이외의 다른 형식에 대해 자체 표준 쿼리 연산자 및 추가 확장 메서드를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-132">Some [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] providers, such as [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] and [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], implement their own standard query operators and additional extension methods for other types besides <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
## <a name="lambda-expressions"></a><span data-ttu-id="eeed5-133">람다 식</span><span class="sxs-lookup"><span data-stu-id="eeed5-133">Lambda Expressions</span></span>  
 <span data-ttu-id="eeed5-134">앞의 예제에서 조건식(`num % 2 == 0`)은 `Where` 메서드(`Where(num => num % 2 == 0).`)에 인라인 인수로 전달됩니다. 이 인라인 식을 람다 식이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-134">In the previous example, notice that the conditional expression (`num % 2 == 0`) is passed as an in-line argument to the `Where` method: `Where(num => num % 2 == 0).` This inline expression is called a lambda expression.</span></span> <span data-ttu-id="eeed5-135">이 방법을 사용하면 무명 메서드나 제네릭 대리자 또는 식 트리로서 좀 더 복잡한 형식으로 작성해야 하는 코드를 편리하게 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-135">It is a convenient way to write code that would otherwise have to be written in more cumbersome form as an anonymous method or a generic delegate or an expression tree.</span></span> <span data-ttu-id="eeed5-136">C#에서 `=>`는 "goes to"로 읽는 람다 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-136">In C# `=>` is the lambda operator, which is read as "goes to".</span></span> <span data-ttu-id="eeed5-137">연산자 왼쪽의 `num`은 쿼리 식의 `num`에 해당하는 입력 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-137">The `num` on the left of the operator is the input variable which corresponds to `num` in the query expression.</span></span> <span data-ttu-id="eeed5-138">컴파일러는 `numbers`가 제네릭 <xref:System.Collections.Generic.IEnumerable%601> 형식이라는 것을 알고 있으므로 `num`의 형식을 유추할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-138">The compiler can infer the type of `num` because it knows that `numbers` is a generic <xref:System.Collections.Generic.IEnumerable%601> type.</span></span> <span data-ttu-id="eeed5-139">람다의 본문은 쿼리 구문의 식 또는 다른 C# 식이나 문의 식과 동일하며, 메서드 호출 및 기타 복잡한 논리를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-139">The body of the lambda is just the same as the expression in query syntax or in any other C# expression or statement; it can include method calls and other complex logic.</span></span> <span data-ttu-id="eeed5-140">"반환 값"은 식 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-140">The "return value" is just the expression result.</span></span>  
  
 <span data-ttu-id="eeed5-141">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 사용을 시작하기 위해 람다를 광범위하게 사용할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-141">To get started using [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], you do not have to use lambdas extensively.</span></span> <span data-ttu-id="eeed5-142">그러나 특정 쿼리는 메서드 구문으로만 표현할 수 있으며 그중 일부는 람다 식이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-142">However, certain queries can only be expressed in method syntax and some of those require lambda expressions.</span></span> <span data-ttu-id="eeed5-143">람다에 익숙해지면 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 도구 상자에서 람다가 강력하고 유연한 도구임을 알게 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-143">After you become more familiar with lambdas, you will find that they are a powerful and flexible tool in your [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] toolbox.</span></span> <span data-ttu-id="eeed5-144">자세한 내용은 [람다 식](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eeed5-144">For more information, see [Lambda Expressions](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span></span>  
  
## <a name="composability-of-queries"></a><span data-ttu-id="eeed5-145">쿼리 작성 가능성</span><span class="sxs-lookup"><span data-stu-id="eeed5-145">Composability of Queries</span></span>  
 <span data-ttu-id="eeed5-146">이전 코드 예제에서는 `Where` 호출 시 점 연산자를 사용하여 `OrderBy` 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-146">In the previous code example, note that the `OrderBy` method is invoked by using the dot operator on the call to `Where`.</span></span> <span data-ttu-id="eeed5-147">`Where`가 필터링된 시퀀스를 생성하면 `Orderby`는 이를 정렬하여 해당 시퀀스에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-147">`Where` produces a filtered sequence, and then `Orderby` operates on that sequence by sorting it.</span></span> <span data-ttu-id="eeed5-148">쿼리는 `IEnumerable`을 반환하기 때문에, 사용자는 메서드 호출을 함께 연결하여 메서드 구문에서 쿼리를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-148">Because queries return an `IEnumerable`, you compose them in method syntax by chaining the method calls together.</span></span> <span data-ttu-id="eeed5-149">사용자가 쿼리 구문을 사용하여 쿼리를 작성할 때 백그라운드에서는 컴파일러가 이 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-149">This is what the compiler does behind the scenes when you write queries by using query syntax.</span></span> <span data-ttu-id="eeed5-150">쿼리 변수는 쿼리 결과를 저장하지 않기 때문에 언제든지 수정할 수 있으며, 실행한 후에도 언제든지 새 쿼리의 기반으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eeed5-150">And because a query variable does not store the results of the query, you can modify it or use it as the basis for a new query at any time, even after it has been executed.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="eeed5-151">참고 항목</span><span class="sxs-lookup"><span data-stu-id="eeed5-151">See Also</span></span>  
 [<span data-ttu-id="eeed5-152">C#에서 LINQ 시작</span><span class="sxs-lookup"><span data-stu-id="eeed5-152">Getting Started with LINQ in C#</span></span>](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)


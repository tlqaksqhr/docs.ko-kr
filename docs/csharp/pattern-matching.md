---
title: "패턴 일치 - C# 가이드"
description: "C#의 패턴 일치 식에 대한 자세한 정보"
keywords: .NET, .NET Core, C#
ms.date: 01/24/2017
ms.author: wiwagn
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: cf17b68514ff263b784bcb42d2015d27015328d9
ms.contentlocale: ko-kr
ms.lasthandoff: 07/28/2017

---

# <a name="pattern-matching"></a><span data-ttu-id="b9987-104">패턴 일치</span><span class="sxs-lookup"><span data-stu-id="b9987-104">Pattern Matching</span></span> #

<span data-ttu-id="b9987-105">패턴은 값에 특정 *모양*이 있는지 테스트하고 모양이 일치하는 경우 값에서 정보를 *추출*할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-105">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="b9987-106">패턴 일치는 이미 사용하고 있는 알고리즘에 대해 더 간결한 구문을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-106">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="b9987-107">이미 기존 구문을 사용하여 패턴 일치 알고리즘을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-107">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="b9987-108">값을 테스트하는 `if` 또는 `switch` 문을 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-108">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="b9987-109">그런 다음 이러한 문이 일치할 경우 해당 값에서 정보를 추출하고 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-109">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="b9987-110">새 구문 요소는 이미 친숙한 `is` 및 `switch` 문에 대한 확장입니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-110">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="b9987-111">이러한 새 확장은 값 테스트와 해당 정보 추출을 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-111">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="b9987-112">이 항목에서는 읽을 수 있고 간결한 코드를 사용하는 방법을 보여 주는 새로운 구문을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-112">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="b9987-113">패턴 일치를 통해 데이터와 데이터를 조작하는 메서드가 긴밀하게 연결된 개체 지향 디자인과 달리 데이터와 코드가 구분된 구문을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-113">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="b9987-114">이러한 새 구문을 보여 주기 위해 패턴 일치 문을 사용하여 도형을 나타내는 구조체를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-114">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="b9987-115">클래스 계층 구조를 작성하고 [가상 메서드 및 재정의된 메서드](methods.md#inherited)를 만들어 개체의 런타임 형식에 따라 개체 동작을 사용자 지정하는 작업에 대해 이미 잘 알고 있을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-115">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="b9987-116">이러한 기술은 클래스 계층 구조로 구성되지 않은 데이터에는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-116">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="b9987-117">데이터와 메서드가 분리된 경우 다른 도구가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-117">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="b9987-118">새 *패턴 일치* 구문에서는 더 명확한 구문으로 데이터를 검사하고 해당 데이터의 조건에 따라 제어 흐름을 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-118">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="b9987-119">이미 변수 값을 테스트하는 `if` 및 `switch` 문을 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-119">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="b9987-120">변수 형식을 테스트하는 `is` 문을 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-120">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="b9987-121">*패턴 일치*는 이러한 문에 새로운 기능을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-121">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="b9987-122">이 항목에서는 여러 도형의 면적을 계산하는 메서드를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-122">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="b9987-123">그러나 이 작업을 위해 개체 지향 기술을 사용하여 다양한 셰이프에 대한 클래스 계층 구조를 작성하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-123">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="b9987-124">대신 *패턴 일치*를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-124">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="b9987-125">상속을 사용하지 않음을 더 강조하기 위해 각 셰이프를 클래스가 아니라 `struct`로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-125">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="b9987-126">서로 다른 `struct` 형식이 공통 사용자 정의 기본 형식을 지정할 수 없으므로 상속은 가능한 디자인이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-126">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="b9987-127">이 샘플을 진행하면서 이 코드를 개체 계층 구조로 구성된 방식과 대조합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-127">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="b9987-128">쿼리 및 조작해야 하는 데이터가 클래스 계층 구조가 아닌 경우 패턴 일치를 통해 매우 세련된 디자인을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-128">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="b9987-129">추상 셰이프 정의로 시작하고 다른 특정 셰이프 클래스를 추가하는 대신 각 도형에 대한 간단한 데이터 전용 정의로 시작하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-129">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

<span data-ttu-id="b9987-130">[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "셰이프 정의")]</span><span class="sxs-lookup"><span data-stu-id="b9987-130">[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]</span></span>

<span data-ttu-id="b9987-131">이러한 구조체에서 일부 셰이프의 면적을 계산하는 메서드를 작성하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-131">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="b9987-132">`is` 형식 패턴 식</span><span class="sxs-lookup"><span data-stu-id="b9987-132">The `is` type pattern expression</span></span>

<span data-ttu-id="b9987-133">C# 7 이전에는 일련의 `if` 및 `is` 문에서 각 형식을 테스트해야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-133">Before C# 7, you'd need to test each type in a series of `if` and `is` statements:</span></span>

<span data-ttu-id="b9987-134">[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "is를 사용하는 클래식 형식 패턴")]</span><span class="sxs-lookup"><span data-stu-id="b9987-134">[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]</span></span>

<span data-ttu-id="b9987-135">위의 코드는 *형식 패턴*의 클래식 식입니다. 변수를 테스트하여 해당 형식을 확인하고 해당 형식에 따라 다른 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-135">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="b9987-136">`is` 식에 대한 확장을 사용하여 테스트에 성공할 경우 변수를 할당하면 이 코드가 더 간단해집니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-136">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

<span data-ttu-id="b9987-137">[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is 패턴 식")]</span><span class="sxs-lookup"><span data-stu-id="b9987-137">[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]</span></span>

<span data-ttu-id="b9987-138">이 업데이트된 버전에서 `is` 식은 변수를 테스트하고 적절한 형식의 새로운 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-138">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="b9987-139">또한 이 버전에는 `struct`인 `Rectangle` 형식이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-139">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="b9987-140">새 `is` 식은 참조 형식뿐 아니라 값 형식에서도 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-140">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="b9987-141">패턴 일치 식에 대한 언어 규칙은 일치 식의 결과를 잘못 사용하는 경우를 방지하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-141">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="b9987-142">위의 예제에서 `s`, `c` 및 `r` 변수는 범위 내에만 있고 해당 패턴 일치 식에 `true` 결과가 있는 경우 무기한 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-142">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="b9987-143">다른 위치에 있는 변수 중 하나를 사용하려는 경우 코드에서 컴파일러 오류를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-143">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="b9987-144">범위부터 시작하여 해당 규칙을 자세히 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-144">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="b9987-145">`c` 변수는 첫 번째 `if` 문의 `else` 분기에서만 범위 내에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-145">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="b9987-146">`s` 변수는 `ComputeArea` 메서드에서 범위 내에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-146">The variable `s` is in scope in the method `ComputeArea`.</span></span> <span data-ttu-id="b9987-147">이는 `if` 문의 각 분기가 변수에 대해 별도 범위를 설정하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-147">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="b9987-148">그러나 `if` 문 자체는 별도 범위를 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-148">However, the `if` statement itself does not.</span></span> <span data-ttu-id="b9987-149">즉, `if` 문에서 선언된 변수는 `if` 문(이 경우 메서드)과 동일한 범위에 있습니다. 이 동작은 패턴 일치와 관련은 없지만 변수 범위와 `if` 및 `else` 문에 대해 정의된 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-149">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="b9987-150">`c` 및 `s` 변수는 한정적으로 할당된 true 시 메커니즘 때문에 해당 `if` 문이 true일 때 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-150">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="b9987-151">이 항목의 샘플에서는 패턴 일치 `is` 식이 `if` 문의 `true` 분기에 있는 일치 변수를 한정적으로 할당하는 권장 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-151">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="b9987-152">`if (!(shape is Square s))` 및 `s` 변수가 `false` 분기에서만 한정적으로 할당된다고 지정하면 논리를 반전시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-152">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="b9987-153">이 논리는 C#에서 유효하지만 논리를 따르는 것이 더 혼동되기 때문에 따르지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-153">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="b9987-154">이러한 규칙은 해당 패턴이 충족되지 않은 경우 패턴 일치 식의 결과에 실수로 액세스할 가능성이 없음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-154">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="b9987-155">패턴 일치 `switch` 문 사용</span><span class="sxs-lookup"><span data-stu-id="b9987-155">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="b9987-156">시간이 흐르면서 다른 셰이프 형식을 지원해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-156">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="b9987-157">테스트하는 조건 수가 증가함에 따라 `is` 패턴 일치 식 사용이 불편해질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-157">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="b9987-158">확인하려는 각 형식에 대한 `if` 문이 필요할 뿐 아니라 `is` 식은 입력이 단일 형식과 일치하는지 여부의 테스트로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-158">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="b9987-159">이 경우 `switch` 패턴 일치 식을 선택하는 것이 더 나을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-159">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="b9987-160">기존의 `switch` 문은 패턴 식이었으며 상수 패턴을 지원했습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-160">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="b9987-161">`case` 문에서 사용된 상수와 변수를 비교할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-161">You could compare a variable to any constant used in a `case` statement:</span></span>

<span data-ttu-id="b9987-162">[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "클래식 switch 문")]</span><span class="sxs-lookup"><span data-stu-id="b9987-162">[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]</span></span>

<span data-ttu-id="b9987-163">`switch` 문이 지원하는 패턴은 상수 패턴뿐이었습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-163">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="b9987-164">숫자 형식과 `string` 형식으로 더욱 제한되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-164">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="b9987-165">이러한 제한 사항이 제거되었으며, 이제 형식 패턴을 사용하여 `switch` 문을 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-165">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

<span data-ttu-id="b9987-166">[!code-csharp[Switch 형식 패턴](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "'switch' 식을 사용하여 계산")]</span><span class="sxs-lookup"><span data-stu-id="b9987-166">[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]</span></span>

<span data-ttu-id="b9987-167">패턴 일치 `switch` 문은 기존의 C 스타일 `switch` 문을 사용한 개발자에게 친숙한 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-167">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="b9987-168">각 `case`가 평가되고, 입력 변수와 일치하는 조건 아래에 있는 코드가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-168">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="b9987-169">코드 실행은 case 식 간에 "이동"할 수 없습니다. `case` 문의 구문에서는 각 `case`가 `break`, `return` 또는 `goto`로 끝나야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-169">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="b9987-170">다른 레이블로 이동하는 `goto` 문은 클래식 switch 문인 상수 패턴에만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-170">The `goto` statements to jump to another label are valid only for the constant pattern, the classic switch statement.</span></span>

<span data-ttu-id="b9987-171">`switch` 문을 제어하는 중요한 새 규칙이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-171">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="b9987-172">`switch` 식의 변수 형식에 대한 제한 사항이 제거되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-172">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="b9987-173">이 예제의 `object`와 같은 모든 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-173">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="b9987-174">case 식이 더 이상 상수 값으로 제한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-174">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="b9987-175">이러한 제한이 제거되면서 `switch` 섹션을 다시 정렬할 경우 프로그램의 동작이 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-175">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="b9987-176">상수 값으로 제한될 경우 최대 한 개의 `case` 레이블만 `switch` 식과 일치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-176">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="b9987-177">모든 `switch` 섹션이 다음 섹션으로 이동해서는 안 되는 규칙과 결합되어 동작에 영향을 주지 않고 `switch` 섹션을 임의 순서로 다시 정렬할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-177">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="b9987-178">이제 보다 일반화된 `switch` 식을 사용하므로 각 섹션의 순서가 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-178">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="b9987-179">`switch` 식은 텍스트 순서로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-179">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="b9987-180">`switch` 식과 일치하는 첫 번째 `switch` 레이블로 실행이 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-180">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="b9987-181">`default` 사례는 일치하는 다른 사례 레이블이 없는 경우에만 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-181">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="b9987-182">`default` 사례는 텍스트 순서에 관계없이 마지막으로 평가됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-182">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="b9987-183">`default` 사례가 없고 일치하는 다른 `case` 문이 없는 경우 `switch` 문 뒤의 문에서 실행이 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-183">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="b9987-184">`case` 레이블 코드는 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-184">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="b9987-185">`case` 식의 `when` 절</span><span class="sxs-lookup"><span data-stu-id="b9987-185">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="b9987-186">`case` 레이블에 `when` 절을 사용하여 면적이 0인 해당 셰이프에 대한 특수 사례를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-186">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="b9987-187">측면 길이가 0인 사각형 또는 반지름이 0인 원은 면적이 0입니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-187">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="b9987-188">`case` 레이블에 `when` 절을 사용하여 해당 조건을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-188">You specify that condition using a `when` clause on the `case` label:</span></span>  

<span data-ttu-id="b9987-189">[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "면적이 0인 셰이프 계산")]</span><span class="sxs-lookup"><span data-stu-id="b9987-189">[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]</span></span>

<span data-ttu-id="b9987-190">이 변경 내용은 새 구문에 대한 몇 가지 중요한 사항을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-190">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="b9987-191">첫째, 여러 `case` 레이블을 하나의 `switch` 섹션에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-191">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="b9987-192">문 블록은 이러한 레이블이 `true`인 경우에 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-192">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="b9987-193">이 인스턴스에서 `switch` 식이 면적이 0인 원 또는 사각형인 경우 메서드가 상수 0을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-193">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="b9987-194">이 예제에서는 첫 번째 `switch` 블록에 대한 두 개의 `case` 레이블에 있는 두 개의 변수를 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-194">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="b9987-195">이 `switch` 블록의 문은 `c`(원) 또는 `s`(사각형) 변수를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-195">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="b9987-196">이러한 변수는 이 `switch` 블록에서 한정적으로 할당되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-196">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="b9987-197">이 사례 중 하나가 일치하면 변수 중 하나가 명확하게 할당된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-197">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="b9987-198">그러나 사례 중 하나가 런타임 시 일치할 수 있기 때문에 컴파일 시간에 *어떤* 사례가 할당되었는지 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-198">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="b9987-199">이런 이유로 동일한 블록에 여러 `case` 레이블을 사용하는 경우 대부분 `case` 문에서 새 변수를 도입하지 않거나 `when` 절에서만 변수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-199">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="b9987-200">면적이 0인 셰이프를 추가한 경우 사각형과 삼각형인 셰이프 유형 두 개를 더 추가하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-200">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

<span data-ttu-id="b9987-201">[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "사각형 및 삼각형 추가")]</span><span class="sxs-lookup"><span data-stu-id="b9987-201">[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]</span></span>

 <span data-ttu-id="b9987-202">이 변경 내용 집합은 degenerate 사례에 대한 `case` 레이블과 새로운 각 셰이프에 대한 레이블 및 블록을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-202">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="b9987-203">마지막으로, `null` 사례를 추가하여 인수가 `null`이 아닌지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-203">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

<span data-ttu-id="b9987-204">[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "null 사례 추가")]</span><span class="sxs-lookup"><span data-stu-id="b9987-204">[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]</span></span>

<span data-ttu-id="b9987-205">`null` 패턴의 특수 동작은 패턴에서 형식이 없는 `null` 상수를 모든 참조 형식 또는 nullable 형식으로 변환할 수 있기 때문에 흥미롭습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-205">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="b9987-206">`null`을 임의 형식으로 변환하는 대신, 언어에서 `null` 값은 변수의 컴파일 시간 형식과 관계없이 어떠한 형식 패턴과도 일치하지 않는다고 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-206">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="b9987-207">이 동작을 통해 새 `switch` 기반 형식 패턴이 `is` 문과 일치하게 됩니다. `is` 문은 확인되는 값이 `null`일 경우 항상 `false`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-207">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="b9987-208">더 간단하기도 합니다. 형식을 확인한 후에는 추가 null 검사가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-208">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="b9987-209">위 샘플의 case 블록에 null 검사가 없다는 사실에서 이를 확인할 수 있습니다. 형식 패턴 일치를 통해 null이 아닌 값이 보장되므로 null 검사가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-209">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="conclusions"></a><span data-ttu-id="b9987-210">결론</span><span class="sxs-lookup"><span data-stu-id="b9987-210">Conclusions</span></span>

<span data-ttu-id="b9987-211">*패턴 일치 구문*을 사용하면 상속 계층 구조와 관련이 없는 다양한 변수 및 형식 간의 제어 흐름을 쉽게 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-211">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="b9987-212">논리를 제어하여 변수에 테스트하는 조건을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-212">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="b9987-213">데이터 및 해당 데이터를 조작하는 메서드가 별개인 더욱 분산된 응용 프로그램을 빌드하는 경우 더 자주 필요한 패턴과 구문을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-213">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="b9987-214">이 샘플에 사용된 셰이프 구조체에는 메서드가 없고 읽기 전용 속성만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-214">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="b9987-215">패턴 일치는 모든 데이터 형식에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-215">Pattern Matching works with any data type.</span></span> <span data-ttu-id="b9987-216">개체를 검사하는 식을 작성하고 해당 조건에 따라 제어 흐름 결정을 내립니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-216">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="b9987-217">추상 `Shape` 및 각각 고유한 가상 메서드 구현으로 면적을 계산하는 특정 파생 셰이프에 대한 클래스 계층 구조를 만들어 수행하는 디자인과 이 샘플의 코드를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-217">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="b9987-218">데이터로 작업하고 데이터 저장소 문제와 동작 문제를 구분하려는 경우 패턴 일치 식은 매우 유용한 도구일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9987-218">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>



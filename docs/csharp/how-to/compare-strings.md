---
title: '방법: 문자열 비교 - C# 가이드'
description: 문화권별 순서 지정 여부나 대/소문자와 상관없이 문자열 값을 비교하고 정렬하는 방법에 대해 알아봅니다.
ms.date: 03/20/2018
ms.prod: .net
ms.technology:
- devlang-csharp
ms.topic: article
helpviewer_keywords:
- strings [C#], comparison
- comparing strings [C#]
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 3edc1ffdcb4d084f8f76ff27144402fbf98fcbdb
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/28/2018
---
# <a name="how-to-compare-strings-in-c"></a><span data-ttu-id="c110f-103">C#에서 문자열을 비교하는 방법</span><span class="sxs-lookup"><span data-stu-id="c110f-103">How to compare strings in C#</span></span> #

<span data-ttu-id="c110f-104">문자열을 비교하여 두 가지 질문 중 하나를 해결할 수 있습니다. "두 문자열이 같은가?"</span><span class="sxs-lookup"><span data-stu-id="c110f-104">You compare strings to answer one of two questions: "Are these two strings equal?"</span></span> <span data-ttu-id="c110f-105">또는 "정렬할 때 이 문자열을 어떤 순서로 정렬해야 하는가?"</span><span class="sxs-lookup"><span data-stu-id="c110f-105">or "In what order should these strings be placed when sorting them?"</span></span>

<span data-ttu-id="c110f-106">이러한 두 가지 질문은 문자열 비교에 영향을 주는 요소에 의해 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-106">Those two questions are complicated by factors that affect string comparisons:</span></span> 
- <span data-ttu-id="c110f-107">서수 또는 언어 비교를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-107">You can choose an ordinal or linguistic comparison.</span></span>
- <span data-ttu-id="c110f-108">대/소문자를 구분할지 여부를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-108">You can choose if case matters.</span></span>
- <span data-ttu-id="c110f-109">문화권별 비교를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-109">You can choose culture specific comparisons.</span></span>
- <span data-ttu-id="c110f-110">언어적 비교는 문화권 및 플랫폼에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-110">Linguistic comparisions are culture and platform dependent.</span></span>

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

<span data-ttu-id="c110f-111">문자열을 비교할 때 순서를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-111">When you compare strings, you define an order among them.</span></span> <span data-ttu-id="c110f-112">비교는 문자열 시퀀스를 정렬하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-112">Comparisons are used to sort a sequence of strings.</span></span> <span data-ttu-id="c110f-113">시퀀스가 알려진 순서대로 되면 소프트웨어와 사람 모두를 검색하는 것이 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-113">Once the sequence is in a known order, it is easier to search, both for software and for humans.</span></span> <span data-ttu-id="c110f-114">다른 비교로 문자열이 같은지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-114">Other comparisons may check if strings are the same.</span></span> <span data-ttu-id="c110f-115">이러한 동일성 검사는 동등 여부와 유사하지만 대/소문자 차이 같은 일부 차이점은 무시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-115">These sameness checks are similar to equality, but some differences, such as case differences, may be ignored.</span></span>

## <a name="default-ordinal-comparisons"></a><span data-ttu-id="c110f-116">기본 서수 비교</span><span class="sxs-lookup"><span data-stu-id="c110f-116">Default ordinal comparisons</span></span>

<span data-ttu-id="c110f-117">가장 일반적인 작업인 <xref:System.String.CompareTo%2A?displayProperty=nameWithType>과 <xref:System.String.Equals%2A?displayProperty=nameWithType> 또는 <xref:System.String.op_Equality%2A?displayProperty=nameWithType>은 서수 비교, 대/소문자 구분 비교를 사용하고 현재 문화권을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-117">The most common operations, <xref:System.String.CompareTo%2A?displayProperty=nameWithType> and <xref:System.String.Equals%2A?displayProperty=nameWithType> or <xref:System.String.op_Equality%2A?displayProperty=nameWithType> use an ordinal comparison, a case-sensitive comparison, and use the current culture.</span></span> <span data-ttu-id="c110f-118">이 결과는 다음 예제에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-118">The results are shown in the following example.</span></span>

[!code-csharp-interactive[Comparing strings using an ordinal comparison](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#1)]

<span data-ttu-id="c110f-119">서수 비교는 문자열을 비교할 때 언어 규칙을 고려하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-119">Ordinal comparisons do not take linguistic rules into account when comparing strings.</span></span> <span data-ttu-id="c110f-120">문자별로 문자열을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-120">They will compare the strings character by character.</span></span> <span data-ttu-id="c110f-121">대/소문자 구분 비교에서는 비교 시 대/소문자를 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-121">Case-sensitive comparisons use capitalization in their comparisons.</span></span> <span data-ttu-id="c110f-122">이러한 기본 비교 방법에 대한 가장 중요한 점은 현재 문화권을 사용하기 때문에 결과가 실행되는 컴퓨터의 로캘 및 언어 설정에 따라 달라진다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-122">The most important point about these default comparison methods is that because they use the current culture, the results depend on the locale and language settings of the machine where they run.</span></span> <span data-ttu-id="c110f-123">이러한 비교는 컴퓨터 또는 위치에서 순서가 일관적이어야 하는 비교에는 적합하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-123">These comparisons are unsuitable for comparisons where order should be consistent across machines or locations.</span></span>

## <a name="case-insensitive-ordinal-comparisons"></a><span data-ttu-id="c110f-124">대/소문자를 구분하지 않는 서수 비교</span><span class="sxs-lookup"><span data-stu-id="c110f-124">Case-insensitive ordinal comparisons</span></span>

<span data-ttu-id="c110f-125"><xref:System.String.Equals%2A?displayProperty=nameWithType> 메서드를 사용하면 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>의 <xref:System.StringComparison> 값을 지정하여 대/소문자 구분 비교를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-125">The <xref:System.String.Equals%2A?displayProperty=nameWithType> method enables you to specify a <xref:System.StringComparison> value of <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> to specify a case-insensitive comparison.</span></span> <span data-ttu-id="c110f-126">또한 대/소문자를 구분하지 않는 비교를 지정하는 부울 인수를 포함하는 정적 <xref:System.String.Compare%2A> 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-126">There is also a static <xref:System.String.Compare%2A> method that includes a boolean argument to specify case-insensitive comparisons.</span></span> <span data-ttu-id="c110f-127">이는 다음 코드에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-127">These are shown in the following code:</span></span>

[!code-csharp-interactive[Comparing strings ignoring case](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#2)]

## <a name="linguistic-comparisons"></a><span data-ttu-id="c110f-128">언어 비교</span><span class="sxs-lookup"><span data-stu-id="c110f-128">Linguistic comparisons</span></span>

<span data-ttu-id="c110f-129">또한 현재 문화권에 대한 언어 규칙을 사용하여 문자열을 정렬할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-129">Strings can also be ordered using linguistic rules for the current culture.</span></span>
<span data-ttu-id="c110f-130">이를 종종 "단어 정렬 순서"라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-130">This is sometimes referred to as "word sort order."</span></span> <span data-ttu-id="c110f-131">언어 비교를 수행할 때 일부 영숫자가 아닌 유니코드 문자에 특별한 가중치가 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-131">When you perform a linguistic comparision, some nonalphanumeric Unicode characters might have special weights assigned.</span></span> <span data-ttu-id="c110f-132">예를 들어, 하이픈 "-"는 매우 작은 가중치가 할당될 수 있으므로 "co-op" 및 "coop"는 정렬 순서에 나란히 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-132">For example, the hyphen "-" may have a very small weight assigned to it so that "co-op" and "coop" appear next to each other in sort order.</span></span> <span data-ttu-id="c110f-133">또한 일부 유니코드 문자는 영숫자 문자의 시컨스와 동일할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-133">In addition, some Unicode characters may be equivalent to a sequence of alphanumeric characterss.</span></span> <span data-ttu-id="c110f-134">다음 예에서는 "ss" 및 'ß'를 사용하여 독일어로</span><span class="sxs-lookup"><span data-stu-id="c110f-134">The following example uses the phrase "They dance in the street."</span></span> <span data-ttu-id="c110f-135">"거리에서 춤을 추다"라는 문구를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-135">in German with the "ss" and 'ß'.</span></span> <span data-ttu-id="c110f-136">언어적으로(Windows의 경우) "ss"는 "en-US" 및 "de-DE" 문화권의 독일어 Essetz: 'ß' 문자와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-136">Linguistically (in Windows), "ss" is equal to the German Essetz: 'ß' character in both "en-US" and "de-DE" cultures.</span></span> 

[!code-csharp-interactive[Comparing strings using linguistic rules](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#3)]

<span data-ttu-id="c110f-137">이 샘플에서는 운영 체제별 언어 비교 특성을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-137">This sample demonstrates the operating system dependent nature of linguistic comparisons.</span></span> <span data-ttu-id="c110f-138">대화형 창 호스트는 Linux 호스트입니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-138">The host for the interactive window is a Linux host.</span></span> <span data-ttu-id="c110f-139">언어 및 서수 비교는 동일한 결과를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-139">The linguistic and ordinal comparisons produce the same results.</span></span> <span data-ttu-id="c110f-140">이 샘플을 Windows 호스트에서 실행한 경우 다음과 같은 출력을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-140">If you ran this same sample on a Windows host, you would see the following output:</span></span>

```console
<coop> is less than <co-op> using invariant culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using invariant culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using invariant culture
<co-op> is less than <cop> using ordinal comparison
```

<span data-ttu-id="c110f-141">Windows에서 언어 비교를 서수 비교로 변경하면 "cop", "coop" 및 "co-op"의 정렬 순서가 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-141">On Windows, the sort order of "cop", "coop", and "co-op" change when you change from a linguistic comparison to an ordinal comparison.</span></span> <span data-ttu-id="c110f-142">두 개의 독일어 문장도 서로 다른 비교 형식을 사용하여 다르게 비교됩니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-142">The two German sentences also compare differently using the different comparison types.</span></span>

## <a name="comparisons-using-specific-cultures"></a><span data-ttu-id="c110f-143">특정 문화권을 사용한 비교</span><span class="sxs-lookup"><span data-stu-id="c110f-143">Comparisons using specific cultures</span></span>

<span data-ttu-id="c110f-144">이 샘플은 현재 문화권에 대한 <xref:System.Globalization.CultureInfo>를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-144">This sample stores <xref:System.Globalization.CultureInfo> for the current culture.</span></span>
<span data-ttu-id="c110f-145">원래 문화권은 현재 스레드 개체에서 설정하거나 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-145">The original culture can be set and retrieved on the current thread object.</span></span> <span data-ttu-id="c110f-146">비교는 문화권별 비교를 보장하기 위해 <xref:System.StringComparison.CurrentCulture> 값을 사용하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-146">The comparisons are performed using the <xref:System.StringComparison.CurrentCulture> value to ensure a culture-specific comparison.</span></span>

<span data-ttu-id="c110f-147">사용된 문화권은 언어 비교에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-147">The culture used affects linguistic comparisons.</span></span> <span data-ttu-id="c110f-148">다음 예에서는 "en-US" 문화권과 "de-DE" 문화권을 사용하여 두 개의 독일어 문장을 비교한 결과를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-148">The following example shows the results of comparing the two German sentences using the "en-US" culture and the "de-DE" culture:</span></span>

[!code-csharp-interactive[Comparing strings across cultures](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#4)]

<span data-ttu-id="c110f-149">문화권별 비교는 일반적으로 사용자가 입력한 문자열을 사용자가 입력한 다른 문자열과 비교하여 정렬하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-149">Culture-sensitive comparisons are typically used to compare and sort strings input by users with other strings input by users.</span></span> <span data-ttu-id="c110f-150">이러한 문자열의 문자 및 정렬 규칙은 사용자 컴퓨터의 로캘에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-150">The characters and sorting conventions of these strings might vary depending on the locale of the user's computer.</span></span> <span data-ttu-id="c110f-151">똑같은 문자가 포함된 문자열이라도 현재 스레드의 문화권에 따라 다르게 정렬될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-151">Even strings that contain identical characters might sort differently depending on the culture of the current thread.</span></span> <span data-ttu-id="c110f-152">또한 이 샘플 코드를 Windows 컴퓨터에서 로컬로 시도하면 다음과 같은 결과가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-152">In addition, try this sample code locally on a Windows machine, and you will the following results:</span></span>

```console
<coop> is less than <co-op> using en-US culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using en-US culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using en-US culture
<co-op> is less than <cop> using ordinal comparison
```

<span data-ttu-id="c110f-153">언어 비교는 현재 문화권에 따라 달라지며 OS에 종속됩니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-153">Linguistic comparisions are dependent on the current culture, and are OS dependent.</span></span> <span data-ttu-id="c110f-154">문자열 비교 작업을 할 때 이 점을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-154">You must take that into account when you work with string comparisons.</span></span>

## <a name="linguistic-sorting-and-searching-strings-in-arrays"></a><span data-ttu-id="c110f-155">배열의 언어적 정렬 및 문자열 검색</span><span class="sxs-lookup"><span data-stu-id="c110f-155">Linguistic sorting and searching strings in arrays</span></span>

<span data-ttu-id="c110f-156">다음 예에서는 현재 문화권에 따라 언어 비교를 사용하여 배열에서 문자열을 정렬하고 검색하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-156">The following examples show how to sort and search for strings in an array using a linguistic comparison dependent on the current culture.</span></span> <span data-ttu-id="c110f-157"><xref:System.StringComparer?displayProperty=nameWithType> 매개 변수를 사용하는 정적 <xref:System.Array> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-157">You use the static <xref:System.Array> methods that take a <xref:System.StringComparer?displayProperty=nameWithType> parameter.</span></span>

<span data-ttu-id="c110f-158">이 예에서는 현재 문화권을 사용하여 문자열 배열을 정렬하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-158">This example shows how to sort an array of strings using the current culture:</span></span> 

[!code-csharp-interactive[Sorting an array of strings](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#5)]

<span data-ttu-id="c110f-159">배열이 정렬되면 이진 검색을 사용하여 항목을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-159">Once the array is sorted, you can search for entries using a binary search.</span></span> <span data-ttu-id="c110f-160">이진 검색은 컬렉션의 중간에서 시작하여 컬렉션의 절반에서 검색 문자열이 포함되어 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-160">A binary search starts in the middle of the collection to determine which half of the collection would contain the sought string.</span></span> <span data-ttu-id="c110f-161">이후의 각 비교는 컬렉션의 나머지 부분을 절반으로 세분합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-161">Each subsequent comparison subdivides the remaining part of the collection in half.</span></span>  <span data-ttu-id="c110f-162">배열은 <xref:System.StringComparer.CurrentCulture?displayProperty=nameWithType>을 사용하여 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-162">The array is sorted using <xref:System.StringComparer.CurrentCulture?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c110f-163">로컬 함수 `ShowWhere`는 문자열이 발견된 위치에 대한 정보를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-163">The local function `ShowWhere` displays information about where the string was found.</span></span> <span data-ttu-id="c110f-164">문자열을 찾을 수 없는 경우 반환된 값은 발견된 그 위치를 나타냅니다. </span><span class="sxs-lookup"><span data-stu-id="c110f-164">If the string was not found, the returned value indicates where it would be if it were found.</span></span>

[!code-csharp-interactive[Searching in a sorted array](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#6)]

## <a name="ordinal-sorting-and-searching-in-collections"></a><span data-ttu-id="c110f-165">컬렉션의 서수 정렬 및 검색</span><span class="sxs-lookup"><span data-stu-id="c110f-165">Ordinal sorting and searching in collections</span></span>

<span data-ttu-id="c110f-166">다음 코드에서는 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 컬렉션 클래스를 사용하여 문자열을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-166">The following code uses the <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> collection class to store strings.</span></span> <span data-ttu-id="c110f-167">문자열은 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> 메서드를 사용하여 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-167">The strings are sorted using the <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c110f-168">이 메서드에는 두 문자열을 비교하고 정렬하는 대리자가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-168">This method needs a delegate that compares and orders two strings.</span></span> <span data-ttu-id="c110f-169"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> 메서드는 비교 함수를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-169">The <xref:System.String.CompareTo%2A?displayProperty=nameWithType> method provides that comparison function.</span></span> <span data-ttu-id="c110f-170">이 샘플을 실행하고 순서를 관찰합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-170">Run the sample and observe the order.</span></span> <span data-ttu-id="c110f-171">이 정렬 작업은 서수 대/소문자 구분 정렬을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-171">This sort operation uses an ordinal case sensitive sort.</span></span> <span data-ttu-id="c110f-172">정적 <xref:System.String.Compare%2A?displayProperty=nameWithType> 메서드를 사용하여 여러 비교 규칙을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-172">You would use the static <xref:System.String.Compare%2A?displayProperty=nameWithType> methods to specify different comparison rules.</span></span>

[!code-csharp-interactive[Sorting a list of strings](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#7)]

<span data-ttu-id="c110f-173">정렬된 후에는 이진 검색을 사용하여 문자열 목록을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-173">Once sorted, the list of strings can be searched using a binary search.</span></span> <span data-ttu-id="c110f-174">다음 샘플에서는 동일한 비교 함수를 사용하여 정렬된 목록을 검색하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-174">The following sample shows how to search the sorted listed using the same comparison function.</span></span> <span data-ttu-id="c110f-175">로컬 함수 `ShowWhere`는 검색된 텍스트가 어디에 있는지를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-175">The local function `ShowWhere` shows where the sought text is or would be:</span></span>

[!code-csharp-interactive[csProgGuideStrings#11](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#8)]

<span data-ttu-id="c110f-176">정렬 및 검색 시 항상 동일한 형식의 비교를 사용하도록 하세요.</span><span class="sxs-lookup"><span data-stu-id="c110f-176">Always make sure to use the same type of comparison for sorting and searching.</span></span> <span data-ttu-id="c110f-177">정렬 및 검색에 대해 서로 다른 비교 형식을 사용하면 예기치 않은 결과가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-177">Using different comparison types for sorting and searching produces unexpected results.</span></span> 

<span data-ttu-id="c110f-178"><xref:System.Collections.Hashtable?displayProperty=nameWithType>, <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType>, <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 등의 컬렉션 클래스는 요소 또는 키의 형식이 `string`인 경우 <xref:System.StringComparer?displayProperty=nameWithType> 매개 변수를 사용하는 생성자를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-178">Collection classes such as <xref:System.Collections.Hashtable?displayProperty=nameWithType>, <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType>, and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> have constructors that take a <xref:System.StringComparer?displayProperty=nameWithType> parameter when the type of the elements or keys is `string`.</span></span> <span data-ttu-id="c110f-179">일반적으로 가능하면 이러한 생성자를 사용하고 <xref:System.StringComparer.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparer.OrdinalIgnoreCase?displayProperty=nameWithType>를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-179">In general, you should use these constructors whenever possible, and specify either <xref:System.StringComparer.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

## <a name="reference-equality-and-string-interning"></a><span data-ttu-id="c110f-180">참조 동일성과 문자열 인터닝</span><span class="sxs-lookup"><span data-stu-id="c110f-180">Reference equality and string interning</span></span>

<span data-ttu-id="c110f-181">샘플 중에 <xref:System.Object.ReferenceEquals%2A>를 사용한 것은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-181">None of the samples have used <xref:System.Object.ReferenceEquals%2A>.</span></span> <span data-ttu-id="c110f-182">이 메서드는 두 문자열이 동일한 개체인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-182">This method determines if two strings are the same object.</span></span> <span data-ttu-id="c110f-183">이로 인해 문자열 비교 시 일관성 없는 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-183">This can lead to inconsistent results in string comparisons.</span></span> <span data-ttu-id="c110f-184">다음 예에서는 C#의 *문자열 인터닝* 기능을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-184">The following example demonstrates the *string interning* feature of C#.</span></span> <span data-ttu-id="c110f-185">프로그램이 두 개 이상의 동일 문자열 변수를 선언할 경우 컴파일러는 변수를 모두 같은 위치에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-185">When a program declares two or more identical string variables, the compiler stores them all in the same location.</span></span> <span data-ttu-id="c110f-186"><xref:System.Object.ReferenceEquals%2A> 메서드를 호출하여 두 문자열이 실제로 메모리에서 같은 개체를 참조하는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-186">By calling the <xref:System.Object.ReferenceEquals%2A> method, you can see that the two strings actually refer to the same object in memory.</span></span> <span data-ttu-id="c110f-187">인터닝을 방지하려면 <xref:System.String.Copy%2A?displayProperty=nameWithType> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-187">Use the <xref:System.String.Copy%2A?displayProperty=nameWithType> method to avoid interning.</span></span> <span data-ttu-id="c110f-188">복사본이 생성된 후 두 개의 문자열은 동일한 값을 가지더라도 다른 위치에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-188">After the copy has been made, the two strings have different storage locations, even though they have the same value.</span></span> <span data-ttu-id="c110f-189">`a`와 `b`가 *인터닝*되었음을, 즉 동일한 저장소를 공유한다는 것을 보여주는 다음 샘플을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-189">Run the following sample to show that strings `a` and `b` are *interned* meaning they share the same storage.</span></span> <span data-ttu-id="c110f-190">문자열 `a`와 `c`는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-190">The strings `a` and `c` are not.</span></span>

[!code-csharp-interactive[Demonstrating string interning](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#9)]

> [!NOTE]
> <span data-ttu-id="c110f-191">문자열의 동일성을 테스트할 때, 어떤 유형의 비교를 수행할지 명시적으로 지정하는 메서드를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-191">When you test for equality of strings, you should use the methods that explicitly specify what kind of comparison you intend to perform.</span></span> <span data-ttu-id="c110f-192">코드를 훨씬 더 쉽게 유지 관리하고 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-192">Your code is much more maintainable and readable.</span></span> <span data-ttu-id="c110f-193"><xref:System.StringComparison> 열거형 매개 변수를 사용하는 <xref:System.String?displayProperty=nameWithType> 및 <xref:System.Array?displayProperty=nameWithType> 클래스의 메서드 오버로드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-193">Use the overloads of the methods of the <xref:System.String?displayProperty=nameWithType> and <xref:System.Array?displayProperty=nameWithType> classes that take a <xref:System.StringComparison> enumeration parameter.</span></span> <span data-ttu-id="c110f-194">수행할 비교 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-194">You specify which type of comparison to perform.</span></span> <span data-ttu-id="c110f-195">동일성을 테스트할 때 `==` 및 `!=` 연산자를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-195">Avoid using the `==` and `!=` operators when you test for equality.</span></span> <span data-ttu-id="c110f-196"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> 인스턴스 메서드는 항상 서수 대/소문자 구분 비교를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-196">The <xref:System.String.CompareTo%2A?displayProperty=nameWithType> instance methods always perform an ordinal case-sensitive comparison.</span></span> <span data-ttu-id="c110f-197">주로 알파벳순으로 문자열을 정렬하는 데 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="c110f-197">They are primarily suited for ordering strings alphabetically.</span></span>

## <a name="see-also"></a><span data-ttu-id="c110f-198">참고 항목</span><span class="sxs-lookup"><span data-stu-id="c110f-198">See also</span></span>
 <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>  
 <xref:System.StringComparer?displayProperty=nameWithType>  
 [<span data-ttu-id="c110f-199">문자열</span><span class="sxs-lookup"><span data-stu-id="c110f-199">Strings</span></span>](../programming-guide/strings/index.md)  
 [<span data-ttu-id="c110f-200">문자열 비교</span><span class="sxs-lookup"><span data-stu-id="c110f-200">Comparing Strings</span></span>](../../standard/base-types/comparing.md)  
 [<span data-ttu-id="c110f-201">응용 프로그램 전역화 및 지역화</span><span class="sxs-lookup"><span data-stu-id="c110f-201">Globalizing and Localizing Applications</span></span>](/visualstudio/ide/globalizing-and-localizing-applications)
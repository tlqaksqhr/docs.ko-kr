---
title: 구문 변환 시작(Roslyn API)
description: 구문 트리를 트래버스하고, 탐색하고, 쿼리하는 방법을 소개합니다.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: 04053645b91e8f74e890340fb9bba66a4efdce0c
ms.sourcegitcommit: 2ad7d06f4f469b5d8a5280ac0e0289a81867fc8e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/08/2018
ms.locfileid: "35231619"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="b1d8b-103">구문 변환 시작</span><span class="sxs-lookup"><span data-stu-id="b1d8b-103">Get started with syntax transformation</span></span>

<span data-ttu-id="b1d8b-104">이 자습서는 [구문 분석 시작](syntax-analysis.md) 및 [의미 체계 분석 시작](semantic-analysis.md) 빠른 시작에서 살펴본 개념과 기술을 기반으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="b1d8b-105">아직 완료하지 않은 경우 이 자습서를 시작하기 전에 해당 빠른 시작을 완료해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="b1d8b-106">이 빠른 시작에서는 구문 트리를 만들고 변환하는 기술을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="b1d8b-107">이전 빠른 시작에서 알아본 기술을 함께 사용하여 첫 번째 명령줄 리팩터링을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="b1d8b-108">불변성 및 .NET 컴파일러 플랫폼</span><span class="sxs-lookup"><span data-stu-id="b1d8b-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="b1d8b-109">**불변성**은 .NET 컴파일러 플랫폼의 기본 원리입니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="b1d8b-110">변경 불가능한 데이터 구조는 생성된 후 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="b1d8b-111">변경 불가능한 데이터 구조는 여러 소비자가 동시에 안전하게 공유하고 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="b1d8b-112">한 소비자가 예기치 않은 방식으로 다른 소비자에게 영향을 줄 위험이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="b1d8b-113">분석기에는 잠금이나 기타 동시성 측정값이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="b1d8b-114">이 규칙은 구문 트리, 컴파일, 기호, 의미 체계 모델 및 사용자에게 나타나는 모든 기타 데이터 구조에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="b1d8b-115">기존 구조를 수정하는 대신 API는 지정된 차이점을 기반으로 새 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="b1d8b-116">이 개념을 구문 트리에 적용하여 변환을 통해 새 트리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="b1d8b-117">트리 만들기 및 변환</span><span class="sxs-lookup"><span data-stu-id="b1d8b-117">Create and transform trees</span></span>

<span data-ttu-id="b1d8b-118">구문 변환에 대해 두 가지 전략 중 하나를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="b1d8b-119">**팩터리 메서드**는 대체할 특정 노드를 검색하거나 새 코드를 삽입할 특정 위치를 검색할 때 가장 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="b1d8b-120">**재작성기**는 대체할 코드 패턴을 전체 프로젝트에서 검색하려는 경우 가장 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="b1d8b-121">팩터리 메서드를 사용하여 노드 만들기</span><span class="sxs-lookup"><span data-stu-id="b1d8b-121">Create nodes with factory methods</span></span>

<span data-ttu-id="b1d8b-122">첫 번째 구문 변환은 팩터리 메서드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="b1d8b-123">`using System.Collections;` 문을 `using System.Collections.Generic;` 문으로 바꾸려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="b1d8b-124">이 예제는 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> 팩터리 메서드를 사용하여 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> 개체를 만드는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="b1d8b-125">각 종류의 **노드**, **토큰** 또는 **기타 정보**에 대해 해당 형식의 인스턴스를 만드는 팩터리 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="b1d8b-126">노드를 상향식 계층 구조로 작성하여 구문 트리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="b1d8b-127">그런 다음, 기존 노드를 직접 만든 새 트리로 바꿔서 기존 프로그램을 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="b1d8b-128">Visual Studio를 시작하고 새 C# **독립 실행형 코드 분석 도구** 프로젝트를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="b1d8b-129">Visual Studio에서 **파일** > \**새로 만들기* > **프로젝트**를 선택하여 [새 프로젝트] 대화 상자를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-129">In Visual Studio, choose **File** > \**New* > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="b1d8b-130">**Visual C#** > **확장성** 아래에서 **독립 실행형 코드 분석 도구**를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="b1d8b-131">이 빠른 시작에는 두 개의 예제 프로젝트가 있으므로 솔루션 이름을 **SyntaxTransformationQuickStart**로 지정하고 프로젝트 이름을 **ConstructionCS**로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="b1d8b-132">**확인**을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-132">Click **OK**.</span></span>

<span data-ttu-id="b1d8b-133">이 프로젝트는 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> 클래스 메서드를 사용하여 `System.Collections.Generic` 네임스페이스를 나타내는 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="b1d8b-134">다음 using 지시문을 `Program.cs` 파일의 맨 위에 추가하여 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> 클래스의 팩터리 메서드와 <xref:System.Console>의 메서드를 가져오면 나중에 이러한 항목을 정규화하지 않고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-134">Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="b1d8b-135">**name syntax nodes**를 만들어 `using System.Collections.Generic;` 문을 나타내는 트리를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="b1d8b-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>는 C#에 나타나는 네 가지 형식의 이름에 대한 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="b1d8b-137">다음 네 가지 형식의 이름을 함께 작성하여 C# 언어로 표시할 수 있는 이름을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="b1d8b-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> - `System` 및 `Microsoft` 같은 단순 단일 식별자 이름을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="b1d8b-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType> - `List<int>` 같은 제네릭 형식 또는 메서드 이름을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="b1d8b-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType> - `System.IO` 같은 폼 `<left-name>.<right-identifier-or-generic-name>`의 정규화된 이름을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="b1d8b-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType> - `LibraryV2::Foo` 같은 어셈블리 extern 별칭을 사용하는 이름을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="b1d8b-142"><xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> 메서드를 사용하여 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> 노드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="b1d8b-143">`Program.cs`에서 `Main` 메서드에 다음 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="b1d8b-144">앞의 코드는 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> 개체를 만들고 이를 `name` 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="b1d8b-145">대부분 Roslyn API는 기본 클래스를 반환하므로 관련 형식을 더 쉽게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="b1d8b-146"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>를 빌드할 때 `name` 변수인 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>를 재사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="b1d8b-147">샘플을 빌드할 때 형식 유추를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="b1d8b-148">이 프로젝트에서 해당 단계를 자동화합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="b1d8b-149">이름을 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-149">You've created the name.</span></span> <span data-ttu-id="b1d8b-150">이제 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>를 빌드하여 더 많은 노드를 트리로 빌드해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="b1d8b-151">새 트리는 `name`을 이름의 왼쪽으로 사용하고 `Collections` 네임스페이스의 새 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax>를 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>의 오른쪽으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="b1d8b-152">다음 코드를 `program.cs`에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="b1d8b-153">코드를 다시 실행하고 결과를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-153">Run the code again, and see the results.</span></span> <span data-ttu-id="b1d8b-154">코드를 나타내는 노드 트리를 빌드하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="b1d8b-155">이 패턴을 계속해서 네임스페이스 `System.Collections.Generic`에 대한 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="b1d8b-156">다음 코드를 `Program.cs`에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="b1d8b-157">프로그램을 다시 실행하여 추가할 코드에 대한 트리를 빌드했는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-157">Run the program again to see that you've build the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="b1d8b-158">수정된 트리 만들기</span><span class="sxs-lookup"><span data-stu-id="b1d8b-158">Create a modified tree</span></span>

<span data-ttu-id="b1d8b-159">하나의 문을 포함하는 작은 구문 트리를 빌드했습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="b1d8b-160">단일 문 또는 기타 작은 코드 블록을 만드는 데는 새 노드를 만드는 API를 사용하는 것이 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="b1d8b-161">그러나 더 큰 코드 블록을 빌드하려면 노드를 바꾸거나 노드를 기존 트리에 삽입하는 메서드를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="b1d8b-162">구문 트리는 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="b1d8b-163">**구문 API**는 생성 후 기존 구문 트리를 수정하기 위한 메커니즘을 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="b1d8b-164">대신 기존 트리에 대한 변경 내용을 기반으로 새 트리를 생성하는 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="b1d8b-165">`With*` 메서드는 <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> 클래스에서 선언된 확장 메서드 또는 <xref:Microsoft.CodeAnalysis.SyntaxNode>에서 파생되는 구체적인 클래스에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="b1d8b-166">이러한 메서드는 기존 노드의 자식 속성에 변경 내용을 적용하여 새 노드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="b1d8b-167">또한 <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> 확장 메서드를 사용하여 하위 트리의 하위 노드를 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="b1d8b-168">이 메서드는 새로 만들어진 자식을 가리키도록 부모를 업데이트하고 전체 트리에서 이 프로세스를 반복합니다(트리 ‘재회전’으로 알려진 프로세스).</span><span class="sxs-lookup"><span data-stu-id="b1d8b-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spining_ the tree.</span></span>

<span data-ttu-id="b1d8b-169">다음 단계에서는 전체(작은) 프로그램을 나타내는 트리를 만든 다음, 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="b1d8b-170">다음 코드를 `Program` 클래스의 시작 부분에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="b1d8b-171">예제 코드는 `System.Collections.Generic` 네임스페이스가 아닌 `System.Collections` 네임스페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="b1d8b-172">다음으로 `Main` 메서드의 맨 아래에 다음 코드를 추가하여 텍스트를 구문 분석하고 트리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="b1d8b-173">이 예제는 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> 메서드를 사용하여 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> 노드의 이름을 이전 코드에서 생성된 이름으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="b1d8b-174"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> 메서드를 통해 새 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> 노드를 만들어 `System.Collections` 이름을 이전 코드에서 만든 이름으로 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="b1d8b-175">`Main` 메서드의 맨 아래에 다음 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="b1d8b-176">프로그램을 실행하고 출력을 신중하게 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="b1d8b-177">`newusing`이 루트 트리에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-177">The `newusing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="b1d8b-178">원래 트리가 변경되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="b1d8b-179"><xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> 확장 메서드를 통해 다음 코드를 추가하여 새 트리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="b1d8b-180">새 트리는 기존 가져오기를 업데이트된 `newUsing` 노드로 바꾼 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="b1d8b-181">기존 `root` 변수에 이 새 트리를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="b1d8b-182">프로그램을 다시 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-182">Run the program again.</span></span> <span data-ttu-id="b1d8b-183">이제 트리가 `System.Collections.Generic` 네임스페이스를 올바르게 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="b1d8b-184">`SyntaxRewriters`를 사용하여 트리 변환</span><span class="sxs-lookup"><span data-stu-id="b1d8b-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="b1d8b-185">`With*` 및 <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> 메서드는 구문 트리의 개별 분기를 변환하는 편리한 수단을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="b1d8b-186"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> 클래스는 구문 트리에서 여러 변환을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="b1d8b-187"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> 클래스는 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>의 서브클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b1d8b-188"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter>은 특정 형식의 <xref:Microsoft.CodeAnalysis.SyntaxNode>에 변환을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="b1d8b-189">구문 트리에 나타날 때마다 여러 형식의 <xref:Microsoft.CodeAnalysis.SyntaxNode> 개체에 변환을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="b1d8b-190">이 빠른 시작의 두 번째 프로젝트는 형식 유추를 사용할 수 있는 모든 위치에서 지역 변수 선언의 명시적 형식을 제거하는 명령줄 리팩터링을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="b1d8b-191">새 C# **독립 실행형 코드 분석 도구** 프로젝트를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="b1d8b-192">Visual Studio에서 `SyntaxTransformationQuickStart` 솔루션 노드를 마우스 오른쪽 단추로 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="b1d8b-193">**추가** > **새 프로젝트**를 선택하여 **새 프로젝트 대화 상자**를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="b1d8b-194">**Visual C#** > **확장성** 아래에서 **독립 실행형 코드 분석 도구**를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="b1d8b-195">프로젝트 이름을 `TransformationCS`로 지정하고 [확인]을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="b1d8b-196">첫 번째 단계는 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter>에서 파생되는 클래스를 만들어 변환을 수행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="b1d8b-197">프로젝트에 새 클래스 파일을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-197">Add a new class file to the project.</span></span> <span data-ttu-id="b1d8b-198">Visual Studio에서 **프로젝트** > **클래스 추가...** 를 선택합니다. **새 항목 추가** 대화 상자에서 파일 이름으로 `TypeInferenceRewriter.cs`를 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="b1d8b-199">다음 using 지시문을 `TypeInferenceRewriter.cs` 파일에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="b1d8b-200">다음으로 `TypeInferenceRewriter` 클래스가 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> 클래스를 확장하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="b1d8b-201">다음 코드를 추가하여 <xref:Microsoft.CodeAnalysis.SemanticModel>을 포함할 전용 읽기 전용 필드를 선언하고 생성자에서 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="b1d8b-202">이 필드는 나중에 형식 유추를 사용할 수 있는 위치를 판별하는 데 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="b1d8b-203"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```C#
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="b1d8b-204">많은 Roslyn API는 반환된 실제 런타임 형식의 기본 클래스인 반환 형식을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="b1d8b-205">n개의 시나리오, 한 종류의 노드는 다른 종류의 노드로 완전히 바뀌거나 제거될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-205">n many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="b1d8b-206">이 예제에서 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> 메서드는 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> 파생 형식 대신 <xref:Microsoft.CodeAnalysis.SyntaxNode>를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="b1d8b-207">이 재작성기는 기존 노드를 기반으로 새 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> 노드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="b1d8b-208">이 빠른 시작은 지역 변수 선언을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="b1d8b-209">이 선언은 `foreach` 루프, `for` 루프, LINQ식 및 람다 식과 같은 다른 선언으로 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="b1d8b-210">또한 이 재작성기는 가장 단순한 형식의 선언만 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="b1d8b-211">혼자서 살펴보려면 다음 형식의 변수 선언에 대한 완료된 샘플을 확장해 보세요.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="b1d8b-212">다음 코드를 `VisitLocalDeclarationStatement` 메서드의 본문에 추가하여 이러한 선언 형식의 재작성을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="b1d8b-213">이 메서드는 수정되지 않은 `node` 매개 변수를 반환하여 재작성이 발생하지 않음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="b1d8b-214">해당 `if` 식 모두가 true가 아닌 경우 노드는 초기화를 통해 가능한 선언을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="b1d8b-215">다음 문을 추가하여 선언에 지정된 형식 이름을 추출하고 <xref:Microsoft.CodeAnalysis.SemanticModel> 필드를 통해 형식 이름을 바인딩하여 형식 기호를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="b1d8b-216">이제 이 문을 추가하여 이니셜라이저 식을 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="b1d8b-217">마지막으로 다음 `if` 문을 추가하여 이니셜라이저 식의 형식이 지정된 형식과 일치하는 경우 기존 형식 이름을 `var` 키워드로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Replace the initializer node")]

<span data-ttu-id="b1d8b-218">선언은 이니셜라이저 식을 기본 클래스 또는 인터페이스로 캐스트할 수 있기 때문에 조건이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="b1d8b-219">필요한 경우 할당의 왼쪽 및 오른쪽에 있는 형식이 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="b1d8b-220">이러한 사례에서 명시적 형식을 제거하면 프로그램의 의미 체계가 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="b1d8b-221">`var`은 상황별 키워드이므로 `var`은 키워드가 아니라 식별자로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="b1d8b-222">선행 및 후행 기타 정보(공백)는 세로 공백과 들여쓰기를 유지하기 위해 이전 형식 이름에서 `var` 키워드로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-222">The leading and trailing trivia (whitespace) are transferred from the old type name to the `var` keyword to maintain vertical whitespace and indentation.</span></span> <span data-ttu-id="b1d8b-223">형식 이름은 실제로 선언문의 손자이므로 `With*` 대신 `ReplaceNode`를 사용하여 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>를 변환하는 것이 더 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="b1d8b-224">`TypeInferenceRewriter`를 완료했습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="b1d8b-225">이제 `Program.cs` 파일로 돌아가서 예제를 완료합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="b1d8b-226">테스트 <xref:Microsoft.CodeAnalysis.Compilation>을 만들고 <xref:Microsoft.CodeAnalysis.SemanticModel>을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="b1d8b-227"><xref:Microsoft.CodeAnalysis.SemanticModel>을 사용하여 `TypeInferenceRewriter`를 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="b1d8b-228">이 단계는 마지막으로 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-228">You'll do this step last.</span></span> <span data-ttu-id="b1d8b-229">그동안 테스트 컴파일을 나타내는 자리 표시자 변수를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="b1d8b-230">잠시 후에 `CreateTestCompilation` 메서드가 없음을 보고하는 오류 물결선이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="b1d8b-231">**Ctrl+마침표**를 눌러 전구를 열고 Enter 키를 눌러 **메서드 스텁 생성** 명령을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="b1d8b-232">이 명령은 `Program` 클래스에서 `CreateTestCompilation` 메서드에 대한 메서드 스텁을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="b1d8b-233">나중에 돌아와서 이 메서드를 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-233">You'll come back to fill in this method later:</span></span>

![사용법에서 C# 메서드 생성](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="b1d8b-235">다음 코드를 작성하여 테스트 <xref:Microsoft.CodeAnalysis.Compilation>에서 각 <xref:Microsoft.CodeAnalysis.SyntaxTree>를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="b1d8b-236">각 트리에 대해 해당 트리의 <xref:Microsoft.CodeAnalysis.SemanticModel>을 사용하여 새 `TypeInferenceRewriter`를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="b1d8b-237">직접 만든 `foreach` 문 내부에 다음 코드를 추가하여 각 소스 트리에서 변환을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="b1d8b-238">이 코드는 편집이 수행된 경우 변환된 새 트리를 조건부로 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="b1d8b-239">재작성기는 형식 유추를 사용하여 단순화할 수 있는 하나 이상의 지역 변수 선언이 발생하는 경우에만 트리를 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="b1d8b-240">`File.WriteAllText` 코드 아래에 물결선이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="b1d8b-241">전구를 선택하고 필요한 `using System.IO;` 문을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="b1d8b-242">거의 완료되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-242">You're almost done!</span></span> <span data-ttu-id="b1d8b-243">한 단계가 남았습니다. 테스트 <xref:Microsoft.CodeAnalysis.Compilation> 만들기.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-243">There's once step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="b1d8b-244">이 빠른 시작 중에 형식 유추를 사용하지 않았으므로 완벽한 테스트 사례를 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="b1d8b-245">그러나 C# 프로젝트 파일에서 컴파일을 만드는 작업은 이 연습의 범위를 벗어납니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="b1d8b-246">그래도 지침을 신중하게 수행했다면 희망적입니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="b1d8b-247">`CreateTestCompilation` 메서드의 내용을 다음 코드로 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="b1d8b-248">이 코드는 이 빠른 시작에 설명된 프로젝트와 조건부로 일치하는 테스트 컴파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="b1d8b-249">행운을 빌고 프로젝트를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="b1d8b-250">Visual Studio에서 **디버그** > **디버깅 시작**을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="b1d8b-251">Visual Studio에서 프로젝트의 파일이 변경되었다는 메시지가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="b1d8b-252">“**모두 예**”를 클릭하여 수정된 파일을 다시 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="b1d8b-253">해당 파일을 살펴보면 놀라운 것을 관찰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="b1d8b-254">모든 명시적 및 중복 형식 지정자가 없는 코드는 놀라울 정도로 깔끔해 보입니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="b1d8b-255">지금까지</span><span class="sxs-lookup"><span data-stu-id="b1d8b-255">Congratulations!</span></span> <span data-ttu-id="b1d8b-256">**컴파일러 API**를 사용하여 C# 프로젝트에서 특정 구문 패턴에 대한 모든 파일을 검색하고, 해당 패턴과 일치하는 소스 코드의 의미 체계를 분석하고, 소스 코드를 변환하는 고유한 리팩터링을 작성했습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="b1d8b-257">이제 공식적으로 리팩터링 작성자가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b1d8b-257">You're now officially refactoring author!</span></span>
---
title: Visual Basic의 새로운 기능
ms.date: 02/15/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 09a113130d29336ecabb52095ca7f5809f5f0ade
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33592550"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="f202f-102">Visual Basic의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="f202f-102">What's new for Visual Basic</span></span>

<span data-ttu-id="f202f-103">이 항목에는 각 Visual Basic 버전의 주요 기능 이름과 최신 Visual Basic 버전의 새로운 기능 및 향상된 기능에 대한 자세한 설명이 정리되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the lastest version of the language.</span></span>
  
## <a name="current-version"></a><span data-ttu-id="f202f-104">현재 버전</span><span class="sxs-lookup"><span data-stu-id="f202f-104">Current Version</span></span>

<span data-ttu-id="f202f-105">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="f202f-105">Visual Basic 15.5</span></span>   
<span data-ttu-id="f202f-106">새로운 기능은 [Visual Basic 15.5](#visual-basic-155)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f202f-106">For new features, see [Visual Basic 15.5](#visual-basic-155)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="f202f-107">이전 버전</span><span class="sxs-lookup"><span data-stu-id="f202f-107">Previous versions</span></span>

<span data-ttu-id="f202f-108">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="f202f-108">Visual Basic 15.3</span></span>   
<span data-ttu-id="f202f-109">새로운 기능은 [Visual Basic 15.3](#visual-basic-153)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f202f-109">For new features, see [Visual Basic 15.3](#visual-basic-153)</span></span>

<span data-ttu-id="f202f-110">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="f202f-110">Visual Basic 2017</span></span>   
<span data-ttu-id="f202f-111">새로운 기능은 [Visual Basic 2017](#visual-basic-2017)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f202f-111">For new features, see [Visual Basic 2017](#visual-basic-2017)</span></span>

<span data-ttu-id="f202f-112">Visual Basic / Visual Studio .NET 2015</span><span class="sxs-lookup"><span data-stu-id="f202f-112">Visual Basic / Visual Studio .NET 2015</span></span>   
<span data-ttu-id="f202f-113">새로운 기능은 [Visual Basic 14](#visual-basic-14)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f202f-113">For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="f202f-114">Visual Basic / Visual Studio .NET 2013</span><span class="sxs-lookup"><span data-stu-id="f202f-114">Visual Basic / Visual Studio .NET 2013</span></span>  
<span data-ttu-id="f202f-115">.NET 컴파일러 플랫폼("Roslyn")의 기술 미리 보기</span><span class="sxs-lookup"><span data-stu-id="f202f-115">Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="f202f-116">Visual Basic / Visual Studio .NET 2012</span><span class="sxs-lookup"><span data-stu-id="f202f-116">Visual Basic / Visual Studio .NET 2012</span></span>   
<span data-ttu-id="f202f-117">`Async` 및 `await` 키워드, 반복기, 호출자 정보 특성</span><span class="sxs-lookup"><span data-stu-id="f202f-117">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="f202f-118">Visual Basic, Visual Studio .NET 2010</span><span class="sxs-lookup"><span data-stu-id="f202f-118">Visual Basic, Visual Studio .NET 2010</span></span>   
<span data-ttu-id="f202f-119">자동으로 구현된 속성, 컬렉션 이니셜라이저, 암시적 줄 연속, 동적, 제네릭 공변성(Covariance)/반공변성(Contravariance), 전역 네임스페이스 액세스</span><span class="sxs-lookup"><span data-stu-id="f202f-119">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="f202f-120">Visual Basic / Visual Studio .NET 2008</span><span class="sxs-lookup"><span data-stu-id="f202f-120">Visual Basic / Visual Studio .NET 2008</span></span>   
<span data-ttu-id="f202f-121">LINQ(통합 언어 쿼리), XML 리터럴, 지역 형식 유추, 개체 이니셜라이저, 익명 형식, 확장 메서드, 로컬 `var` 형식 유추, 람다 식, `if` 연산자, 부분 메서드(Partial Method), nullable 값 형식</span><span class="sxs-lookup"><span data-stu-id="f202f-121">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>  

<span data-ttu-id="f202f-122">Visual Basic / Visual Studio .NET 2005</span><span class="sxs-lookup"><span data-stu-id="f202f-122">Visual Basic / Visual Studio .NET 2005</span></span>   
<span data-ttu-id="f202f-123">`My` 형식 및 도우미 형식(앱, 컴퓨터, 파일 시스템, 네트워크에 액세스)</span><span class="sxs-lookup"><span data-stu-id="f202f-123">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="f202f-124">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="f202f-124">Visual Basic / Visual Studio .NET 2003</span></span>   
<span data-ttu-id="f202f-125">비트 시프트 연산자, 루프 변수 선언</span><span class="sxs-lookup"><span data-stu-id="f202f-125">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="f202f-126">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="f202f-126">Visual Basic / Visual Studio .NET 2002</span></span>   
<span data-ttu-id="f202f-127">Visual Basic .NET의 첫 번째 릴리스</span><span class="sxs-lookup"><span data-stu-id="f202f-127">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="f202f-128">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="f202f-128">Visual Basic 15.5</span></span>

[<span data-ttu-id="f202f-129">뒤에 오지 않는 명명된 인수</span><span class="sxs-lookup"><span data-stu-id="f202f-129">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="f202f-130">Visual Basic 15.3 및 이전 버전에서 메서드 호출이 위치 및 이름별 인수를 포함하는 경우 위치 인수는 명명된 인수 앞에 와야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-130">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="f202f-131">Visual Basic 15.5부터 위치 및 명명된 인수는 마지막 위치 인수까지 모든 인수가 올바른 위치에 있는 한 순서에 관계 없이 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-131">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="f202f-132">이는 명명된 인수가 코드를 더 쉽게 읽을 수 있도록 사용되는 경우 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-132">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="f202f-133">예를 들어 다음 메서드 호출은 명명된 인수 사이에 두 개의 위치 인수를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-133">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="f202f-134">명명된 인수는 값 19가 나이를 나타낸다는 것을 명백하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-134">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

<span data-ttu-id="f202f-135">**선행 16진수/이진/8진수 구분 기호**</span><span class="sxs-lookup"><span data-stu-id="f202f-135">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="f202f-136">Visual Basic 2017은 숫자 구분 기호로 밑줄 문자(`_`)에 대한 지원을 추가했습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-136">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="f202f-137">Visual Basic 15.5부터 접두사와 16 진수, 이진 또는 8진수 숫자 사이의 선행 구분 기호로 밑줄 문자를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-137">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="f202f-138">다음 예제에서는 선행 숫자 구분 기호를 사용하여 16진수 숫자로 3,271,948,384를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-138">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
``` 
<span data-ttu-id="f202f-139">선행 구분 기호로 밑줄 문자를 사용하려면 Visual Basic 프로젝트(\*.vbproj) 파일에 다음 요소를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-139">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="f202f-140">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="f202f-140">Visual Basic 15.3</span></span>

[<span data-ttu-id="f202f-141">**명명된 튜플 유추**</span><span class="sxs-lookup"><span data-stu-id="f202f-141">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="f202f-142">변수에서 튜플 요소의 값을 할당할 때 Visual Basic는 해당 변수 이름에서 튜플 요소의 이름을 유추합니다. 튜블 요소의 이름을 명시적으로 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-142">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="f202f-143">다음 예제에서는 유추를 사용하여 세 개의 명명된 요소, `state`, `stateName` 및 `capital`로 튜플을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-143">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="f202f-144">**추가 컴파일러 스위치**</span><span class="sxs-lookup"><span data-stu-id="f202f-144">**Additional compiler switches**</span></span>  

<span data-ttu-id="f202f-145">이제 Visual Basic 명령줄 컴파일러는 참조 어셈블리의 출력을 제어하기 위해 [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) 및 [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) 컴파일러 옵션을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-145">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="f202f-146">**-refout**는 참조 어셈블리의 출력 디렉터리를 정의하고 **-refonly**는 참조 어셈블리만 컴파일로 출력되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-146">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="f202f-147">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="f202f-147">Visual Basic 2017</span></span>

[<span data-ttu-id="f202f-148">**튜플**</span><span class="sxs-lookup"><span data-stu-id="f202f-148">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="f202f-149">튜플은 단일 메서드 호출에서 여러 값을 반환하는 데 주로 사용되는 간단한 데이터 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-149">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="f202f-150">일반적으로 하나의 메서드에서 여러 값을 반환하려면 다음 중 하나를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-150">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="f202f-151">사용자 지정 형식(`Class` 또는 `Structure`)을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-151">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="f202f-152">이는 대규모 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-152">This is a heavyweight solution.</span></span>

- <span data-ttu-id="f202f-153">메서드에서 값을 반환하는 것 외에도 `ByRef` 매개 변수를 하나 이상 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-153">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>
 
<span data-ttu-id="f202f-154">Visual Basic의 튜플 지원을 사용하면 튜플을 신속하게 정의하고, 필요에 따라 해당 값에 의미 체계 이름을 할당하고, 해당 값을 빠르게 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-154">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="f202f-155">다음 예제에서는 <xref:System.Int32.TryParse%2A> 메서드 호출을 래핑하고 튜플을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-155">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="f202f-156">그런 다음 메서드를 호출하고 반환된 튜플을 코드에서 다음과 같이 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-156">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)] 

<span data-ttu-id="f202f-157">**이진 리터럴 및 자릿수 구분 기호**</span><span class="sxs-lookup"><span data-stu-id="f202f-157">**Binary literals and digit separators**</span></span>

<span data-ttu-id="f202f-158">`&B` 또는 `&b` 접두사를 사용하여 이진 리터럴을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-158">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="f202f-159">또한 밑줄 문자 `_`를 자릿수 구분 기호로 사용하여 가독성을 향상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-159">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="f202f-160">다음 예제에서는 두 기능을 모두 사용하여 `Byte` 값을 할당하고 10진수, 16진수, 이진수로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-160">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="f202f-161">자세한 내용은 [바이트](../language-reference/data-types/byte-data-type.md#literal-assignments), [정수](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) 및 [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) 데이터 형식의 "리터럴 할당" 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f202f-161">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

<span data-ttu-id="f202f-162">**C# 참조 반환 값 지원**</span><span class="sxs-lookup"><span data-stu-id="f202f-162">**Support for C# reference return values**</span></span>

<span data-ttu-id="f202f-163">C# 7.0부터 C#에서 참조 반환 값을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-163">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="f202f-164">즉, 호출하는 메서드가 참조로 반환된 값을 받을 때 참조 값을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-164">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="f202f-165">Visual Basic에서 참조 반환 값이 있는 메서드를 작성할 수는 없지만 참조 반환 값을 사용하고 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-165">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="f202f-166">예를 들어 C#으로 작성된 다음 `Sentence` 클래스에는 문장 내에서 지정한 하위 문자열로 시작하는 다음 단어를 찾는 `FindNext` 메서드가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-166">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="f202f-167">문자열은 참조 반환 값으로 반환되며, 메서드에 참조로 전달된 `Boolean` 변수는 검색에 성공했는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-167">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="f202f-168">즉, 호출자는 반환된 값을 읽을 수 있을 뿐만 아니라 수정할 수도 있으며, 수정 내용이 `Sentence` 클래스에 반영됩니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-168">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="f202f-169">가장 간단한 형태로, 문장에서 찾은 단어를 코드에서 다음과 같이 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-169">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="f202f-170">메서드 대신 메서드가 반환하는 식, 즉 참조 반환 값에 값을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-170">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="f202f-171">그러나 이 코드의 문제는 일치 항목이 없을 경우 메서드가 첫 번째 단어를 반환한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-171">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="f202f-172">이 예제에서는 `Boolean` 인수의 값을 검사하여 일치 항목이 있는지 확인하지 않으므로 일치 항목이 없을 경우 첫 번째 단어를 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-172">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="f202f-173">다음 예제에서는 일치 항목이 없을 경우 첫 번째 단어를 해당 단어로 대체하여 이 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-173">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="f202f-174">더 나은 해결 방법은 참조 반환 값이 참조로 전달되는 도우미 메서드를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-174">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="f202f-175">그러면 도우미 메서드가 참조로 전달된 인수를 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-175">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="f202f-176">다음 예제에서는 해당 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-176">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="f202f-177">자세한 내용은 [참조 반환 값](../programming-guide/language-features/procedures/ref-return-values.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f202f-177">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="f202f-178">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="f202f-178">Visual Basic 14</span></span>

[<span data-ttu-id="f202f-179">Nameof</span><span class="sxs-lookup"><span data-stu-id="f202f-179">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)  
 <span data-ttu-id="f202f-180">문자열을 하드 코드하지 않고 오류 메시지에서 사용하기 위해 형식이나 멤버의 정규화되지 않은 문자열 이름을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-180">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="f202f-181">이 기능을 사용하면 리팩터링할 때 코드를 올바르게 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-181">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="f202f-182">이 기능은 MVC(Model-View-Controller) 링크를 연결하고 속성 변경 이벤트를 발생시키는 데도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-182">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>  
  
[<span data-ttu-id="f202f-183">문자열 보간</span><span class="sxs-lookup"><span data-stu-id="f202f-183">String Interpolation</span></span>](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)  
 <span data-ttu-id="f202f-184">문자열 보간 식을 사용하여 문자열을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-184">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="f202f-185">보간된 문자열 식은 식이 포함된 템플릿 문자열과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-185">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="f202f-186">보간된 문자열은 인수 측면에서 [Composite Formatting](../../standard/base-types/composite-format.md)보다 이해하기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-186">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>  
  
[<span data-ttu-id="f202f-187">Null 조건부 멤버 액세스 및 인덱싱</span><span class="sxs-lookup"><span data-stu-id="f202f-187">Null-conditional Member Access and Indexing</span></span>](../../csharp/language-reference/operators/null-conditional-operators.md)  
<span data-ttu-id="f202f-188">멤버 액세스(`?.`) 또는 인덱스(`?[]`) 작업을 수행하기 전에 매우 간단한 구문을 사용하여 null 테스트를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-188">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="f202f-189">이러한 연산자는 null 검사의 처리를 위해 작성하는 코드의 양을 줄이는 데 도움이 되며 특히 데이터 구조에서 아래로 내려가는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-189">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="f202f-190">왼쪽 피연산자 또는 개체 참조가 null이면 연산에서 null이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-190">If the left operand or object reference is null, the operations returns null.</span></span>  
  
[<span data-ttu-id="f202f-191">다중 선 문자열 리터럴</span><span class="sxs-lookup"><span data-stu-id="f202f-191">Multi-line String Literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  
 <span data-ttu-id="f202f-192">문자열 리터럴에 줄 바꿈 시퀀스가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-192">String literals can contain newline sequences.</span></span>  <span data-ttu-id="f202f-193">`<xml><![CDATA[...text with newlines...]]></xml>.Value` 사용과 관련된 이전 작업은 더 이상 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-193">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>  
  
<span data-ttu-id="f202f-194">설명</span><span class="sxs-lookup"><span data-stu-id="f202f-194">Comments</span></span>  
<span data-ttu-id="f202f-195">암시적 줄 연속 뒤, 이니셜라이저 식 내부 및 LINQ 식 항 사이에 주석을 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-195">You can put comments after implicit line continuations, inside initializer expressions, and amongst LINQ expression terms.</span></span>  
  
 <span data-ttu-id="f202f-196">더 효율적인 정규화된 이름 확인</span><span class="sxs-lookup"><span data-stu-id="f202f-196">Smarter Fully-qualified Name Resolution</span></span>  
 <span data-ttu-id="f202f-197">`Threading.Thread.Sleep(1000)`과 같은 코드가 제공된 경우 이전에는 Visual Basic에서 "Threading" 네임스페이스를 조회하고 System.Threading 및 System.Windows.Threading 간에 모호하다는 사실을 발견한 후 오류를 보고했습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-197">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="f202f-198">이제 Visual Basic에서는 두 가지 가능한 네임스페이스를 함께 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-198">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="f202f-199">완성 목록을 표시하는 경우 Visual Studio 편집기에서 두 형식의 멤버가 모두 완성 목록에 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-199">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>  
  
 <span data-ttu-id="f202f-200">연도가 먼저 나오는 날짜 리터럴</span><span class="sxs-lookup"><span data-stu-id="f202f-200">Year-first Date Literals</span></span>  
 <span data-ttu-id="f202f-201">yyyy-mm-dd 형식(`#2015-03-17 16:10 PM#`)의 날짜 리터럴을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-201">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>  
  
 <span data-ttu-id="f202f-202">읽기 전용 인터페이스 속성</span><span class="sxs-lookup"><span data-stu-id="f202f-202">Readonly Interface Properties</span></span>  
 <span data-ttu-id="f202f-203">읽기/쓰기 속성을 사용하여 읽기 전용 인터페이스 속성을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-203">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="f202f-204">이러한 인터페이스는 최소 기능을 보장하며 구현 클래스에서 속성이 설정되도록 허용하는 것을 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-204">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>  
  
 [<span data-ttu-id="f202f-205">TypeOf \<expr> IsNot \<type></span><span class="sxs-lookup"><span data-stu-id="f202f-205">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)  
 <span data-ttu-id="f202f-206">코드를 더 읽기 쉽게 만들기 위해 `IsNot`과 함께 `TypeOf`를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-206">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>  
  
 [<span data-ttu-id="f202f-207">#Disable Warning \<ID> 및 #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="f202f-207">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/directives.md)  
 <span data-ttu-id="f202f-208">소스 파일 내의 영역에 대한 특정 경고를 사용하지 않거나 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-208">You can disable and enable specific warnings for regions within a source file.</span></span>  
  
 <span data-ttu-id="f202f-209">XML 문서 주석 향상</span><span class="sxs-lookup"><span data-stu-id="f202f-209">XML Doc-comment Improvements</span></span>  
 <span data-ttu-id="f202f-210">문서 주석을 작성하면 편집기의 효율성을 높이고 매개 변수 이름의 유효성 검사, `crefs`(제네릭, 연산자 등)의 적절한 처리, 색 지정 및 리팩터링에 대한 지원을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-210">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>  
  
 [<span data-ttu-id="f202f-211">부분 모듈 및 인터페이스 정의</span><span class="sxs-lookup"><span data-stu-id="f202f-211">Partial Module and Interface Definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)  
 <span data-ttu-id="f202f-212">클래스 및 구조체 외에도 부분 모듈과 인터페이스를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-212">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>  
  
 [<span data-ttu-id="f202f-213">메서드 본문 내의 #Region 지시문</span><span class="sxs-lookup"><span data-stu-id="f202f-213">#Region Directives inside Method Bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)  
 <span data-ttu-id="f202f-214">#Region…#End Region 구분 기호를 파일의 원하는 위치, 함수 내부 및 여러 함수 본문을 포괄하여 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-214">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>  
  
 [<span data-ttu-id="f202f-215">Overrides 정의는 암시적으로 Overloads임</span><span class="sxs-lookup"><span data-stu-id="f202f-215">Overrides Definitions are Implicitly Overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)  
 <span data-ttu-id="f202f-216">`Overrides` 한정자를 정의에 추가하면 일반적인 경우에 더 적은 코드를 입력할 수 있도록 컴파일러에서 암시적으로 `Overloads`를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-216">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>  
  
 <span data-ttu-id="f202f-217">특성 인수에서 허용되는 CObj</span><span class="sxs-lookup"><span data-stu-id="f202f-217">CObj Allowed in Attributes Arguments</span></span>  
 <span data-ttu-id="f202f-218">이전에는 컴파일러에서 CObj(...)가 특성 생성에서 사용될 때 상수가 아니라는 오류를 제공했습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-218">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>  
  
 <span data-ttu-id="f202f-219">여러 인터페이스의 모호한 메서드 선언 및 사용</span><span class="sxs-lookup"><span data-stu-id="f202f-219">Declaring and Consuming Ambiguous Methods from Different Interfaces</span></span>  
 <span data-ttu-id="f202f-220">이전에는 다음 코드에서 `IMock`을 선언하거나 `GetDetails`를 호출하지 못하게 하는 오류가 발생했습니다(이러한 항목이 C#에서 선언된 경우).</span><span class="sxs-lookup"><span data-stu-id="f202f-220">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>  
  
```vb  
Interface ICustomer  
  Sub GetDetails(x As Integer)  
End Interface  
  
Interface ITime  
  Sub GetDetails(x As String)  
End Interface  
  
Interface IMock : Inherits ICustomer, ITime  
  Overloads Sub GetDetails(x As Char)  
End Interface  
  
Interface IMock2 : Inherits ICustomer, ITime  
End Interface  
```  
  
 <span data-ttu-id="f202f-221">이제 컴파일러에서 일반 오버로드 확인 규칙을 사용하여 호출하는 데 가장 적합한 `GetDetails`를 선택하며, 샘플에서와 같이 Visual Basic에서 인터페이스 관계를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f202f-221">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f202f-222">참고 항목</span><span class="sxs-lookup"><span data-stu-id="f202f-222">See also</span></span>  
 [<span data-ttu-id="f202f-223">Visual Studio 2017의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="f202f-223">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)
